<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vscode设置一键同步--settings sync</title>
      <link href="/leader755/835.html"/>
      <url>/leader755/835.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近换了新工作，然后作为程序猿首先是编辑器的设置。但是每个人的编辑器都有自己的编程习惯的。那能不能将 vscode 的编辑器设置同步呢？答案是有的：setttings-async</p></blockquote><h2 id="1-vscode-插件中查找插件-setting-sync"><a href="#1-vscode-插件中查找插件-setting-sync" class="headerlink" title="1.vscode 插件中查找插件 setting-sync"></a>1.vscode 插件中查找插件 setting-sync</h2><p>下面这个插件可以把当前的配置上传到 gist，所以需要去创建 gist。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599917112978-ee13d880-b9d9-48cf-84f4-3948e435f7c8.png#align=left&display=inline&height=534&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1068&originWidth=650&size=100569&status=done&style=none&width=325" alt="image.png"></p><h2 id="2-在-github-上创建-gist，并查看-token-和-gist-id-信息（查看信息只做验证，不需要保存）"><a href="#2-在-github-上创建-gist，并查看-token-和-gist-id-信息（查看信息只做验证，不需要保存）" class="headerlink" title="2.在 github 上创建 gist，并查看 token 和 gist id 信息（查看信息只做验证，不需要保存）"></a>2.在 github 上创建 gist，并查看 token 和 gist id 信息（查看信息只做验证，不需要保存）</h2><h3 id="1）github-settings-gt-Developer-settings"><a href="#1）github-settings-gt-Developer-settings" class="headerlink" title="1）github settings-&gt;Developer settings"></a>1）github settings-&gt;Developer settings</h3><p><strong>登录 github,点击用户头像–&gt; settings,进入设置界面-&gt;点击左侧 Developer settings，进入开发者设置。</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599917634153-a4c8924e-5512-42c6-afd7-c9df46203dd4.png#align=left&display=inline&height=690&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1380&originWidth=2458&size=573967&status=done&style=none&width=1229" alt="image.png"></p><h3 id="2）创建-Generate-new-token"><a href="#2）创建-Generate-new-token" class="headerlink" title="2）创建 Generate new token"></a>2）创建 Generate new token</h3><p><strong>选择 Personal access tokens，点击右侧 Generate new token</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599917720348-0dabbbc3-4759-4d12-b837-9b4e7d84e9f6.png#align=left&display=inline&height=226&margin=%5Bobject%20Object%5D&name=image.png&originHeight=452&originWidth=2368&size=90751&status=done&style=none&width=1184" alt="image.png"></p><h3 id="3）生成新-token"><a href="#3）生成新-token" class="headerlink" title="3）生成新 token"></a>3）生成新 token</h3><p><strong>填写 token 名称，在下方勾选 gist。点击下面按钮，生成新的 token（注意只需要勾选 gist 项）</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599917796086-d7370670-8d50-40f7-acd8-4b03faa1067c.png#align=left&display=inline&height=1545&margin=%5Bobject%20Object%5D&name=image.png&originHeight=3090&originWidth=2074&size=570099&status=done&style=none&width=1037" alt="image.png"></p><h3 id="4-查看新生成的-token"><a href="#4-查看新生成的-token" class="headerlink" title="4)查看新生成的 token"></a>4)查看新生成的 token</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599918034902-8b062122-6775-4e65-9567-35e03046c961.png#align=left&display=inline&height=270&margin=%5Bobject%20Object%5D&name=image.png&originHeight=540&originWidth=2326&size=101341&status=done&style=none&width=1163" alt="image.png"></p><h3 id="5）查看生成的-gist-id"><a href="#5）查看生成的-gist-id" class="headerlink" title="5）查看生成的 gist id"></a>5）查看生成的 gist id</h3><p><strong>点击用户头像，点击 your gists。</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599918103323-40eca146-45a9-4415-971f-7ce13f45be71.png#align=left&display=inline&height=461&margin=%5Bobject%20Object%5D&name=image.png&originHeight=922&originWidth=1942&size=173097&status=done&style=none&width=971" alt="image.png"></p><p>点击蓝色按钮查看<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599918186497-c45bbf18-871f-4fd4-a1e0-eae38d1c4928.png#align=left&display=inline&height=439&margin=%5Bobject%20Object%5D&name=image.png&originHeight=878&originWidth=1980&size=204822&status=done&style=none&width=990" alt="image.png"><br>跳转到新地址，在新地址后面就可以查看到当前 gist 的 id。<strong>页面不要关闭，后面有用</strong>。仓库后面的一串字符就是 gist ID。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599918303579-bab29066-719a-482b-ac22-910cac076675.png#align=left&display=inline&height=35&margin=%5Bobject%20Object%5D&name=image.png&originHeight=70&originWidth=1230&size=17138&status=done&style=none&width=615" alt="image.png"></p><h2 id="3-插件使用"><a href="#3-插件使用" class="headerlink" title="3.插件使用"></a>3.插件使用</h2><p>在 vscode 中按 F1，查看插件用法和配置<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599918476339-18ee9eac-aa13-494c-a411-3e70dcd2bdf2.png#align=left&display=inline&height=265&margin=%5Bobject%20Object%5D&name=image.png&originHeight=530&originWidth=1254&size=78292&status=done&style=none&width=627" alt="image.png"></p><h3 id="1-gt-首次使用"><a href="#1-gt-首次使用" class="headerlink" title="1&gt;首次使用"></a>1&gt;首次使用</h3><p>选择 “如何配置项”。进入以下页面，选择    ** LOGIN WHITH GITHUB** 项，会跳转到浏览器页面，对 github 的授权页面，放心授权就行，授权成功就可以关闭页面了。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599918541445-4a4deea5-e8ee-4651-9580-c939b5715caf.png#align=left&display=inline&height=742&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1484&originWidth=1892&size=294147&status=done&style=none&width=946" alt="image.png"></p><h3 id="2-gt-同步配置"><a href="#2-gt-同步配置" class="headerlink" title="2&gt;同步配置"></a>2&gt;同步配置</h3><p>按 Shift + Alt + D 同步，粘贴 gist 的 ID 同步设置。</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599918685552-42eaa667-7bd6-481b-8c40-cfe36ea3e952.png#align=left&display=inline&height=700&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1400&originWidth=1708&size=192708&status=done&style=none&width=854" alt="image.png"></h3><h3 id="3-gt-常用的快捷方式"><a href="#3-gt-常用的快捷方式" class="headerlink" title="3&gt;常用的快捷方式"></a>3&gt;常用的快捷方式</h3><pre class=" language-powershell"><code class="language-powershell">1<span class="token punctuation">.</span>上传键：Shift <span class="token operator">+</span> Alt <span class="token operator">+</span> U2<span class="token punctuation">.</span>下载键：Shift <span class="token operator">+</span> Alt <span class="token operator">+</span> D（在macOS上：Shift <span class="token operator">+</span> Option <span class="token operator">+</span> U <span class="token operator">/</span> Shift <span class="token operator">+</span> Option <span class="token operator">+</span> D）</code></pre>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sync </tag>
            
            <tag> settings sync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win安装Nodejs报2503、2502错误解决方案</title>
      <link href="/leader755/36022.html"/>
      <url>/leader755/36022.html</url>
      
        <content type="html"><![CDATA[<p>**</p><blockquote><p><strong>出现 error 2502 和 error2503 是因为 win8 的权限问题所导致的，具体说就是要以管理员身份进行安装就可以解决，下面详细来说一下。</strong></p></blockquote><h2 id="1-创建-nodejs-文件夹"><a href="#1-创建-nodejs-文件夹" class="headerlink" title="1.创建 nodejs 文件夹"></a>1.创建 nodejs 文件夹</h2><p>在 C 盘根目录下创建 ndejs 文件夹，并将 nodejs 安装包放入新创建的文件夹。</p><blockquote><p>注意此步骤是保持 nodejs 的安装包目录和安装目录在同一目录</p></blockquote><h2 id="2-以管理员身份运行-cmd-命令"><a href="#2-以管理员身份运行-cmd-命令" class="headerlink" title="2.以管理员身份运行 cmd 命令"></a><strong>2.</strong>以管理员身份运行 cmd 命令</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1599533265573-89e2d57d-38de-4829-a750-ceac318ba3f9.webp#align=left&display=inline&height=618&margin=%5Bobject%20Object%5D&originHeight=618&originWidth=388&size=0&status=done&style=none&width=388" alt=""><br>以管理员身份运行 cmd</p><h2 id="3-cd-到新创建的-nodejs-文件夹"><a href="#3-cd-到新创建的-nodejs-文件夹" class="headerlink" title="3.cd 到新创建的 nodejs 文件夹"></a>3.cd 到新创建的 nodejs 文件夹</h2><pre class=" language-powershell"><code class="language-powershell">cd <span class="token operator">/</span>nodejs</code></pre><h2 id="4-用-msiexec-安装"><a href="#4-用-msiexec-安装" class="headerlink" title="4.用 msiexec 安装"></a>4.用 msiexec 安装</h2><p>文件名为安装包的 node 文件名（根据实际的路径来安装）</p><pre class=" language-powershell"><code class="language-powershell">msiexec <span class="token operator">/</span>package D:\软件\nodejs\node<span class="token operator">-</span>v12<span class="token punctuation">.</span>18<span class="token punctuation">.</span>3<span class="token operator">-</span>x64<span class="token punctuation">.</span>msi</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599900205862-629859d4-69c3-42fe-ad47-fb4e4a345e11.png#align=left&display=inline&height=653&margin=%5Bobject%20Object%5D&name=image.png&originHeight=653&originWidth=1003&size=56220&status=done&style=none&width=1003" alt="image.png"></p><p>至此，安装完成！<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1599533265538-1f35581b-43c0-417e-a6d9-37765f47a9c4.webp#align=left&display=inline&height=187&margin=%5Bobject%20Object%5D&originHeight=187&originWidth=605&size=0&status=done&style=none&width=605" alt=""><br>查看 nodejs 版本</p><h2 id="5-查看-node-和-npm-版本"><a href="#5-查看-node-和-npm-版本" class="headerlink" title="5.查看 node 和 npm 版本"></a>5.查看 node 和 npm 版本</h2><pre class=" language-powershell"><code class="language-powershell">node <span class="token operator">-</span>vnpm <span class="token operator">-</span>v</code></pre><h2 id="6-配置环境变量"><a href="#6-配置环境变量" class="headerlink" title="6.配置环境变量"></a>6.配置环境变量</h2><blockquote><p>一般情况下，系统默认会设置好环境变量，但是偶尔会出现问题。需要自己去配置环境变量</p></blockquote><h3 id="6-1-配置-npm-的全局模块的存放路径以及-cache-的路径"><a href="#6-1-配置-npm-的全局模块的存放路径以及-cache-的路径" class="headerlink" title="6.1.配置 npm 的全局模块的存放路径以及 cache 的路径"></a>6.1.配置 npm 的全局模块的存放路径以及 cache 的路径</h3><p>在 nodejs 文件夹 下建立 “node_global”及”node_cache” 两个文件夹<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599900234284-c483126a-bf49-40b0-8bad-caba75217516.png#align=left&display=inline&height=352&margin=%5Bobject%20Object%5D&name=image.png&originHeight=352&originWidth=630&size=35229&status=done&style=none&width=630" alt="image.png"></p><h3 id="6-2-启动-cmd，输入"><a href="#6-2-启动-cmd，输入" class="headerlink" title="6.2 启动 cmd，输入"></a>6.2 启动 cmd，输入</h3><blockquote><p>路径需要符合自己的实际情况</p></blockquote><pre class=" language-powershell"><code class="language-powershell">npm config <span class="token function">set</span> prefix <span class="token string">"D:\软件\nodejs\node_global"</span>npm config <span class="token function">set</span> cache <span class="token string">"D:\软件\nodejs\node_cache"</span></code></pre><h3 id="6-3-设置系统变量"><a href="#6-3-设置系统变量" class="headerlink" title="6.3 设置系统变量"></a>6.3 设置系统变量</h3><p>关闭 cmd，打开系统对话框，“我的电脑” 右键 “属性”-“高级系统设置”-“高级”-“环境变量”。如下图</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599626616271-4293e33c-c83e-4d41-abe5-a47001c0bc3a.png#align=left&display=inline&height=636&margin=%5Bobject%20Object%5D&name=image.png&originHeight=636&originWidth=1072&size=68307&status=done&style=none&width=1072" alt="image.png"></p><blockquote><ul><li>*<em>1&gt; 用户变量 *</em><ul><li>*<em>在 用户变量 Path 中添加  *</em></li><li>D:\软件<strong>\nodejs;</strong></li><li>D:\软件<strong>\nodejs\node_modules\npm;</strong></li><li>D:\软件*<em>\nodejs\node_global;    *</em></li><li>** 前面的分号不能少**</li></ul></li></ul></blockquote><blockquote><ul><li><strong>2&gt;环境变量</strong><ul><li><strong>在系统变量下新建 “NODE_PATH”，</strong></li><li><strong>输入”</strong>D:\软件<strong>\nodejs\node_global\node_modules“。</strong></li><li><strong>以后安装安装的 加上 -g 都会下载这个下面</strong></li></ul></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试（8）拷贝</title>
      <link href="/leader755/46928.html"/>
      <url>/leader755/46928.html</url>
      
        <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599388884598-3823412b-fbc8-42fb-8d05-192f3011b049.png#align=left&display=inline&height=1320&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1320&originWidth=2910&size=320693&status=done&style=none&width=2910" alt="image.png"></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599381658009-a92fc3b0-5400-4cff-9f05-754065529eab.png#align=left&display=inline&height=241&margin=%5Bobject%20Object%5D&name=image.png&originHeight=482&originWidth=674&size=26164&status=done&style=none&width=337" alt="image.png"></h3><p>js 的基本数据类型的赋值，就是值传递。引用类型对象的赋值是将对象地址的引用赋值。这时候修改对象中的属性或者值，会导致所有引用这个对象的值改变。如果想要真的复制一个新的对象，而不是复制对象的引用，就要用到对象的深拷贝。</p><h2 id="数据类型（基本数据类型和引用数据类型）"><a href="#数据类型（基本数据类型和引用数据类型）" class="headerlink" title="数据类型（基本数据类型和引用数据类型）"></a>数据类型（基本数据类型和引用数据类型）</h2><h3 id="基本数据类型（栈内存，引用值，深拷贝）"><a href="#基本数据类型（栈内存，引用值，深拷贝）" class="headerlink" title="基本数据类型（栈内存，引用值，深拷贝）"></a>基本数据类型（栈内存，引用值，深拷贝）</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a=3,b=4</span></code></pre><h3 id="引用数据类型（堆内存，引用址，指针指向该地址。浅拷贝）"><a href="#引用数据类型（堆内存，引用址，指针指向该地址。浅拷贝）" class="headerlink" title="引用数据类型（堆内存，引用址，指针指向该地址。浅拷贝）"></a>引用数据类型（堆内存，引用址，指针指向该地址。浅拷贝）</h3><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"引用数据类型"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> arr2 <span class="token operator">=</span> arr1<span class="token punctuation">;</span>arr2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,2,3] [1,2,3]</span></code></pre><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="1-‘-’赋值。只是将对象的引用赋值"><a href="#1-‘-’赋值。只是将对象的引用赋值" class="headerlink" title="1.‘=’赋值。只是将对象的引用赋值"></a>1.‘=’赋值。只是将对象的引用赋值</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"xiaoMing"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{name:'xiaoMing',age:20};</span>a<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"xiaohong"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{name:'xiaohong',age:20}</span></code></pre><p>###</p><h3 id="2-Object-assign"><a href="#2-Object-assign" class="headerlink" title="2.Object.assign()"></a>2.Object.assign()</h3><p>Object.assign 是 ES6 的新函数。Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。<strong>因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。Object.assgin 只能深拷贝第一层, 深层的还是浅拷贝, 记住这个就行了。</strong></p><pre class=" language-javascript"><code class="language-javascript">Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token operator">...</span>sources<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>参数：<br>target：目标对象。<br>sources：任意多个源对象。<br>返回值：目标对象会被返回。</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> source <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token string">"koala"</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"程序员成长指北"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { a: 'koala', b: { name: '程序员成长指北' } }</span>source<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">"smallKoala"</span><span class="token punctuation">;</span>source<span class="token punctuation">.</span>b<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"程序员成长指北哦"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { a: 'smallKoala', b: { name: '程序员成长指北哦' } }</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { a: 'koala', b: { name: '程序员成长指北哦' } }</span></code></pre><blockquote><p>//Object.assign 是浅拷贝，拷贝的是对象的引用值，如果为引用类型对象时，一级属性为深拷贝，对象中有二级属性的话，则二级属性以后都是浅拷贝。</p></blockquote><h3 id="3-扩展运算符（…）"><a href="#3-扩展运算符（…）" class="headerlink" title="3.扩展运算符（…）"></a>3.扩展运算符（…）</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token punctuation">{</span> c<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>obj <span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{a:2,b:{c:1}}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{a:1,b:{c:1}}</span>obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{a:2,b:{c:2}}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{a:1,b:{c:2}}</span></code></pre><blockquote><p>//扩展运算符是浅拷贝，拷贝的是对象的引用值，如果为引用类型对象时，一级属性为深拷贝，如果对象中有二级属性的话，则二级属性以后都是浅拷贝。</p></blockquote><blockquote></blockquote><h3 id="如果对象或者数组中包含子数组和子对象，那子数组或者对象为浅拷贝"><a href="#如果对象或者数组中包含子数组和子对象，那子数组或者对象为浅拷贝" class="headerlink" title="如果对象或者数组中包含子数组和子对象，那子数组或者对象为浅拷贝"></a>如果对象或者数组中包含子数组和子对象，那子数组或者对象为浅拷贝</h3><blockquote><p>原因是…遍历时那部分为对象/数组类型指向原来的地址</p></blockquote><p>###</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> d<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj1 <span class="token operator">=</span> obj<span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//深拷贝常用方法</span><span class="token keyword">var</span> obj3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>obj <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj4 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>c<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">999</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{a: 999, b: 2, c: { a: -999 },d: [123, 5]}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{a: 1, b: 2, c: { a: 3 },d: [4, 5]}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{a: 1, b: 2, c: { a: -999 },d: [123, 5]}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//{a: 1, b: 2, c: { a: -999 },d: [123, 5]}</span></code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr1 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//深拷贝常用方法</span><span class="token keyword">var</span> arr2 <span class="token operator">=</span> arr<span class="token punctuation">;</span><span class="token keyword">var</span> arr3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr4 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token operator">===</span> arr1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token operator">===</span> arr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token operator">===</span> arr3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token operator">===</span> arr4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span>arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">999</span><span class="token punctuation">;</span>arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1, 2, 3, [4, 5], {a: 6, b: 7}]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[999, 2, 3, [-999, 5], {a: 123, b: 7}]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1, 2, 3, [-999, 5], {a: 123, b: 7}]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1, 2, 3, [-999, 5], {a: 123, b: 7}]</span></code></pre><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="1-手动复制"><a href="#1-手动复制" class="headerlink" title="1.手动复制"></a>1.手动复制</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> obj1<span class="token punctuation">.</span>a<span class="token punctuation">,</span> b<span class="token punctuation">:</span> obj1<span class="token punctuation">.</span>b<span class="token punctuation">,</span> c<span class="token punctuation">:</span> obj1<span class="token punctuation">.</span>c <span class="token punctuation">}</span><span class="token punctuation">;</span>obj2<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// { a: 10, b: 20, c: 30 } &lt;-- 沒被改到</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// { a: 10, b: 100, c: 30 }</span></code></pre><h3 id="2-JSON-做字符串转换"><a href="#2-JSON-做字符串转换" class="headerlink" title="2.JSON 做字符串转换"></a>2.JSON 做字符串转换</h3><p>用 JSON.stringify 把对象转成字符串，再用 JSON.parse 把字符串转成新的对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> body<span class="token punctuation">:</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj2<span class="token punctuation">.</span>body<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// { body: { a: 10 } } &lt;-- 沒被改到</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// { body: { a: 20 } }</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1 <span class="token operator">===</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>body <span class="token operator">===</span> obj2<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span></code></pre><blockquote><p><strong>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则。只能序列化对象的可枚举的自有属性。</strong></p></blockquote><p>###</p><h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><p>1.如果 obj 里面有时间对象，则 JSON.stringify 后再 JSON.parse 的结果，时间将只是字符串的形式，而不是对象的形式</p><pre class=" language-javascript"><code class="language-javascript">eg：<span class="token keyword">var</span> test <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'a'</span><span class="token punctuation">,</span>    date<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">1536627600000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">1540047600000</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> b<span class="token punctuation">;</span>  b <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">)</span>；console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>解决方法，将 new Date()变为字符串，new Date().toString()</p></blockquote><p>2.如果 obj 里有 RegExp(正则表达式的缩写)、Error 对象，则序列化的结果将只得到空对象；</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"a"</span><span class="token punctuation">,</span>  date<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">"\\w+"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// debugger</span><span class="token keyword">const</span> copyed <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//console.error('ddd', test, copyed)；</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>copyed<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>**<br><strong>3.如果 obj 里有函数，undefined，则序列化的结果会把函数或 undefined 丢失；</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"a"</span><span class="token punctuation">,</span>  date<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">hehe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"fff"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// debugger</span><span class="token keyword">const</span> copyed <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"ddd"</span><span class="token punctuation">,</span> test<span class="token punctuation">,</span> copyed<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>**<br><strong>4.如果 obj 里有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null</strong><br>**<br><strong>5.JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果 obj 中的对象是有构造函数生成的， 则使用 JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的 constructor；</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">const</span> liai <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"liai"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"a"</span><span class="token punctuation">,</span>  date<span class="token punctuation">:</span> liai<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// debugger</span><span class="token keyword">const</span> copyed <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"ddd"</span><span class="token punctuation">,</span> test<span class="token punctuation">,</span> copyed<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>**<br><strong>6.如果对象中存在循环引用的情况也无法正确实现深拷贝；</strong><br><strong>总结：</strong><br>用法简单，然而使用这种方法会有一些隐藏的坑：因为在序列化 JavaScript 对象时，所有函数和原型成员会被有意忽略。<br>通俗点说，JSON.parse(JSON.stringfy(X))，其中 X 只能是 Number, String, Boolean, Array, 扁平对象，即那些能够被 JSON 直接表示的数据结构。</p><h3 id="3-递归拷贝"><a href="#3-递归拷贝" class="headerlink" title="3.递归拷贝"></a>3.递归拷贝</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>initalObj<span class="token punctuation">,</span> finalObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> obj <span class="token operator">=</span> finalObj <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> initalObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> prop <span class="token operator">=</span> initalObj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token operator">===</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> prop <span class="token operator">===</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> prop<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      arguments<span class="token punctuation">.</span><span class="token function">callee</span><span class="token punctuation">(</span>prop<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> prop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">21</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="4-使用-Object-create-方法"><a href="#4-使用-Object-create-方法" class="headerlink" title="4.使用 Object.create()方法"></a>4.使用 Object.create()方法</h3><p>直接使用 var newObj = Object.create(oldObj)，可以达到深拷贝的效果。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>initalObj<span class="token punctuation">,</span> finalObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> obj <span class="token operator">=</span> finalObj <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> initalObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> prop <span class="token operator">=</span> initalObj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token operator">===</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> prop <span class="token operator">===</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> prop<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> prop<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="5-jquery"><a href="#5-jquery" class="headerlink" title="5.jquery"></a>5.jquery</h3><p>jquery 有提供一个$.extend 可以用来做 Deep Copy。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> $ <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"jquery"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  b<span class="token punctuation">:</span> <span class="token punctuation">{</span> f<span class="token punctuation">:</span> <span class="token punctuation">{</span> g<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  c<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>b<span class="token punctuation">.</span>f <span class="token operator">===</span> obj2<span class="token punctuation">.</span>b<span class="token punctuation">.</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span></code></pre><h3 id="6-第三方函数"><a href="#6-第三方函数" class="headerlink" title="6.第三方函数"></a>6.第三方函数</h3><p>还有一些其它的第三方函数库有深拷贝 function，如 lodash。</p><h2 id="文章引用："><a href="#文章引用：" class="headerlink" title="文章引用："></a>文章引用：</h2><p><a href="https://blog.csdn.net/ljw1412/article/details/79651725" target="_blank" rel="noopener">https://blog.csdn.net/ljw1412/article/details/79651725</a><br><a href="https://www.jianshu.com/p/52db1d0c1780" target="_blank" rel="noopener">https://www.jianshu.com/p/52db1d0c1780</a><br><a href="https://segmentfault.com/a/1190000016440069" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016440069</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深拷贝 </tag>
            
            <tag> 浅拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试（6）公众号，小程序</title>
      <link href="/leader755/46994.html"/>
      <url>/leader755/46994.html</url>
      
        <content type="html"><![CDATA[<p>大纲：<br>微信，小程序授权（ openId，unid，用户信息，手机号）<br>微信支付（H5，公众号，小程序，app）<br>微信上传图片（H5，公众号，小程序）<br>支付宝支付（H5，app）</p><h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><p>小程序中如何合并 seaData,减少 setData 次数：<br>**  合并<code>setdata</code>的请求，减少通讯的次数：**<br>避免过于频繁调用<code>setData</code>,应考虑将多次<code>setData</code>合并成一次<code>setData</code>调用</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 不要频繁调用setData</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 绝大多数时候可优化为</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>**<br><strong>5. 列表的局部更新</strong><br>在一个列表中，有<code>n</code>条数据，采用上拉加载更多的方式，假如这个时候想对其中某一个数据进行点赞操作，还能及时看到点赞的效果。</p><blockquote><ul><li>可以采用<code>setData</code>全局刷新，点赞完成之后，重新获取数据，再次进行全局重新渲染，这样做的有点是：方便，快捷！缺点是：用户体验极其不好，当用户刷量 100 多条数据后，重新渲染会出现空白期。</li><li>也可以采用局部刷新，将点赞的<code>id</code>传过去，知道点的是哪一条数据，重新获取数据，查找相对应<code>id</code>的那条数据的下标（<code>index</code>是不会改变的），用<code>setData</code>进行局部刷新，如此，便可以显著提升渲染速度。</li></ul></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    list<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">=</span>newList<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>微信登录几种方式：<br><strong>微信联合登录和微信授权登录</strong><br>微信联合登录；也就是我们常用的微信移动端/PC 端之间的扫码登录，PC 端用微信扫码登录，微信移动端确认授权登录后，应用可以从微信拿到用户的 open id 或 union id，将微信获取的用户信息与自己账户体系中的用户身份进行关联；</p><p>授权登录：需要用户确认登录，这样可以通过用户的个人确认，获取用户全面的信息，无论是否关注相关微信公众号等都可以获取。</p><p>静默授权不需要用户确认，只需要用户访问某个网页，属于嵌套在普通网页里的授权形式，但是只能获取到用户的唯一标示 openid 和 union id，无法拿到用户的微信头像、微信名称等个人信息，对于用户的简单认证还是很有用的。</p><p><strong>如何通过微信账户体系来做多应用、多平台之间的账户互通体系；如果某个服务同时分布在多个公众号中，账户体系如何建立；如何做到用户身份唯一识别；</strong><br>1）、同一用户不同公众号/应用下 open id 不同，同一用户不同公众号/应用下 unionid 相同；<br>2）、建立应用账户体系时，通过 union 来进行多应用/平台之间的用户账户体系识别与合并；<br>3）、多应用/平台建立账户体系时，需要做到唯一 user id 对应唯一 union id；<br><strong>某个服务，包括移动 app 端、PC 网页端、公众号端服务，那么用户使用微信授权登录的数据流转流程是怎么样的；</strong><br>1、用户通过微信授权移动 app 服务；该应用服务即可通过接口获取用户的 union id，这个时候，如果在数据库中没有查到该 id，则识别为新用户，直接创建一个 user id，该唯一 user id 与 union id 对应；<br>2、用户通过微信扫码 PC 端授权联合登陆获取 PC 端服务；该应用服务即可通过接口获取用户的 union id，这个时候，在数据库中查到有这个 id，就会把 pc 登录这个账户合并到之前创建的唯一 user id 账户下；<br>3、用户通过关注该服务公众号，用微信授权登录公众号服务；该应用服即可通过接口获取用户的 union id，这个时候，在数据库中查到有这个 id，就会把公众号中登录的这个账户合并到之前创建的唯一 user id 账户下；</p><p><strong>网页授权的两种 scope 的区别说明：</strong><br>1、授权登录以 snsapi_base 为 scope 发起的网页授权，是用来获取进入页面的用户的 openid 的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）特点：用户无感知；<br>2、静默授权以 snsapi_userinfo 为 scope 发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。<br><strong>特殊场景下静默授权：</strong><br>对于已关注公众号的用户，如果用户从公众号的会话或者自定义菜单进入本公众号的网页授权页，即使是 scope 为 snsapi_userinfo，也是静默授权，用户无感知。<br><strong>网页授权流程：</strong><br><strong>1、引导用户进入授权页面同意授权，获取 code **<br>确保微信公众账号拥有授权作用域（scope 参数）的权限的前提下引导用户去授权页面<br>参考链接：<br>scope 为 snsapi_base<br>注意：appid,redirect_uri,state 这些要和后台协商好<br><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=%22+wx_appid+%22&redirect_uri=%22+api.wx_reg+%22&response_type=code&scope=snsapi_login,snsapi_userinfo&state=1,0#wechat_redirect" target="_blank" rel="noopener">https://open.weixin.qq.com/connect/oauth2/authorize?appid=”+wx_appid+”&amp;redirect_uri=”+api.wx_reg+”&amp;response_type=code&amp;scope=snsapi_login,snsapi_userinfo&amp;state=1,0#wechat_redirect</a><br>scope 为 snsapi_userinfo<br><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=%22+wx_appid+%22&redirect_uri=%22+api.wx_reg+%22&response_type=code&scope=snsapi_base,snsapi_userinfo&state=1,0#wechat_redirect" target="_blank" rel="noopener">https://open.weixin.qq.com/connect/oauth2/authorize?appid=”+wx_appid+”&amp;redirect_uri=”+api.wx_reg+”&amp;response_type=code&amp;scope=snsapi_base,snsapi_userinfo&amp;state=1,0#wechat_redirect</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1598313614593-c3c04a5e-42a9-4586-ad55-fa1d21806255.png#align=left&display=inline&height=532&margin=%5Bobject%20Object%5D&originHeight=532&originWidth=639&size=0&status=done&style=none&width=639" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1598313614554-8e7593c1-952c-43b5-acaa-ea1014164056.png#align=left&display=inline&height=527&margin=%5Bobject%20Object%5D&originHeight=527&originWidth=312&size=0&status=done&style=none&width=312" alt=""><br>用户同意授权后<br>如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE。<br>**2、通过 code 换取网页授权 access_token（后台操作）（之前是 php 中间做了一步中转操作</strong>通过 code 换取网页授权 access_token 这步是后台操作<strong>）</strong><br>  页面跳回跳的 url 上 redirect_uri/?code=CODE&amp;state=STATE。code<br>通过 code 换取的是网页授权 access_token，如果网页授权的作用域为 snsapi_base，则本步骤中获取到网页授权 access_token 的同时，也获取到了 openid，snsapi_base 式的网页授权流程即到此为止。<br><strong>3：需要个人信息。后台通过 code 得到值之后返回给前端去操作</strong><br><strong>2、通过 code 换取网页授权 access_token（前端操作）</strong><br><strong>window.location.href=”<a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=&quot;+wx_appid+&quot;&amp;redirect_uri=&quot;+encodeURIComponent" target="_blank" rel="noopener">https://open.weixin.qq.com/connect/oauth2/authorize?appid=&quot;+wx_appid+&quot;&amp;redirect_uri=&quot;+encodeURIComponent</a>(“+中转页面的html比如 location.html+”)+”&amp;response_type=code&amp;scope=snsapi_base,snsapi_userinfo&amp;state=”+wx_rt_url_code（前端自己判断，存储，目的是确定授权页面来源。以方便授权后跳回的页面地址）+”,1(这值是和后台协商)#wechat_redirect”;</strong><br><strong>3:</strong>location.html 页面授权后会跳转到这个页面。同时在页面 url？后参数中拿到 code 和 state 的值 （state 就是上面传入的）*<strong>*<br>**</strong>就可以拿着这两个参数去进行登录操作。获取相应的 token ，wxUserToken 等需要的<strong>信息  <em><em>。根据 *</em>wx_rt_url_code 自己定义个规则回转到相应的页面。完成登录状态。进行下一步操作***\</em></strong><br><strong>**</strong>为了确保参数的正确传入，state 可以进行 decodeURIComponent 下。（之前调接口的时候程序报错，发现 pc 端授权登录的时候微信解析是有逗号，手机端 state 是没逗号，确保程序的正常运行可以进行解码下）<strong>**</strong><br>网站的微信授权登录是以二维码的形式 api 网址 api <a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419316505&token=&lang=zh_CN" target="_blank" rel="noopener">https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN</a><br>手机端微信授权登录 api 网址  <a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419317851&token=&lang=zh_CN" target="_blank" rel="noopener">https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419317851&amp;token=&amp;lang=zh_CN</a></p><p>微信支付：</p><p>H5 支付（即在网页端（非微信浏览器）页面调用支付）</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">onBridgeReady</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  WeixinJSBridge<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>    <span class="token string">"getBrandWCPayRequest"</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      appId<span class="token punctuation">:</span> <span class="token string">"wx2421b1c4370ec43b"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//公众号名称，由商户传入</span>      timeStamp<span class="token punctuation">:</span> <span class="token string">"1395712654"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//时间戳，自1970年以来的秒数</span>      nonceStr<span class="token punctuation">:</span> <span class="token string">"e61463f8efa94090b1f366cccfbbb444"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//随机串</span>      <span class="token keyword">package</span><span class="token punctuation">:</span> <span class="token string">"prepay_id=u802345jgfjsdfgsdg888"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//统一下单接口返回的prepay_id,提交格式如：prepay_id=***</span>      signType<span class="token punctuation">:</span> <span class="token string">"MD5"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//签名类型，默认为MD5，支持HMAC-SHA256和MD5 注意此处需与统一下单的签名类型一致</span>      paySign<span class="token punctuation">:</span> <span class="token string">"70EA570631E4BB79628FBCA90534C63FF7FADD89"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//微信签名 (算法生成)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token keyword">function</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>err_msg <span class="token operator">==</span> <span class="token string">"get_brand_wcpay_request:ok"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用以上方式判断前端返回,微信团队郑重提示：</span>        <span class="token comment" spellcheck="true">//res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠。</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> WeixinJSBridge <span class="token operator">==</span> <span class="token string">"undefined"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>addEventListener<span class="token punctuation">)</span> <span class="token punctuation">{</span>    document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"WeixinJSBridgeReady"</span><span class="token punctuation">,</span> onBridgeReady<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>attachEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    document<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">"WeixinJSBridgeReady"</span><span class="token punctuation">,</span> onBridgeReady<span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">"onWeixinJSBridgeReady"</span><span class="token punctuation">,</span> onBridgeReady<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token function">onBridgeReady</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>开微信开发者工具，打 log，最后发现在这一步时候 if (typeof WeixinJSBridge == “undefined”)<br>1.ios 能够调起微信浏览器的 js-sdk 2.安卓大部分都走到 undefined 里面去了<br>这里其实我也不太清楚原因。个人感觉是微信安卓的内置浏览器版本和这个 WeixinJSBridge 方法的问题。（希望有大神能够解答一下）</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token function">getConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            wx<span class="token punctuation">.</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                debug<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wx_config<span class="token punctuation">.</span>debug<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span>                appId<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wx_config<span class="token punctuation">.</span>appId<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 必填，公众号的唯一标识</span>                timestamp<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wx_config<span class="token punctuation">.</span>timestamp<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 必填，生成签名的时间戳</span>                nonceStr<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wx_config<span class="token punctuation">.</span>nonceStr<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 必填，生成签名的随机串</span>                signature<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>wx_config<span class="token punctuation">.</span>signature<span class="token punctuation">,</span><span class="token comment" spellcheck="true">// 必填，签名</span>                jsApiList<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wx_config<span class="token punctuation">.</span>jsApiList <span class="token comment" spellcheck="true">// 必填，需要使用的JS接口列表</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//微信支付</span>            wx<span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">// config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。</span>                <span class="token comment" spellcheck="true">// console.log(this.jsApiCall());</span>                wx<span class="token punctuation">.</span><span class="token function">chooseWXPay</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                    timestamp<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wechat_code<span class="token punctuation">.</span>timestamp<span class="token punctuation">,</span>                    nonceStr<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>wechat_code<span class="token punctuation">.</span>nonceStr<span class="token punctuation">,</span>                    <span class="token keyword">package</span><span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wechat_code<span class="token punctuation">.</span><span class="token keyword">package</span><span class="token punctuation">,</span>                    signType<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wechat_code<span class="token punctuation">.</span>signType<span class="token punctuation">,</span>                    paySign<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wechat_code<span class="token punctuation">.</span>paySign<span class="token punctuation">,</span>                    success<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 支付成功后的回调函数</span>                        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"支付成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">"/hd/becomevip"</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                    cancel<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"支付失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p><strong>分析和总结</strong><br>** <em>*<br>扫码支付、公众号支付、H5 支付、小程序支付都有一个同步回调地址跟异步通知地址，只是设置方式有所区别 ：<br><strong>1. 扫码支付</strong><br>同步回调地址在微信商户平台中设置，异步通知地址在统一下单接口的请求参数中设置；<br><strong>2. 公众号支付</strong><br>同步回调地址在 JSAPI 发起支付的回到函数中进行回到，异步通知地址在统一下单接口的请求参数中设置；<br><strong>3. H5 支付</strong><br>同步回调地址：在统一下单接口的返回参数中有一个参数 mweb_url，在 mweb_url 中以 get 传参形式新增一个参数 redirect_url，redirect_url 即是同步回调函数；<br>异步通知地址：统一下单接口的请求参数中设置；<br>*<em>4. 小程序支付\</em>\</em><br>同步回调地址：在小程序获得支付参数，并通过 js 调起微信支付以后，js 中会有一个回调函数，同步回调地址在该回调函数中添加；<br>异步通知地址：统一下单接口的请求参数中设置。</p><p>其中扫码支付主要用于电脑端；公众号支付跟 H5 支付主要用于移动端，因此商户在移动端使用微信支付的时候需要判断当前打开的浏览器是否是微信浏览器，并根据结果决定选择公众号支付或 H5 支付；小程序支付的话主要用于小程序内部，因此比如获取 openid，调用统一下单接口等操作均在给小程序提供数据接口服务的接口后台实现。</p><p>同步回调地址是作为微信后台跟商户进行页面跳转的渠道，因此同步回调地址是至关重要的，如果不填写，则可能导致支付完成后无法做页面跳转。<br>异步通知地址是微信后台对商户后台在完成微信支付后进行通知的重要通道，商户后台的异步通知地址必须是可访问的，在接收到微信的通知后，要做相关业务处理，并最终返回 SUCCESS 或 FAIL 的标识给微信，以告知微信不要在发送通知。</p><p>结尾<br>这里只是针对微信扫码支付、公众号支付、H5 支付、小程序支付等微信的四中支付方式做了一个大概的分析和总结，具体的每一个支付方式的接入方法还请以微信支付开发文档为重要参考；因篇幅有限，代码量大，这里就不贴具体的实现代码了。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
            <tag> 公众号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试（5）http，https</title>
      <link href="/leader755/5102.html"/>
      <url>/leader755/5102.html</url>
      
        <content type="html"><![CDATA[<h2 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h2><p>http 状态码是表示服务器对请求的响应状态，主要分为以下几个部分<br>1<strong>：这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。<br>2</strong>：表示请求成功，<br>3<strong>：表示重定向<br>4</strong>：表示客户端错误<br>5**：表示服务器端错误<br>100（continue），客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收<br>200（OK），表示请求成功，请求所希望的响应头或数据体将随此响应返回。<br>202（Accepted），服务器已接受请求，但尚未处理。<br>204（No-Content），服务器成功处理了请求，但不需要返回任何实体内容<br>205（Reset-Content），服务器成功处理了请求，且没有返回任何内容。但是与 204 响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。<br>206（Partial-Content），服务器已经成功处理了部分 GET 请求。<br>301（Moved-Permanently），永久性重定向<br>302（Moved-Temporarily），暂时性重定向<br>304（Not-Modified），浏览器端缓存的资源依然有效<br>400（Bad-Reques），请求有误，当前请求无法被服务器理解。<br>401（Unauthorized），当前请求需要用户验证。<br>403（Forbidden），服务器已经理解请求，但是拒绝执行它。<br>404（Not-Found），请求的资源没有被找到<br>500（Interval Server Error），服务器内部错误<br>502（Bad GateWay），网关出错<br>503（Service Unavailable），由于临时的服务器维护或者过载，服务器当前无法处理请求。<br>504（Gateway Timeout），作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。</p><h1 id="HTTP-之状态码"><a href="#HTTP-之状态码" class="headerlink" title="HTTP 之状态码"></a>HTTP 之状态码</h1><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><h6 id="1xx：指示信息–表示请求已接收，继续处理"><a href="#1xx：指示信息–表示请求已接收，继续处理" class="headerlink" title="1xx：指示信息–表示请求已接收，继续处理"></a>1xx：指示信息–表示请求已接收，继续处理</h6><h6 id="2xx：成功–表示请求已被成功接收、理解、接受"><a href="#2xx：成功–表示请求已被成功接收、理解、接受" class="headerlink" title="2xx：成功–表示请求已被成功接收、理解、接受"></a>2xx：成功–表示请求已被成功接收、理解、接受</h6><h6 id="3xx：重定向–要完成请求必须进行更进一步的操作"><a href="#3xx：重定向–要完成请求必须进行更进一步的操作" class="headerlink" title="3xx：重定向–要完成请求必须进行更进一步的操作"></a>3xx：重定向–要完成请求必须进行更进一步的操作</h6><h6 id="4xx：客户端错误–请求有语法错误或请求无法实现"><a href="#4xx：客户端错误–请求有语法错误或请求无法实现" class="headerlink" title="4xx：客户端错误–请求有语法错误或请求无法实现"></a>4xx：客户端错误–请求有语法错误或请求无法实现</h6><h6 id="5xx：服务器端错误–服务器未能实现合法的请求"><a href="#5xx：服务器端错误–服务器未能实现合法的请求" class="headerlink" title="5xx：服务器端错误–服务器未能实现合法的请求"></a>5xx：服务器端错误–服务器未能实现合法的请求</h6><p>常见状态码：</p><pre><code>200 OK                        //客户端请求成功400 Bad Request               //客户端请求有语法错误，不能被服务器所理解401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden                 //服务器收到请求，但是拒绝提供服务404 Not Found                 //请求资源不存在，eg：输入了错误的URL500 Internal Server Error     //服务器发生不可预期的错误503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</code></pre><p>更多状态码<a href="https://link.jianshu.com?t=http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">http://www.runoob.com/http/http-status-codes.html</a></p><h1 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h1><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。<br>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。<br>HTTP1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p><pre><code>GET  请求指定的页面信息，并返回实体主体。HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。PUT  从客户端向服务器传送的数据取代指定的文档的内容。DELETE   请求服务器删除指定的页面。CONNECT  HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。OPTIONS  允许客户端查看服务器的性能。TRACE    回显服务器收到的请求，主要用于测试或诊断。</code></pre><p>作者：RaphetS<br>链接：<a href="https://www.jianshu.com/p/80e25cb1d81a" target="_blank" rel="noopener">https://www.jianshu.com/p/80e25cb1d81a</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>##</p><h2 id="https-和-http"><a href="#https-和-http" class="headerlink" title="https 和 http"></a>https 和 http</h2><p>说一下 http 和 https<br>https 的 SSL 加密是在传输层实现的。 (1)http 和 https 的基本概念<br>http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br>https: 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。<br>https 协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。<br>(2)http 和 https 的区别？<br>http 传输的数据都是未加密的，也就是明文的，网景公司设置了 SSL 协议来对 http 协议传输的数据进行加密处理，简单来说 https 协议是由 http 和 ssl 协议构建的可进行加密传输和身份认证的网络协议，比 http 协议的安全性更高。 主要的区别如下：<br>Https 协议需要 ca 证书，费用较高。<br>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。<br>使用不同的链接方式，端口也不同，一般而言，http 协议的端口为 80，https 的端口为 443<br>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。<br>(3)https 协议的工作原理<br>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。<br>客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。<br>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。<br>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。<br>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。<br>web 服务器通过自己的私钥解密出会话密钥。<br>web 服务器通过会话密钥加密与客户端之间的通信。<br>(4)https 协议的优点<br>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；<br>HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。<br>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。<br>谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 HTTP 网站，采用 HTTPS 加密的网站在搜索结果中的排名将会更高”。<br>(5)https 协议的缺点<br>https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。<br>https 缓存不如 http 高效，会增加数据开销。<br>SSL 证书也需要钱，功能越强大的证书费用越高。<br>SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</p><h2 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP/IP 协议"></a>TCP/IP 协议</h2><p>在讲解 HTTP 与 HTTPS 之前,有个知识点必须提前讲解下,那就是 TCP/IP 协议.<br>从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 <strong>TCP/IP 为网际协议群。</strong><br>互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，<strong>互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</strong><br>更详细全面的可以查看 <a href="https://juejin.im/post/6844903510509633550" target="_blank" rel="noopener">一篇文章带你熟悉 TCP/IP 协议（网络协议篇二）</a></p><h3 id="TCP-协议（传输控制协议）-应用程序之间的通信"><a href="#TCP-协议（传输控制协议）-应用程序之间的通信" class="headerlink" title="TCP 协议（传输控制协议）:应用程序之间的通信"></a>TCP 协议（传输控制协议）:应用程序之间的通信</h3><p><strong>TCP 确保数据包以正确的次序到达，并且尝试确认数据包的内容没有改变。</strong> TCP 在 IP 地址之上引端口（port），它允许计算机通过网络提供各种服务。一些端口号为不同的服务保留，而且这些端口号是众所周知。<br>服务或者守护进程：在提供服务的机器上，有程序监听特定端口上的通信流。例如大多数电子邮件通信流出现在端口 25 上，用于 wwww 的 HTTP 通信流出现在 80 端口上。<br>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信，占用两个计算机之间整个的通信线路。TCP 用于从应用程序到网络的数据传输控制。TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。<br><strong>TCP/IP 就是 TCP 和 IP 两个协议在一起协同工作，有上下层次的关系。</strong><br>TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。IP 负责计算机之间的通信。<strong>TCP 负责将数据分割并装入 IP 包，IP 负责将包发送至接受者</strong>，传输过程要经 IP 路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址，然后在它们到达的时候重新组合它们。</p><h3 id="IP-协议（网际协议）-计算机之间的通信"><a href="#IP-协议（网际协议）-计算机之间的通信" class="headerlink" title="IP 协议（网际协议）:计算机之间的通信"></a>IP 协议（网际协议）:计算机之间的通信</h3><p>IP 协议是计算机用来相互识别的通信的一种机制，每台计算机都有一个 IP.用来在 internet 上标识这台计算机。 <strong>IP 负责在因特网上发送和接收数据包。</strong> 通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。<strong>IP 负责将每个包路由至它的目的地。</strong><br><strong>IP 协议仅仅是允许计算机相互发消息，但它并不检查消息是否以发送的次序到达而且没有损坏（只检查关键的头数据）。为了提供消息检验功能，直接在 IP 协议上设计了传输控制协议 TCP。</strong></p><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>HTTP 协议（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW 服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。<br><strong>HTTP 是客户端浏览器或其他程序与 Web 服务器之间的应用层通信协议。</strong> 在 Internet 上的 Web 服务器上存放的都是超文本信息，客户机需要通过 HTTP 协议传输所要访问的超文本信息。HTTP 包含命令和传输信息，不仅可用于 Web 访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。<br>我们在浏览器的地址栏里输入的网站地址叫做 URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个 Internet 地址。当你在浏览器的地址框中输入一个 URL 或是单击一个超级链接时，URL 就确定了要浏览的地址。<strong>浏览器通过超文本传输协议(HTTP)，将 Web 服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</strong></p><h3 id="HTTP-协议基础"><a href="#HTTP-协议基础" class="headerlink" title="HTTP 协议基础"></a>HTTP 协议基础</h3><ul><li><p><strong>永远都是客户端发起请求，服务器回送响应</strong>应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色。仅从一条通信线路来说，服务器端和客服端的角色是确定的。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。<strong>换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</strong></p></li><li><p><strong>无状态的协议 HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。</strong> 也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p></li><li><p><strong>Cookie 管理状态</strong>Cookie 技术通过<strong>在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</strong> Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p></li><li><p><strong>URI 定位资源</strong>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</p></li><li><p><strong>持久连接</strong>HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。 为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，<strong>只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。</strong></p></li><li><p><strong>管线化</strong>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能<strong>做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</strong>比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。</p></li></ul><h3 id="HTTP-工作过程"><a href="#HTTP-工作过程" class="headerlink" title="HTTP 工作过程"></a>HTTP 工作过程</h3><ul><li>1,地址解析</li></ul><p>如用客户端浏览器请求这个页面：<code>localhost.com:8080/index.htm</code>从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：</p><pre><code>协议名：http主机名：localhost.com端口：8080对象路径：/index.htm复制代码复制代码</code></pre><p>在这一步，需要域名系统 DNS 解析域名,得主机的 IP 地址。</p><ul><li>2,封装 HTTP 请求数据包</li></ul><p>把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包</p><ul><li>3,封装成 TCP 包，建立 TCP 连接（TCP 的三次握手）</li></ul><p>在 HTTP 工作开始之前，客户机（Web 浏览器）首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是 80。这里是 8080 端口。</p><ul><li>4,客户端向服务器发送请求命令</li></ul><p>建立 TCP 连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。</p><ul><li>5,服务器响应</li></ul><p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。<br>实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 应答头信息所描述的格式发送用户所请求的实际数据.</p><ul><li>6,服务器关闭 TCP 连接</li></ul><p>一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><h3 id="HTTP-协议报文结构与头部"><a href="#HTTP-协议报文结构与头部" class="headerlink" title="HTTP 协议报文结构与头部"></a>HTTP 协议报文结构与头部</h3><p>这部分涉及到的知识特别繁琐,受限于篇幅,这里就不赘述了.可以参考<a href="https://www.jianshu.com/p/6e9e4156ece3" target="_blank" rel="noopener">这篇文章的四,五,六章作了超详尽的说明.</a></p><h3 id="HTTP-的请求方法"><a href="#HTTP-的请求方法" class="headerlink" title="HTTP 的请求方法"></a>HTTP 的请求方法</h3><pre><code>GET: 获取URL指定的资源；POST：传输实体信息PUT：上传文件DELETE：删除文件HEAD：获取报文首部，与GET相比，不返回报文主体部分OPTIONS：询问支持的方法TRACE：追踪请求的路径；CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信。主要使用SSL和TLS将数据加密后通过网络隧道进行传输。复制代码</code></pre><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p><a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">菜鸟教程里有完整的说明.</a></p><h3 id="HTTP-缺点"><a href="#HTTP-缺点" class="headerlink" title="HTTP 缺点"></a>HTTP 缺点</h3><ul><li>通信使用明文，容易被窃听</li><li>不验证通信方的身份，可能遭遇伪装</li><li>无法证明报文的完整性，有可能遭遇篡改</li></ul><h2 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为 HTTP over TLS，HTTP over SSL 或 HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。<br>HTTPS 经由 HTTP 进行通信，但<strong>利用 SSL/TLS 来加密数据包。</strong><br>HTTPS 开发的主要目的，是提供<strong>对网站服务器的身份认证，保护交换数据的隐私与完整性。</strong><br><strong>简而言之:</strong> HTTPS 是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597799218782-b68ff5d2-772e-46e2-a7b3-65277257e435.webp#align=left&display=inline&height=302&margin=%5Bobject%20Object%5D&originHeight=302&originWidth=534&size=0&status=done&style=none&width=534" alt=""><br><strong>HTTPS 比 HTTP 多了一层 TLS/SSL 协议</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597799218723-4c0e7d6b-f3dc-4a40-9bdd-d3af8a2af1b9.webp#align=left&display=inline&height=212&margin=%5Bobject%20Object%5D&originHeight=212&originWidth=412&size=0&status=done&style=none&width=412" alt=""><br>TLS/SSL 全称安全传输层协议 Transport Layer Security, 是介于 TCP 和 HTTP 之间的一层安全协议，不影响原有的 TCP 协议和 HTTP 协议，所以使用 HTTPS 基本上不需要对 HTTP 页面进行太多的改造。</p><h3 id="HTTPS-原理"><a href="#HTTPS-原理" class="headerlink" title="HTTPS 原理"></a>HTTPS 原理</h3><p>这部分细说起来,真的很多.这里我归纳简单说一下:</p><ul><li>客户端向服务器端索要并验证公钥。这一阶段使用的是<strong>非对称加密传输</strong>(RSA),服务端将数字证书发给客户端.其中数字证书包括:公钥和数字签名.客户端在拿到后对两者进行校验.</li><li>在非对称加密传输中,两端协商生成”对话密钥”。</li><li>双方采用”对话密钥”进行对称加密通信。</li></ul><p>受限于篇幅,我就不展开了.要不然就太多太多了.这里我推荐几篇文章大家全面理解:</p><ul><li>以通俗易懂的方式理解 https 原理: <a href="https://juejin.im/post/6844903504046211079" target="_blank" rel="noopener">文章</a></li><li>关于 SSL/TLS 原理的详细说明:<a href="https://segmentfault.com/a/1190000002554673" target="_blank" rel="noopener">文章</a></li><li>关于 PKI 体系与证书的说明:<a href="https://www.jianshu.com/p/ffe8c203a471" target="_blank" rel="noopener">文章</a></li></ul><h3 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h3><ul><li>HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密</li><li>HTTP 的端口号是 80，HTTPS 是 443</li><li>HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费</li><li>HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ul><h3 id="HTTPS-主要作用是："><a href="#HTTPS-主要作用是：" class="headerlink" title="HTTPS 主要作用是："></a>HTTPS 主要作用是：</h3><ul><li>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全</li><li>对网站服务器进行真实身份认证</li></ul><h3 id="HTTPS-缺点"><a href="#HTTPS-缺点" class="headerlink" title="HTTPS 缺点"></a>HTTPS 缺点</h3><ul><li>HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10%到 20%的耗电；</li><li>https 连接缓存不如 http 高效，如果是大流量网站,则会造成流量成本太高。</li><li>https 连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用 https，基于大部分计算资源闲置的假设的 VPS 的平均成本会上去。</li><li>SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</li><li>SSL 证书通常需要绑定 IP，不能再同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗(SSL 有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP 就不支持这个扩展，考虑到 XP 的装机量，这个特性几乎没用)。</li></ul><h3 id="HTTPS-接入优化"><a href="#HTTPS-接入优化" class="headerlink" title="HTTPS 接入优化"></a>HTTPS 接入优化</h3><p><strong>CDN 接入</strong><br>HTTPS 增加的延时主要是传输延时 RTT，RTT 的特点是节点越近延时越小，CDN 天然离用户最近，因此选择使用 CDN 作为 HTTPS 接入的入口，将能够极大减少接入延时。CDN 节点通过和业务服务器维持长连接、会话复用和链路质量优化等可控方法，极大减少 HTTPS 带来的延时。<br><strong>会话缓存</strong><br>虽然前文提到 HTTPS 即使采用会话缓存也要至少 1*RTT 的延时，但是至少延时已经减少为原来的一半，明显的延时优化;同时，基于会话缓存建立的 HTTPS 连接不需要服务器使用 RSA 私钥解密获取 Pre-master 信息，可以省去 CPU 的消耗。如果业务访问连接集中，缓存命中率高，则 HTTPS 的接入能力讲明显提升。当前 TRP 平台的缓存命中率高峰时期大于 30%，10k/s 的接入资源实际可以承载 13k/的接入，收效非常可观。<br><strong>硬件加速</strong><br>为接入服务器安装专用的 SSL 硬件加速卡，作用类似 GPU，释放 CPU，能够具有更高的 HTTPS 接入能力且不影响业务程序的。测试某硬件加速卡单卡可以提供 35k 的解密能力，相当于 175 核 CPU，至少相当于 7 台 24 核的服务器，考虑到接入服务器其它程序的开销，一张硬件卡可以实现接近 10 台服务器的接入能力。<br><strong>远程解密</strong><br>本地接入消耗过多的 CPU 资源，浪费了网卡和硬盘等资源，考虑将最消耗 CPU 资源的 RSA 解密计算任务转移到其它服务器，如此则可以充分发挥服务器的接入能力，充分利用带宽与网卡资源。远程解密服务器可以选择 CPU 负载较低的机器充当，实现机器资源复用，也可以是专门优化的高计算性能的服务器。当前也是 CDN 用于大规模 HTTPS 接入的解决方案之一。<br><strong>SPDY/HTTP2</strong><br>前面的方法分别从减少传输延时和单机负载的方法提高 HTTPS 接入性能，但是方法都基于不改变 HTTP 协议的基础上提出的优化方法，SPDY/HTTP2 利用 TLS/SSL 带来的优势，通过修改协议的方法来提升 HTTPS 的性能，提高下载速度等。</p><p>作者：shotCat<br>链接：<a href="https://juejin.im/post/6844903781704925198" target="_blank" rel="noopener">https://juejin.im/post/6844903781704925198</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="从输入-URL-到看到页面发生的全过程-含三握手-四挥手详解"><a href="#从输入-URL-到看到页面发生的全过程-含三握手-四挥手详解" class="headerlink" title="从输入 URL 到看到页面发生的全过程(含三握手,四挥手详解)"></a>从输入 URL 到看到页面发生的全过程(含三握手,四挥手详解)</h2><p>总体来说分为以下几个过程:<br><strong>1.浏览器的地址栏输入 URL 并按下回车。</strong><br><strong>2.浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期。</strong><br><strong>3.DNS 解析 URL 对应的 IP。</strong><br><strong>4.根据 IP 建立 TCP 连接（三次握手）。</strong><br><strong>5.HTTP 发起请求。</strong><br><strong>6.服务器处理请求，浏览器接收 HTTP 响应。</strong><br><strong>7.浏览器解析渲染页面。</strong><br><strong>8.关闭 TCP 连接（四次挥手）。</strong></p><h3 id="1-输入-URL-并按下回车。"><a href="#1-输入-URL-并按下回车。" class="headerlink" title="1, 输入 URL 并按下回车。"></a>1, 输入 URL 并按下回车。</h3><p>url 一般包含这几个部分.可以顺带提以下知识点<br><strong>知识点:</strong></p><ul><li>协议：主要是 HTTP 协议，HTTPS 协议，FTP 协议，FILe 协议</li><li>域名： 定义因特网<strong>域名</strong>，比如 <a href="http://google.com" target="_blank" rel="noopener">google.com</a></li><li>端口号：通常默认都是隐藏的 <strong>http 默认端口号为 80 https 默认端口号为 443</strong></li><li>补充: 同源策略 - 在前端进行数据请求时，由于浏览器的同源策略，协议，域名，端口号有一个不同会存在跨域请求，需要进行跨域处理</li></ul><h3 id="2-浏览器查找当前-URL-是否存在缓存，并比较缓存是否过期。"><a href="#2-浏览器查找当前-URL-是否存在缓存，并比较缓存是否过期。" class="headerlink" title="2.浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期。"></a>2.浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期。</h3><p>浏览器首先查询当前 URL 是否有缓存,有的话,再查询是否过期,没过期则读缓存.过期了则访问 web 服务器.<br><strong>知识点:</strong> 详细解释可以看本系列的”浏览器缓存”这节.</p><h3 id="3-DNS-解析-URL-对应的-IP。"><a href="#3-DNS-解析-URL-对应的-IP。" class="headerlink" title="3.DNS 解析 URL 对应的 IP。"></a>3.DNS 解析 URL 对应的 IP。</h3><h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程:"></a><strong>解析过程:</strong></h4><p>1.首先浏览器会查看自己的 DNS 缓存是否存在. 2.如果没有找到,浏览器会<strong>先查找本地 hosts 文件是否有这个网址映射关系</strong>，如果有就调用这个 IP 地址映射，完成域名解析。 3.如果没有找到,则会在操作系统缓存中查找本地的 DNS 解析器缓存，如果找到则返回。 4.如果没有找到,则会在路由器缓存中进行查找,如果找到则返回。 5.如果还是没有找到,则会按 ISP(运营商)DNS 缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到 IP 地址.</p><h4 id="为什么要-DNS-解析"><a href="#为什么要-DNS-解析" class="headerlink" title="为什么要 DNS 解析"></a>为什么要 DNS 解析</h4><p>互联网上每一台计算机的唯一标识是它的 IP 地址，但是 IP 地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到 IP 地址的转换，这个过程就是 DNS 解析，即实现了网址到 IP 地址的转换</p><h4 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h4><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。<br><strong>域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址</strong>。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。<strong>因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。</strong></p><h4 id="什么是域名解析"><a href="#什么是域名解析" class="headerlink" title="什么是域名解析"></a>什么是域名解析</h4><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。<strong>DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录</strong>。</p><pre class=" language-javascript"><code class="language-javascript">例如 baidu<span class="token punctuation">.</span>com  <span class="token number">220.114</span><span class="token punctuation">.</span><span class="token number">23.56</span>（服务器外网IP地址）<span class="token number">80</span>（服务器端口号）复制代码</code></pre><h4 id="相关名词解释"><a href="#相关名词解释" class="headerlink" title="相关名词解释:"></a><strong>相关名词解释:</strong></h4><ul><li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li><li>hosts 文件: Hosts 是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的 IP 地址建立一个关联“数据库”.一般位于系统盘 C:\Windows\System32\drivers\etc 中，如果进去没有看到 Hos 文件，是因为某些系统将 Host 文件隐藏了。</li><li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统的 DNS 缓存中读取该域名所对应的 IP 地址。</li><li>路由缓存：路由器也有 DNS 缓存。</li><li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li><li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器<code>.com</code> 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li></ul><h3 id="4-根据-IP-建立-TCP-连接（三次握手）"><a href="#4-根据-IP-建立-TCP-连接（三次握手）" class="headerlink" title="4.根据 IP 建立 TCP 连接（三次握手）"></a>4.根据 IP 建立 TCP 连接（三次握手）</h3><h4 id="三次握手的过程"><a href="#三次握手的过程" class="headerlink" title="三次握手的过程:"></a><strong>三次握手的过程:</strong></h4><ul><li><strong>客户端发送一个 syn 包:即带有 SYN=1，Seq=x 的数据包到服务器端口，并进入 SYN_SENT 状态，等待服务器确认；</strong>（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</li><li><strong>服务器收到 syn 包，必须确认客户的 SYN，同时发回一个带 SYN=1， ACK=x+1， Seq=y 的响应包以示传达确认信息,即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；</strong>（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</li><li><strong>客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK,即回传一个带 ACK=y+1， Seq=Z 的数据包，代表“握手结束”</strong>（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597798820623-044e3740-a989-4d23-810c-0a36c097ffc7.webp#align=left&display=inline&height=274&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=550&size=0&status=done&style=none&width=550" alt=""><br>完成 TCP 连接后开使向服务器进行请求</p><h4 id="为啥需要三次握手"><a href="#为啥需要三次握手" class="headerlink" title="为啥需要三次握手"></a><strong>为啥需要三次握手</strong></h4><p>谢希仁著《计算机网络》中讲“三次握手”的目的是“<strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</strong>”。</p><h3 id="5-HTTP-发起请求-amp-amp-6-服务器处理请求，浏览器接收-HTTP-响应。"><a href="#5-HTTP-发起请求-amp-amp-6-服务器处理请求，浏览器接收-HTTP-响应。" class="headerlink" title="5.HTTP 发起请求 &amp;&amp; 6.服务器处理请求，浏览器接收 HTTP 响应。"></a>5.HTTP 发起请求 &amp;&amp; 6.服务器处理请求，浏览器接收 HTTP 响应。</h3><ul><li>完整的 HTTP 请求包含请求起始行、请求头部、请求主体三部分。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597798820619-3c03de5d-dfd6-43ed-bb02-162eafd0dfa4.webp#align=left&display=inline&height=243&margin=%5Bobject%20Object%5D&originHeight=243&originWidth=616&size=0&status=done&style=none&width=616" alt=""></p><ul><li>服务器在收到浏览器发送的 HTTP 请求之后，会将收到的 HTTP 报文封装成 HTTP 的 Request 对象，并通过不同的 Web 服务器进行处理，处理完的结果以 HTTP 的 Response 对象返回，主要包括状态码，响应头，响应报文三个部分。</li><li>综合起来,完整的 HTTP 请报文一般包括了：<strong>通用头部</strong>，<strong>请求/响应头部</strong>，<strong>请求/响应体</strong></li></ul><h4 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a><strong>通用头部</strong></h4><p>包括如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//General</span>Request Url<span class="token punctuation">:</span> 请求的web服务器地址Request Method<span class="token punctuation">:</span> 请求方式（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）Status Code<span class="token punctuation">:</span> 请求的返回状态码，如<span class="token number">200</span>代表成功Remote Address<span class="token punctuation">:</span> 请求的远程服务器地址（会转为IP）Referrer Policy<span class="token punctuation">:</span> <span class="token punctuation">(</span>引用策略<span class="token punctuation">)</span>用来监管哪些访问来源信息 <span class="token punctuation">(</span>IE暂不支持<span class="token punctuation">)</span>复制代码</code></pre><h4 id="请求-响应头部"><a href="#请求-响应头部" class="headerlink" title="请求/响应头部:"></a><strong>请求/响应头部:</strong></h4><p>常用的请求头部（部分）：</p><pre><code>Accept: 接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收Content-Type：客户端发送出去实体内容的类型Cache-Control: 指定请求和响应遵循的缓存机制，如no-cacheIf-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中Cookie: 有cookie并且同域访问时会自动带上Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-aliveHost：请求的服务器URLOrigin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)User-Agent：用户客户端的一些必要信息，如UA头部等复制代码</code></pre><p>常用的响应头部（部分）：</p><pre><code>Access-Control-Allow-Headers: 服务器端允许的请求HeadersAccess-Control-Allow-Methods: 服务器端允许的请求方法Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）Content-Type：服务端返回的实体内容的类型Date：数据从服务器发送的时间Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档Last-Modified：请求资源的最后修改时间Expires：应该在什么时候认为文档已经过期,从而不再缓存它Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效ETag：请求变量的实体标签的当前值Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）Server：服务器的一些相关信息复制代码</code></pre><p>一般来说，请求头部和响应头部是匹配分析的。<br>譬如，请求头部的 Accept 要和响应头部的 Content-Type 匹配，否则会报错<br>譬如，跨域请求时，请求头部的 Origin 要匹配响应头部的 Access-Control-Allow-Origin，否则会报跨域错误<br>譬如，在使用缓存时，请求头部的 If-Modified-Since、If-None-Match 分别和响应头部的 Last-Modified、ETag 对应</p><h4 id="请求-响应实体"><a href="#请求-响应实体" class="headerlink" title="请求/响应实体:"></a><strong>请求/响应实体:</strong></h4><p>http 请求时，除了头部，还有消息实体，一般来说<br>请求实体中会将一些需要的参数都放入进入（用于 post 请求）。<br>譬如实体中可以放参数的序列化形式（<code>a=1&amp;b=2</code>这种），或者直接放表单对象（<code>Form Data</code>对象，上传时可以夹杂参数以及文件），等等<br>而一般响应实体中，就是放服务端需要传给客户端的内容<br>一般现在的接口请求时，实体中就是对于的信息的 json 格式，而像页面请求这种，里面就是直接放了一个 html 字符串，然后浏览器自己解析并渲染。<br><img src="https://cdn.nlark.com/yuque/0/2020/svg/241787/1597798820575-0d549cf1-b07e-401a-a079-e250b77ba498.svg#align=left&display=inline&height=800&margin=%5Bobject%20Object%5D&name=image.svg&originHeight=800&originWidth=596&size=106&status=done&style=none&width=596" alt="image.svg"></p><h3 id="7-浏览器解析渲染页面"><a href="#7-浏览器解析渲染页面" class="headerlink" title="7.浏览器解析渲染页面"></a>7.浏览器解析渲染页面</h3><h4 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a><strong>流程简述</strong></h4><p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">1</span><span class="token punctuation">.</span> 解析HTML，构建DOM树<span class="token number">2</span><span class="token punctuation">.</span> 解析CSS，生成CSS规则树<span class="token number">3</span><span class="token punctuation">.</span> 合并DOM树和CSS规则，生成render树<span class="token number">4</span><span class="token punctuation">.</span> 布局render树（Layout<span class="token operator">/</span>reflow），负责各元素尺寸、位置的计算<span class="token number">5</span><span class="token punctuation">.</span> 绘制render树（paint），绘制页面像素信息<span class="token number">6</span><span class="token punctuation">.</span> 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上PS<span class="token punctuation">:</span>reflow：也称作layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为reflow。<span class="token function">repaint：中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候</span><span class="token punctuation">(</span>例如：背景色，边框颜色，文字颜色等<span class="token punctuation">)</span>，此时只需要应用新样式绘制这个元素就可以了。</code></pre><h4 id="1-根据-HTML-解析-DOM-树"><a href="#1-根据-HTML-解析-DOM-树" class="headerlink" title="1.根据 HTML 解析 DOM 树"></a>1.根据 HTML 解析 DOM 树</h4><ul><li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li><li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li></ul><h4 id="2-根据-CSS-解析生成-CSS-规则树"><a href="#2-根据-CSS-解析生成-CSS-规则树" class="headerlink" title="2.根据 CSS 解析生成 CSS 规则树"></a>2.根据 CSS 解析生成 CSS 规则树</h4><ul><li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li><li>浏览器在 CSS 规则树生成之前不会进行渲染。</li></ul><h4 id="3-结合-DOM-树和-CSS-规则树，生成渲染树"><a href="#3-结合-DOM-树和-CSS-规则树，生成渲染树" class="headerlink" title="3.结合 DOM 树和 CSS 规则树，生成渲染树"></a>3.结合 DOM 树和 CSS 规则树，生成渲染树</h4><ul><li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li><li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li></ul><h4 id="4-根据渲染树计算每一个节点的信息（布局）"><a href="#4-根据渲染树计算每一个节点的信息（布局）" class="headerlink" title="4.根据渲染树计算每一个节点的信息（布局）"></a>4.根据渲染树计算每一个节点的信息（布局）</h4><ul><li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li><li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li></ul><h4 id="5-根据计算好的信息绘制页面"><a href="#5-根据计算好的信息绘制页面" class="headerlink" title="5.根据计算好的信息绘制页面"></a>5.根据计算好的信息绘制页面</h4><ul><li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li><li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li><li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/svg/241787/1597798820594-36226bf6-545b-4f76-80fa-26d7e6c87594.svg#align=left&display=inline&height=258&margin=%5Bobject%20Object%5D&name=image.svg&originHeight=258&originWidth=752&size=106&status=done&style=none&width=752" alt="image.svg"></p><h3 id="8-关闭-TCP-连接（四次挥手）"><a href="#8-关闭-TCP-连接（四次挥手）" class="headerlink" title="8.关闭 TCP 连接（四次挥手）"></a>8.关闭 TCP 连接（四次挥手）</h3><p>通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597798820609-5d026504-6792-41b2-a120-30a32cb5916b.webp#align=left&display=inline&height=288&margin=%5Bobject%20Object%5D&originHeight=288&originWidth=550&size=0&status=done&style=none&width=550" alt=""></p><blockquote><ol><li>第一次挥手：Client 发送一个 FIN，用来关闭 Client 到 Server 的数据传送，Client 进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</li><li>第二次挥手：Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号），Server 进入 CLOSE_WAIT 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li><li>第三次挥手：Server 发送一个 FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li><li>第四次挥手：Client 收到 FIN 后，Client 进入 TIME_WAIT 状态，接着发送一个 ACK 给 Server，确认序号为收到序号+1，Server 进入 CLOSED 状态，完成四次挥手。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</li></ol></blockquote><p>我们看看 GET 和 POST 的区别</p><ol><li><p>GET 提交的数据会放在 URL 之后，以?分割 URL 和传输数据，参数之间以&amp;相连，如 EditPosts.aspx?name=test1&amp;id=123456. POST 方法是把提交的数据放在 HTTP 包的 Body 中.</p></li><li><p>GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制.</p></li><li><p>GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过 Request.Form 来获取变量的值。</p></li><li><p>GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p></li></ol><p>链接：<br><a href="https://juejin.im/post/6844903782015303693" target="_blank" rel="noopener">https://juejin.im/post/6844903782015303693</a><br><a href="https://juejin.im/post/6844903781704925198" target="_blank" rel="noopener">https://juejin.im/post/6844903781704925198</a><br><a href="https://www.jianshu.com/p/80e25cb1d81a" target="_blank" rel="noopener">https://www.jianshu.com/p/80e25cb1d81a</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
            <tag> tcp </tag>
            
            <tag> 浏览器渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试（4）less，sass，stylus</title>
      <link href="/leader755/60928.html"/>
      <url>/leader755/60928.html</url>
      
        <content type="html"><![CDATA[<p>###</p><p>##</p><h2 id="预编译：less，sass，stylus"><a href="#预编译：less，sass，stylus" class="headerlink" title="预编译：less，sass，stylus"></a>预编译：less，sass，stylus</h2><h3 id="预处理语言的诞生"><a href="#预处理语言的诞生" class="headerlink" title="预处理语言的诞生"></a>预处理语言的诞生</h3><p>其中 就我所知的有三门语言：Sass、Less 、Stylus 。</p><ol><li>Sass 诞生于 2007 年，Ruby 编写，其语法功能都十分全面，可以说 它完全把 CSS 变成了一门编程语言。另外 在国内外都很受欢迎，并且它的项目团队很是强大 ，是一款十分优秀的预处理语言。</li><li>Stylus 诞生于 2010 年，来自 Node.js 社区，语法功能也和 Sass 不相伯仲，是一门十分独特的创新型语言。</li><li>Less 诞生于 2009 年，受 Sass 的影响创建的一个开源项目。 它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充（_引用于官网_）。</li></ol><h3 id="选择预处理语言"><a href="#选择预处理语言" class="headerlink" title="选择预处理语言"></a>选择预处理语言</h3><blockquote><p>这是一个十分纠结的问题。</p><ol><li>在网上讨论看来，Sass 与 Stylus 相比于 Less 功能更为丰富，但对于学习成本以及适应时间 ，Less 稍胜一筹，这也是我选择 Less 的原因。</li></ol></blockquote><blockquote><ol><li>Less 没有去掉任何 CSS 的功能，而是在现有的语法上，增添了许多额外的功能特性，所以学习 Less 是一件非常舒服的事情。</li></ol></blockquote><h2 id="sass-用法"><a href="#sass-用法" class="headerlink" title="sass 用法"></a>sass 用法</h2><h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h3><h4 id="1-gt-变量"><a href="#1-gt-变量" class="headerlink" title="1 &gt;变量"></a>1 &gt;变量</h4><p>SASS 允许使用变量，所有变量以$开头。</p><pre class=" language-ruby"><code class="language-ruby">　<span class="token variable">$blue</span> <span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#1875e7;　</span>　　div <span class="token punctuation">{</span>　　　color <span class="token punctuation">:</span> <span class="token variable">$blue</span><span class="token punctuation">;</span>　　<span class="token punctuation">}</span></code></pre><p>如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。</p><pre class=" language-ruby"><code class="language-ruby">　<span class="token variable">$side</span> <span class="token punctuation">:</span> left<span class="token punctuation">;</span>　　<span class="token punctuation">.</span>rounded <span class="token punctuation">{</span>　　　　border<span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$side</span><span class="token punctuation">}</span><span class="token operator">-</span>radius<span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>　　<span class="token punctuation">}</span></code></pre><h4 id="2-gt-计算功能"><a href="#2-gt-计算功能" class="headerlink" title="2&gt; 计算功能"></a>2&gt; 计算功能</h4><p>SASS 允许在代码中使用算式：</p><pre class=" language-ruby"><code class="language-ruby">body <span class="token punctuation">{</span>　　　　margin<span class="token punctuation">:</span> <span class="token punctuation">(</span>14px<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　top<span class="token punctuation">:</span> 50px <span class="token operator">+</span> 100px<span class="token punctuation">;</span>　　　　right<span class="token punctuation">:</span> <span class="token variable">$var</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token operator">%</span><span class="token punctuation">;</span>　　<span class="token punctuation">}</span></code></pre><h4 id="3-gt-嵌套"><a href="#3-gt-嵌套" class="headerlink" title="3&gt; 嵌套"></a>3&gt; 嵌套</h4><p>SASS 允许选择器嵌套。比如，下面的 CSS 代码：</p><pre class=" language-ruby"><code class="language-ruby">　div h1 <span class="token punctuation">{</span>　　　　color <span class="token punctuation">:</span> red<span class="token punctuation">;</span>　　<span class="token punctuation">}</span></code></pre><p>可以写成：</p><pre class=" language-ruby"><code class="language-ruby">　div <span class="token punctuation">{</span>　　　　hi <span class="token punctuation">{</span>　　　　　　color<span class="token symbol">:red</span><span class="token punctuation">;</span>　　　　<span class="token punctuation">}</span>　　<span class="token punctuation">}</span></code></pre><p>属性也可以嵌套，比如 border-color 属性，可以写成：</p><pre class=" language-ruby"><code class="language-ruby">　p <span class="token punctuation">{</span>　　　　border<span class="token punctuation">:</span> <span class="token punctuation">{</span>　　　　　　color<span class="token punctuation">:</span> red<span class="token punctuation">;</span>　　　　<span class="token punctuation">}</span>　　<span class="token punctuation">}</span></code></pre><p>注意，border 后面必须加上冒号。<br>在嵌套的代码块内，可以使用&amp;引用父元素。比如 a:hover 伪类，可以写成：</p><pre class=" language-ruby"><code class="language-ruby">a <span class="token punctuation">{</span>　　　　<span class="token operator">&amp;</span><span class="token symbol">:hover</span> <span class="token punctuation">{</span> color<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#ffb3ff; }</span>　　<span class="token punctuation">}</span></code></pre><h4 id="4-gt-注释"><a href="#4-gt-注释" class="headerlink" title="4&gt;注释"></a>4&gt;注释</h4><p>SASS 共有两种注释风格。<br>标准的 CSS 注释 /_ comment _/ ，会保留到编译后的文件。<br>单行注释 // comment，只保留在 SASS 源文件中，编译后被省略。<br>在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。</p><pre class=" language-ruby"><code class="language-ruby">     <span class="token operator">/</span><span class="token operator">*</span><span class="token operator">!</span>　　　　重要注释！　　<span class="token operator">*</span><span class="token operator">/</span></code></pre><p>**<br>**</p><h3 id="2-代码的重用"><a href="#2-代码的重用" class="headerlink" title="2.代码的重用"></a>2.代码的重用</h3><h4 id="1-gt-继承"><a href="#1-gt-继承" class="headerlink" title="1&gt; 继承"></a>1&gt; 继承</h4><p>SASS 允许一个选择器，继承另一个选择器。比如，现有 class1：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token punctuation">.</span>class1 <span class="token punctuation">{</span>　　　　border<span class="token punctuation">:</span> 1px solid <span class="token comment" spellcheck="true">#ddd;</span>　　<span class="token punctuation">}</span></code></pre><p>class2 要继承 class1，就要使用@extend 命令：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token punctuation">.</span>class2 <span class="token punctuation">{</span>　　　　<span class="token variable">@extend</span> <span class="token punctuation">.</span>class1<span class="token punctuation">;</span>　　　　font<span class="token operator">-</span>size<span class="token punctuation">:</span><span class="token number">120</span><span class="token operator">%</span><span class="token punctuation">;</span>　<span class="token punctuation">}</span></code></pre><h4 id="2-gt-Mixin"><a href="#2-gt-Mixin" class="headerlink" title="2&gt; Mixin"></a>2&gt; Mixin</h4><p>Mixin 有点像 C 语言的宏（macro），是可以重用的代码块。<br>使用@mixin 命令，定义一个代码块。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">@mixin</span> left <span class="token punctuation">{</span>　　　　float<span class="token punctuation">:</span> left<span class="token punctuation">;</span>　　　　margin<span class="token operator">-</span>left<span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>　　<span class="token punctuation">}</span></code></pre><p>使用@include 命令，调用这个 mixin。</p><pre class=" language-ruby"><code class="language-ruby">div <span class="token punctuation">{</span>　　　　<span class="token variable">@include</span> left<span class="token punctuation">;</span>　　<span class="token punctuation">}</span></code></pre><p>mixin 的强大之处，在于可以指定参数和缺省值。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">@mixin</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token variable">$value</span><span class="token punctuation">:</span> 10px<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　float<span class="token punctuation">:</span> left<span class="token punctuation">;</span>　　　　margin<span class="token operator">-</span>right<span class="token punctuation">:</span> <span class="token variable">$value</span><span class="token punctuation">;</span>　　<span class="token punctuation">}</span></code></pre><p>使用的时候，根据需要加入参数：</p><pre class=" language-ruby"><code class="language-ruby">div <span class="token punctuation">{</span>　　　　<span class="token variable">@include</span> <span class="token function">left</span><span class="token punctuation">(</span>20px<span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token punctuation">}</span></code></pre><p>下面是一个 mixin 的实例，用来生成浏览器前缀。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">@mixin</span> <span class="token function">rounded</span><span class="token punctuation">(</span><span class="token variable">$vert</span><span class="token punctuation">,</span> <span class="token variable">$horz</span><span class="token punctuation">,</span> <span class="token variable">$radius</span><span class="token punctuation">:</span> 10px<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　border<span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$vert</span><span class="token punctuation">}</span><span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$horz</span><span class="token punctuation">}</span><span class="token operator">-</span>radius<span class="token punctuation">:</span> <span class="token variable">$radius</span><span class="token punctuation">;</span>　　　　<span class="token operator">-</span>moz<span class="token operator">-</span>border<span class="token operator">-</span>radius<span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$vert</span><span class="token punctuation">}</span>#<span class="token punctuation">{</span><span class="token variable">$horz</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token variable">$radius</span><span class="token punctuation">;</span>　　　　<span class="token operator">-</span>webkit<span class="token operator">-</span>border<span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$vert</span><span class="token punctuation">}</span><span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$horz</span><span class="token punctuation">}</span><span class="token operator">-</span>radius<span class="token punctuation">:</span> <span class="token variable">$radius</span><span class="token punctuation">;</span>　　<span class="token punctuation">}</span></code></pre><p>使用的时候，可以像下面这样调用：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true">#navbar li { @include rounded(top, left); }</span><span class="token comment" spellcheck="true">#footer { @include rounded(top, left, 5px); }</span></code></pre><h4 id="3-gt-颜色函数"><a href="#3-gt-颜色函数" class="headerlink" title="3&gt; 颜色函数"></a>3&gt; 颜色函数</h4><p>SASS 提供了一些内置的颜色函数，以便生成系列颜色。</p><pre class=" language-ruby"><code class="language-ruby">     <span class="token function">lighten</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">#cc3, 10%) // #d6d65c</span>　　<span class="token function">darken</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">#cc3, 10%) // #a3a329</span>　　<span class="token function">grayscale</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">#cc3) // #808080</span>　　<span class="token function">complement</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">#cc3) // #33c</span></code></pre><h4 id="4-gt-插入文件"><a href="#4-gt-插入文件" class="headerlink" title="4&gt; 插入文件"></a>4&gt; 插入文件</h4><p>@import 命令，用来插入外部文件。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">@import</span> <span class="token string">"path/filename.scss"</span><span class="token punctuation">;</span></code></pre><p>如果插入的是.css 文件，则等同于 css 的 import 命令。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">@import</span> <span class="token string">"foo.css"</span><span class="token punctuation">;</span></code></pre><h3 id="3-高级用法"><a href="#3-高级用法" class="headerlink" title="3.高级用法"></a>3.高级用法</h3><h4 id="1-gt-条件语句"><a href="#1-gt-条件语句" class="headerlink" title="1&gt; 条件语句"></a>1&gt; 条件语句</h4><p>@if 可以用来判断：</p><pre class=" language-ruby"><code class="language-ruby">p <span class="token punctuation">{</span>　　　　<span class="token variable">@if</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">{</span> border<span class="token punctuation">:</span> 1px solid<span class="token punctuation">;</span> <span class="token punctuation">}</span>　　　　<span class="token variable">@if</span> <span class="token number">5</span> <span class="token operator">&lt;</span> <span class="token number">3</span> <span class="token punctuation">{</span> border<span class="token punctuation">:</span> 2px dotted<span class="token punctuation">;</span> <span class="token punctuation">}</span>　　<span class="token punctuation">}</span></code></pre><p>配套的还有@else 命令：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">@if</span> <span class="token function">lightness</span><span class="token punctuation">(</span><span class="token variable">$color</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">30</span><span class="token operator">%</span> <span class="token punctuation">{</span>　　　　background<span class="token operator">-</span>color<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#000;</span>　　<span class="token punctuation">}</span> <span class="token variable">@else</span> <span class="token punctuation">{</span>　　　　background<span class="token operator">-</span>color<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#fff;</span>　　<span class="token punctuation">}</span></code></pre><h4 id="2-gt-循环语句"><a href="#2-gt-循环语句" class="headerlink" title="2&gt; 循环语句"></a>2&gt; 循环语句</h4><p>SASS 支持 for 循环：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">@for</span> <span class="token variable">$i</span> from <span class="token number">1</span> to <span class="token number">10</span> <span class="token punctuation">{</span>　　　　<span class="token punctuation">.</span>border<span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$i</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>　　　　　　border<span class="token punctuation">:</span> #<span class="token punctuation">{</span><span class="token variable">$i</span><span class="token punctuation">}</span>px solid blue<span class="token punctuation">;</span>　　　　<span class="token punctuation">}</span>　　<span class="token punctuation">}</span></code></pre><p>也支持 while 循环：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">$i</span><span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">;</span>　　<span class="token variable">@while</span> <span class="token variable">$i</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>　　　　<span class="token punctuation">.</span>item<span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$i</span><span class="token punctuation">}</span> <span class="token punctuation">{</span> width<span class="token punctuation">:</span> 2em <span class="token operator">*</span> <span class="token variable">$i</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>　　　　<span class="token variable">$i</span><span class="token punctuation">:</span> <span class="token variable">$i</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>　　<span class="token punctuation">}</span></code></pre><p>each 命令，作用与 for 类似：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">@each</span> <span class="token variable">$member</span> <span class="token keyword">in</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d <span class="token punctuation">{</span>　　　　<span class="token punctuation">.</span>#<span class="token punctuation">{</span><span class="token variable">$member</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>　　　　　　background<span class="token operator">-</span>image<span class="token punctuation">:</span> <span class="token function">url</span><span class="token punctuation">(</span><span class="token string">"/image/<span class="token interpolation"><span class="token delimiter tag">#{</span>$member<span class="token delimiter tag">}</span></span>.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　<span class="token punctuation">}</span>　　<span class="token punctuation">}</span></code></pre><h4 id="3-gt-自定义函数"><a href="#3-gt-自定义函数" class="headerlink" title="3&gt; 自定义函数"></a>3&gt; 自定义函数</h4><p>SASS 允许用户编写自己的函数。</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">@function</span> <span class="token function">double</span><span class="token punctuation">(</span><span class="token variable">$n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　<span class="token variable">@return</span> <span class="token variable">$n</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>　　<span class="token punctuation">}</span>　　<span class="token comment" spellcheck="true">#sidebar {</span>　　　　width<span class="token punctuation">:</span> <span class="token function">double</span><span class="token punctuation">(</span>5px<span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token punctuation">}</span></code></pre><h3 id="关于-sass-的常见使用总结："><a href="#关于-sass-的常见使用总结：" class="headerlink" title="关于 sass 的常见使用总结："></a>关于 sass 的常见使用总结：</h3><h4 id="1-gt-变量-1"><a href="#1-gt-变量-1" class="headerlink" title="1&gt;变量"></a>1&gt;变量</h4><pre class=" language-ruby"><code class="language-ruby"><span class="token operator">/</span><span class="token operator">/</span>定义变量<span class="token variable">$blue</span> <span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#1875e7;</span><span class="token variable">$side</span> <span class="token punctuation">:</span> left<span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span>常规使用div <span class="token punctuation">{</span>  　          color <span class="token punctuation">:</span> <span class="token variable">$blue</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">/</span>字符串中使用 #<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span>rounded <span class="token punctuation">{</span>　　border<span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$side</span><span class="token punctuation">}</span><span class="token operator">-</span>radius<span class="token punctuation">:</span> 5px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-gt-继承"><a href="#2-gt-继承" class="headerlink" title="2&gt;继承"></a>2&gt;继承</h4><p>使用@extend 来实现一个类对另一个类的继承</p><pre class=" language-ruby"><code class="language-ruby"><span class="token punctuation">.</span>class1 <span class="token punctuation">{</span>　　　　border<span class="token punctuation">:</span> 1px solid <span class="token comment" spellcheck="true">#ddd;</span> <span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">/</span>class2 继承 class1<span class="token punctuation">,</span>使用 <span class="token variable">@extend</span><span class="token punctuation">.</span>class2 <span class="token punctuation">{</span>　　　　<span class="token variable">@extend</span> <span class="token punctuation">.</span>class1<span class="token punctuation">;</span>　　　　font<span class="token operator">-</span>size<span class="token punctuation">:</span><span class="token number">120</span><span class="token operator">%</span><span class="token punctuation">;</span>　<span class="token punctuation">}</span></code></pre><h4 id="3-gt-mixin"><a href="#3-gt-mixin" class="headerlink" title="3&gt;mixin"></a>3&gt;mixin</h4><p><strong>使用@mixin 定义一个代码块，使用@include 命令，调用这个 mixin</strong></p><pre class=" language-ruby"><code class="language-ruby"><span class="token operator">/</span><span class="token operator">/</span>常规使用<span class="token variable">@mixin</span> left<span class="token punctuation">{</span>      float<span class="token punctuation">:</span> left<span class="token punctuation">;</span>　　 margin<span class="token operator">-</span>left<span class="token punctuation">:</span> 10px<span class="token punctuation">;</span><span class="token punctuation">}</span>div <span class="token punctuation">{</span>　　<span class="token variable">@include</span> left<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">/</span>用来生成浏览器的前缀，可设置变量和变量默认值<span class="token variable">@mixin</span> <span class="token function">rounded</span><span class="token punctuation">(</span><span class="token variable">$vert</span><span class="token punctuation">,</span> <span class="token variable">$horz</span><span class="token punctuation">,</span> <span class="token variable">$radius</span><span class="token punctuation">:</span> 10px<span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　border<span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$vert</span><span class="token punctuation">}</span><span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$horz</span><span class="token punctuation">}</span><span class="token operator">-</span>radius<span class="token punctuation">:</span> <span class="token variable">$radius</span><span class="token punctuation">;</span>　　　　<span class="token operator">-</span>moz<span class="token operator">-</span>border<span class="token operator">-</span>radius<span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$vert</span><span class="token punctuation">}</span>#<span class="token punctuation">{</span><span class="token variable">$horz</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token variable">$radius</span><span class="token punctuation">;</span>　　　　<span class="token operator">-</span>webkit<span class="token operator">-</span>border<span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$vert</span><span class="token punctuation">}</span><span class="token operator">-</span>#<span class="token punctuation">{</span><span class="token variable">$horz</span><span class="token punctuation">}</span><span class="token operator">-</span>radius<span class="token punctuation">:</span> <span class="token variable">$radius</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#navbar li {</span>    <span class="token variable">@include</span> <span class="token function">rounded</span><span class="token punctuation">(</span>top<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#footer {</span>    <span class="token variable">@include</span> <span class="token function">rounded</span><span class="token punctuation">(</span>top<span class="token punctuation">,</span> left<span class="token punctuation">,</span> 5px<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>** 4&gt;自定义函数**</p><pre class=" language-ruby"><code class="language-ruby"><span class="token variable">@function</span> <span class="token function">double</span><span class="token punctuation">(</span><span class="token variable">$n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　<span class="token variable">@return</span> <span class="token variable">$n</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#sidebar {</span>　　width<span class="token punctuation">:</span> <span class="token function">double</span><span class="token punctuation">(</span>5px<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>**</p><h2 id="less-用法："><a href="#less-用法：" class="headerlink" title="less 用法："></a>less 用法：</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>1&gt;值变量</strong></p><pre class=" language-less"><code class="language-less"><span class="token variable">@color<span class="token punctuation">:</span></span> <span class="token hexcode">#999</span><span class="token punctuation">;</span><span class="token selector">#wrap</span> <span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token variable">@color</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>2&gt;选择器变量(</strong>变量名 必须使用大括号包裹 <a href="">@{变量名}</a><strong>)</strong></p><pre class=" language-less"><code class="language-less"><span class="token variable">@Wrap<span class="token punctuation">:</span></span> wrap<span class="token punctuation">;</span><span class="token variable">@mySelector<span class="token punctuation">:</span></span> #wrap<span class="token punctuation">;</span><span class="token selector">@{mySelector}</span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#999</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.@{Wrap}</span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span><span class="token hexcode">#ccc</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#@{Wrap}</span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span><span class="token hexcode">#666</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>3&gt;<strong>属性变量(</strong>变量名 必须使用大括号包裹 @{变量名}<strong>)</strong></p><pre class=" language-less"><code class="language-less"><span class="token variable">@borderStyle<span class="token punctuation">:</span></span> border<span class="token operator">-</span>style<span class="token punctuation">;</span><span class="token variable">@Soild<span class="token punctuation">:</span></span> solid<span class="token punctuation">;</span><span class="token selector">#wrap</span> <span class="token punctuation">{</span>  <span class="token property">@{borderStyle}</span><span class="token punctuation">:</span> <span class="token variable">@Soild</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//变量名 必须使用大括号包裹</span><span class="token punctuation">}</span></code></pre><p><strong>4&gt; url 变量</strong></p><pre class=" language-less"><code class="language-less"><span class="token variable">@images<span class="token punctuation">:</span></span> <span class="token string">"../img"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//需要加引号</span><span class="token selector">body</span> <span class="token punctuation">{</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url">url("@{images}/dog.png")</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//变量名 必须使用大括号包裹</span><span class="token punctuation">}</span></code></pre><p><strong>5&gt;声明变量(引用一段代码)</strong><br>有点类似于 下面的 混合方法</p><ul><li>结构: @name: { 属性: 值 ;};</li><li>使用：@name();</li></ul><pre class=" language-less"><code class="language-less"><span class="token atrule">@background<span class="token punctuation">:</span></span> <span class="token punctuation">{</span>  <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token selector">#main</span> <span class="token punctuation">{</span>  <span class="token variable">@background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>6&gt;变量运算</strong></p><ul><li>加减法时 以第一个数据的单位为基准</li><li>乘除法时 注意单位一定要统一</li></ul><pre class=" language-less"><code class="language-less"><span class="token variable">@width<span class="token punctuation">:</span></span> <span class="token number">300</span>px<span class="token punctuation">;</span><span class="token variable">@color<span class="token punctuation">:</span></span> <span class="token hexcode">#222</span><span class="token punctuation">;</span><span class="token selector">#wrap</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token variable">@width-20</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token variable">@width-20</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token variable">@width-20</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token variable">@color</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token variable">@color</span> <span class="token operator">+</span> <span class="token hexcode">#111</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token selector">#wrap</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">280</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">1400</span>px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#444</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#333</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>7&gt;变量作用域</strong><br>一句话理解就是：<strong>就近原则</strong>，不要跟我提闭包。</p><pre class=" language-less"><code class="language-less"><span class="token variable">@var<span class="token punctuation">:</span></span> <span class="token variable">@a</span><span class="token punctuation">;</span><span class="token variable">@a<span class="token punctuation">:</span></span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token selector">#wrap</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token variable">@var</span><span class="token punctuation">;</span>  <span class="token variable">@a<span class="token punctuation">:</span></span> <span class="token number">9%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token selector">#wrap</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">9%</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>8&gt;<strong>用变量去定义变量</strong></p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token variable">@fnord<span class="token punctuation">:</span></span> <span class="token string">"I am fnord."</span><span class="token punctuation">;</span><span class="token variable">@var<span class="token punctuation">:</span></span> <span class="token string">"fnord"</span><span class="token punctuation">;</span><span class="token selector">#wrap::after</span> <span class="token punctuation">{</span>  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token variable">@@var</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将@var替换为其值 content:@fnord;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token selector">#wrap::after</span> <span class="token punctuation">{</span>  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">"I am fnord."</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p><strong>1&gt; &amp; 的妙用</strong><br>&amp; ：代表的上一层选择器的名字，此例便是<code>header</code>。</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">#header</span> <span class="token punctuation">{</span>  <span class="token selector">&amp;:after</span> <span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">"Less is more!"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector">.title</span> <span class="token punctuation">{</span>    <span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector">&amp;_content</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//理解方式：直接把 &amp; 替换成 #header</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token selector">#header::after</span> <span class="token punctuation">{</span>  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">"Less is more!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#header .title</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//嵌套了</span>  <span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#header_content</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//没有嵌套！</span>  <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>2&gt;媒体查询</strong><br>在以往的工作中，我们使用 媒体查询，都要把一个元素 分开写</p><pre class=" language-less"><code class="language-less"><span class="token selector">#wrap</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">500</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule">@media screen and <span class="token punctuation">(</span>max-width<span class="token punctuation">:</span> 768px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>  <span class="token selector">#wrap</span> <span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>Less 提供了一个十分便捷的方式</li></ul><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">#main</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//something...</span>  <span class="token atrule">@media screen</span> <span class="token punctuation">{</span>    <span class="token atrule">@media <span class="token punctuation">(</span>max-width<span class="token punctuation">:</span> 768px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>      <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token atrule">@media tv</span> <span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">2000</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token atrule">@media screen and <span class="token punctuation">(</span>maxwidth<span class="token punctuation">:</span> 768px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>  <span class="token selector">#main</span> <span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token atrule">@media tv</span> <span class="token punctuation">{</span>  <span class="token selector">#main</span> <span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">2000</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>唯一的缺点就是 每一个元素都会编译出自己 <code>@media</code> 声明，并不会合并。</li><li></li></ul><p><strong>3&gt;实战技巧</strong><br>可以借助 Less 在元素中，去定义自己的私有样式。</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">#main</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// something..</span>  <span class="token selector">&amp;.show</span> <span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">.show</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-less"><code class="language-less">const main = document<span class="token number">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>main<span class="token number">.</span>classList<span class="token number">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"show"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>复制代码</code></pre><ul><li>结果：</li></ul><pre class=" language-less"><code class="language-less"><span class="token selector">#main.show</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.show</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//会被覆盖。</span><span class="token punctuation">}</span></code></pre><h3 id="混合方法"><a href="#混合方法" class="headerlink" title="混合方法"></a>混合方法</h3><ol><li><strong>无参数方法</strong>方法犹如 声明的集合，使用时 直接键入名称即可。</li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">.card</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 等价于 .card()</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#f6f6f6</span><span class="token punctuation">;</span>    <span class="token property">-webkit-box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">1</span>px <span class="token number">2</span>px <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">.58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">1</span>px <span class="token number">2</span>px <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">.58</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#wrap</span><span class="token punctuation">{</span>  <span class="token mixin-usage function">.card</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等价于.card();</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token selector">#wrap</span><span class="token punctuation">{</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#f6f6f6</span><span class="token punctuation">;</span>  <span class="token property">-webkit-box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">1</span>px <span class="token number">2</span>px <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">.58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">1</span>px <span class="token number">2</span>px <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">.58</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码</code></pre><ol><li>其中 <code>.card</code> 与 <code>.card()</code> 是等价的。 个人建议，为了避免 代码混淆，应写成 :</li></ol><pre><code>.card(){  //something...}#wrap{  .card();}复制代码</code></pre><ol><li>要点：<ul><li><code>.</code> 与 <code>#</code> 皆可作为 方法前缀。</li><li>方法后写不写 <code>()</code> 看个人习惯。</li></ul></li><li><strong>默认参数方法</strong><ul><li>Less 可以使用默认参数，如果 没有传参数，那么将使用默认参数。</li><li><code>@arguments</code> 犹如 JS 中的 <code>arguments</code> 指代的是 全部参数。</li><li>传的参数中 必须带着单位。</li></ul></li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">.border(<span class="token variable">@a</span>:10px,<span class="token variable">@b</span>:50px,<span class="token variable">@c</span>:30px,<span class="token variable">@color</span>:#000)</span><span class="token punctuation">{</span>    <span class="token property">border</span><span class="token punctuation">:</span>solid <span class="token number">1</span>px <span class="token variable">@color</span><span class="token punctuation">;</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token variable">@arguments</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指代的是 全部参数</span><span class="token punctuation">}</span><span class="token selector">#main</span><span class="token punctuation">{</span>    <span class="token mixin-usage function">.border</span><span class="token punctuation">(</span><span class="token number">0</span>px<span class="token punctuation">,</span><span class="token number">5</span>px<span class="token punctuation">,</span><span class="token number">30</span>px<span class="token punctuation">,</span>red<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//必须带着单位</span><span class="token punctuation">}</span><span class="token selector">#wrap</span><span class="token punctuation">{</span>    <span class="token mixin-usage function">.border</span><span class="token punctuation">(</span><span class="token number">0</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#content</span><span class="token punctuation">{</span>  <span class="token mixin-usage function">.border</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等价于 .border()</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token selector">#main</span><span class="token punctuation">{</span>    <span class="token property">border</span><span class="token punctuation">:</span>solid <span class="token number">1</span>px red<span class="token punctuation">;</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">,</span><span class="token number">5</span>px<span class="token punctuation">,</span><span class="token number">30</span>px<span class="token punctuation">,</span>red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#wrap</span><span class="token punctuation">{</span>    <span class="token property">border</span><span class="token punctuation">:</span>solid <span class="token number">1</span>px <span class="token hexcode">#000</span><span class="token punctuation">;</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span>px <span class="token number">50</span>px <span class="token number">30</span>px <span class="token hexcode">#000</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#content</span><span class="token punctuation">{</span>    <span class="token property">border</span><span class="token punctuation">:</span>solid <span class="token number">1</span>px <span class="token hexcode">#000</span><span class="token punctuation">;</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token number">10</span>px <span class="token number">50</span>px <span class="token number">30</span>px <span class="token hexcode">#000</span><span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码</code></pre><ol><li><strong>方法的匹配模式</strong>与 面向对象中的多态 很相似</li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">.triangle(top,<span class="token variable">@width</span>:20px,<span class="token variable">@color</span>:#000)</span> <span class="token punctuation">{</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> transparent transparent <span class="token variable">@color</span> transparent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.triangle(right,<span class="token variable">@width</span>:20px,<span class="token variable">@color</span>:#000)</span> <span class="token punctuation">{</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> transparent <span class="token variable">@color</span> transparent transparent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.triangle(bottom,<span class="token variable">@width</span>:20px,<span class="token variable">@color</span>:#000)</span> <span class="token punctuation">{</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> <span class="token variable">@color</span> transparent transparent transparent<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.triangle(left,<span class="token variable">@width</span>:20px,<span class="token variable">@color</span>:#000)</span> <span class="token punctuation">{</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> transparent transparent transparent <span class="token variable">@color</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.triangle(<span class="token variable">@_</span>,<span class="token variable">@width</span>:20px,<span class="token variable">@color</span>:#000)</span> <span class="token punctuation">{</span>  <span class="token property">border-style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>  <span class="token property">border-width</span><span class="token punctuation">:</span> <span class="token variable">@width</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#main</span> <span class="token punctuation">{</span>  <span class="token mixin-usage function">.triangle</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token number">50</span>px<span class="token punctuation">,</span> <span class="token hexcode">#999</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token selector">#main</span> <span class="token punctuation">{</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> transparent transparent transparent <span class="token hexcode">#999</span><span class="token punctuation">;</span>  <span class="token property">border-style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>  <span class="token property">border-width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>要点<ul><li>第一个参数 <code>left</code> 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。</li><li>如果匹配的参数 是变量，则将会匹配，如 <code>@_</code> 。</li></ul></li><li><strong>方法的命名空间</strong>让方法更加规范</li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">#card()</span><span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#723232</span><span class="token punctuation">;</span>    <span class="token selector">.d(<span class="token variable">@w</span>:300px)</span><span class="token punctuation">{</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token variable">@w</span><span class="token punctuation">;</span>        <span class="token selector">#a(<span class="token variable">@h</span>:300px)</span><span class="token punctuation">{</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token variable">@h</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//可以使用上一层传进来的方法</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">#wrap</span><span class="token punctuation">{</span>    <span class="token mixin-usage function">#card > .d > #a</span><span class="token punctuation">(</span><span class="token number">100</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 父元素不能加 括号</span><span class="token punctuation">}</span><span class="token selector">#main</span><span class="token punctuation">{</span>    <span class="token mixin-usage function">#card .d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#con</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//不得单独使用命名空间的方法</span>    <span class="token comment" spellcheck="true">//.d() 如果前面没有引入命名空间 #card ，将会报错</span>    #card<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等价于 #card();</span>    <span class="token number">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">20</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//必须先引入 #card</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token selector">#wrap</span><span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#main</span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">300</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#con</span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码</code></pre><ol><li>要点<ul><li>在 CSS 中<code>&gt;</code> 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。</li><li>在引入命令空间时，如使用 <code>&gt;</code> 选择器，父元素不能加 括号。</li><li>不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。</li><li>子方法 可以使用上一层传进来的方法</li></ul></li><li><strong>方法的条件筛选</strong>Less 没有 if else，可是它有 <code>when</code></li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">#card</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// and 运算符 ，相当于 与运算 &amp;&amp;，必须条件全部符合才会执行</span>    <span class="token selector">.border(<span class="token variable">@width</span>,<span class="token variable">@color</span>,<span class="token variable">@style</span>) when (<span class="token variable">@width</span>>100px) and(<span class="token variable">@color</span>=#999)</span><span class="token punctuation">{</span>        <span class="token property">border</span><span class="token punctuation">:</span><span class="token variable">@style</span> <span class="token variable">@color</span> <span class="token variable">@width</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// not 运算符，相当于 非运算 !，条件为 不符合才会执行</span>    <span class="token selector">.background(<span class="token variable">@color</span>) when not (<span class="token variable">@color</span>>=#222)</span><span class="token punctuation">{</span>        <span class="token property">background</span><span class="token punctuation">:</span><span class="token variable">@color</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行</span>    <span class="token selector">.font(<span class="token variable">@size</span>:20px) when (<span class="token variable">@size</span>>50px) , (<span class="token variable">@size</span>&lt;100px)</span><span class="token punctuation">{</span>        <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token variable">@size</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">#main</span><span class="token punctuation">{</span>    <span class="token mixin-usage function">#card>.border</span><span class="token punctuation">(</span><span class="token number">200</span>px<span class="token punctuation">,</span><span class="token hexcode">#999</span><span class="token punctuation">,</span>solid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">#card .background</span><span class="token punctuation">(</span><span class="token hexcode">#111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">#card > .font</span><span class="token punctuation">(</span><span class="token number">40</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token selector">#main</span><span class="token punctuation">{</span>  <span class="token property">border</span><span class="token punctuation">:</span>solid <span class="token hexcode">#999</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span><span class="token hexcode">#111</span><span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">40</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码</code></pre><ol><li>要点<ul><li>比较运算有： &gt; &gt;= = =&lt; &lt;。</li><li>= 代表的是等于</li><li>除去关键字 true 以外的值都被视为 false：</li></ul></li><li><strong>数量不定的参数</strong><br>如果你希望你的方法接受数量不定的参数，你可以使用… ，犹如 ES6 的扩展运算符。</li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">.boxShadow(...)</span><span class="token punctuation">{</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token variable">@arguments</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.textShadow(<span class="token variable">@a</span>,...)</span><span class="token punctuation">{</span>    <span class="token property">text-shadow</span><span class="token punctuation">:</span> <span class="token variable">@arguments</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#main</span><span class="token punctuation">{</span>    <span class="token mixin-usage function">.boxShadow</span><span class="token punctuation">(</span><span class="token number">1</span>px<span class="token punctuation">,</span><span class="token number">4</span>px<span class="token punctuation">,</span><span class="token number">30</span>px<span class="token punctuation">,</span>red<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">.textShadow</span><span class="token punctuation">(</span><span class="token number">1</span>px<span class="token punctuation">,</span><span class="token number">4</span>px<span class="token punctuation">,</span><span class="token number">30</span>px<span class="token punctuation">,</span>red<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token selector">#main</span><span class="token punctuation">{</span>  <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token number">1</span>px <span class="token number">4</span>px <span class="token number">30</span>px red<span class="token punctuation">;</span>  <span class="token property">text-shadow</span><span class="token punctuation">:</span> <span class="token number">1</span>px <span class="token number">4</span>px <span class="token number">30</span>px red<span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码</code></pre><ol><li><strong>方法使用 important！</strong><br>使用方法 非常简单，在方法名后 加上关键字即可。</li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">.border</span><span class="token punctuation">{</span>    <span class="token property">border</span><span class="token punctuation">:</span> solid <span class="token number">1</span>px red<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#main</span><span class="token punctuation">{</span>    <span class="token mixin-usage function">.border</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token important">!important</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token selector">#main</span> <span class="token punctuation">{</span>    <span class="token property">border</span><span class="token punctuation">:</span> solid <span class="token number">1</span>px red <span class="token important">!important</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">50</span>px <span class="token important">!important</span><span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码</code></pre><ol><li><strong>循环方法</strong><br>Less 并没有提供 for 循环功能，但这也难不倒 聪明的程序员，使用递归去实现。 下面是官网中的一个 Demo，模拟了生成栅格系统。</li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">.generate-columns(4);.generate-columns(<span class="token variable">@n</span>, <span class="token variable">@i</span>: 1) when (<span class="token variable">@i</span> =&lt; <span class="token variable">@n</span>)</span> <span class="token punctuation">{</span>  <span class="token selector">.column-@{i}</span> <span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token variable">@i</span> <span class="token operator">*</span> <span class="token number">100%</span> <span class="token operator">/</span> <span class="token variable">@n</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token number">.</span><span class="token function">generate-columns</span><span class="token punctuation">(</span><span class="token variable">@n</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token variable">@i</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token selector">.column-1</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">25%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.column-2</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.column-3</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">75%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.column-4</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码</code></pre><ol><li><strong>属性拼接方法</strong><code>+_</code> 代表的是 空格；<code>+</code> 代表的是 逗号。<ul><li>逗号</li></ul></li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">.boxShadow()</span> <span class="token punctuation">{</span>    <span class="token property">box-shadow+</span><span class="token punctuation">:</span> inset <span class="token number">0</span> <span class="token number">0</span> <span class="token number">10</span>px <span class="token hexcode">#555</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.main</span> <span class="token punctuation">{</span>  <span class="token mixin-usage function">.boxShadow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">box-shadow+</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">20</span>px black<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token selector">.main</span> <span class="token punctuation">{</span>  <span class="token property">box-shadow</span><span class="token punctuation">:</span> inset <span class="token number">0</span> <span class="token number">0</span> <span class="token number">10</span>px <span class="token hexcode">#555</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">20</span>px black<span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码</code></pre><ul><li>空格</li></ul><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">.Animation()</span> <span class="token punctuation">{</span>  <span class="token property">transform+_</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.main</span> <span class="token punctuation">{</span>  <span class="token mixin-usage function">.Animation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">transform+_</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token number">15</span>deg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token selector">.main</span> <span class="token punctuation">{</span>  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token number">15</span>deg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码</code></pre><ol><li><strong>实战技巧</strong><br>下面是官网中的一个非常赞的 Demo</li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">.average(<span class="token variable">@x</span>, <span class="token variable">@y</span>)</span> <span class="token punctuation">{</span>  <span class="token variable">@average<span class="token punctuation">:</span></span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">@x</span> <span class="token operator">+</span> <span class="token variable">@y</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">div</span> <span class="token punctuation">{</span>  <span class="token mixin-usage function">.average</span><span class="token punctuation">(</span><span class="token number">16</span>px<span class="token punctuation">,</span> <span class="token number">50</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用 方法</span>  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token variable">@average</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用返回值</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token selector">div</span> <span class="token punctuation">{</span>  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">33</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码</code></pre><p>可以说 Less 是一门优雅编程语言。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。</p><ol><li><strong>extend 关键字的使用</strong></li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">.animation</span> <span class="token punctuation">{</span>  <span class="token property">transition</span><span class="token punctuation">:</span> all <span class="token number">0.3</span>s ease<span class="token operator">-</span>out<span class="token punctuation">;</span>  <span class="token selector">.hide</span> <span class="token punctuation">{</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">#main</span> <span class="token punctuation">{</span>  &amp;<span class="token punctuation">:</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token number">.</span>animation<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#con</span> <span class="token punctuation">{</span>  &amp;<span class="token punctuation">:</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token number">.</span>animation <span class="token number">.</span>hide<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token selector">.animation,#main</span> <span class="token punctuation">{</span>  <span class="token property">transition</span><span class="token punctuation">:</span> all <span class="token number">0.3</span>s ease<span class="token operator">-</span>out<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.animation .hide,#con</span> <span class="token punctuation">{</span>  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li><strong>all 全局搜索替换</strong><br>使用选择器匹配到的 全部声明。</li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">#main</span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#main</span> <span class="token punctuation">{</span>  <span class="token selector">&amp;:after</span> <span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"Less is good!"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">#wrap:extend(#main all)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token selector">#main,#wrap</span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#main:after, #wrap:after</span> <span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">"Less is good!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码</code></pre><ol><li><strong>减少代码的重复性</strong><br>从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明，这无疑 增加了代码的重复性。<br>方法示例 与上面的 extend 进行对比：</li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">.Method</span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token selector">&amp;:after</span> <span class="token punctuation">{</span>      <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"Less is good!"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">#main</span><span class="token punctuation">{</span>  <span class="token mixin-usage function">.Method</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#wrap</span><span class="token punctuation">{</span>  <span class="token mixin-usage function">.Method</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token selector">#main</span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token selector">&amp;:after</span><span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"Less is good!"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token selector">#wrap</span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token selector">&amp;:after</span><span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"Less is good!"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码</code></pre><ol><li><p><strong>要点</strong><em>翻译官网</em></p><ul><li>选择器和扩展之间 是允许有空格的：pre:hover :extend(div pre).</li><li>可以有多个扩展: pre:hover:extend(div pre):extend(.bucket tr) - 注意这与 pre:hover:extend(div pre, .bucket tr)一样。</li><li>这是不可以的，扩展必须在最后 : pre:hover:extend(div pre).nth-child(odd)。</li><li>如果一个规则集包含多个选择器，所有选择器都可以使用 extend 关键字。</li></ul></li><li><p>导入</p><ol><li>导入 less 文件 可省略后缀</li></ol></li></ol><pre class=" language-less"><code class="language-less">import <span class="token string">"main"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等价于</span>import <span class="token string">"main.less"</span><span class="token punctuation">;</span>复制代码</code></pre><ol><li><code>@import</code> 的位置可随意放置</li></ol><pre class=" language-less"><code class="language-less"><span class="token selector">#main</span><span class="token punctuation">{</span>  <span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">15</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">@import</span> <span class="token string">"style"</span><span class="token punctuation">;</span>复制代码</code></pre><ol><li><strong>reference</strong><br>Less 中 最强大的特性 使用 引入的 Less 文件，但不会 编译它。</li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token atrule">@import <span class="token punctuation">(</span>reference<span class="token punctuation">)</span> "bootstrap.less";#wrap<span class="token punctuation">:</span>extend<span class="token punctuation">(</span>.navbar all<span class="token punctuation">)</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ol><li><p>翻译官网：</p><blockquote><p>使用@import (reference)导入外部文件，但不会添加 把导入的文件 编译到最终输出中，只引用。</p></blockquote></li><li><p><strong>once</strong></p><blockquote><p>@import 语句的默认行为。这表明相同的文件只会被导入一次，而随后的导入文件的重复代码都不会解析。</p></blockquote></li></ol><pre class=" language-less"><code class="language-less"><span class="token variable">@import</span> <span class="token punctuation">(</span>once<span class="token punctuation">)</span> <span class="token string">"foo.less"</span><span class="token punctuation">;</span><span class="token variable">@import</span> <span class="token punctuation">(</span>once<span class="token punctuation">)</span> <span class="token string">"foo.less"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this statement will be ignored</span>复制代码</code></pre><ol><li><strong>multiple</strong><blockquote><p>使用@import (multiple)允许导入多个同名文件。</p></blockquote></li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token comment" spellcheck="true">// file: foo.less</span><span class="token selector">.a</span> <span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// file: main.less</span><span class="token variable">@import</span> <span class="token punctuation">(</span>multiple<span class="token punctuation">)</span> <span class="token string">"foo.less"</span><span class="token punctuation">;</span><span class="token variable">@import</span> <span class="token punctuation">(</span>multiple<span class="token punctuation">)</span> <span class="token string">"foo.less"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token selector">.a</span> <span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.a</span> <span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol><li><strong>判断类型</strong><ul><li>isnumber<blockquote><p>判断给定的值 是否 是一个数字。</p></blockquote></li></ul></li></ol><pre class=" language-less"><code class="language-less"><span class="token function">isnumber</span><span class="token punctuation">(</span><span class="token hexcode">#ff0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// false</span><span class="token function">isnumber</span><span class="token punctuation">(</span>blue<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// false</span><span class="token function">isnumber</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span><span class="token function">isnumber</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// true</span><span class="token function">isnumber</span><span class="token punctuation">(</span><span class="token number">56</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// true</span><span class="token function">isnumber</span><span class="token punctuation">(</span><span class="token number">7.8%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// true</span><span class="token function">isnumber</span><span class="token punctuation">(</span>keyword<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// false</span><span class="token function">isnumber</span><span class="token punctuation">(</span><span class="token url">url(...)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>复制代码</code></pre><ul><li><p>iscolor</p><blockquote><p>判断给定的值 是否 是一个颜色。</p></blockquote></li><li><p>isurl</p><blockquote><p>判断给定的值 是否 是一个 url 。</p></blockquote></li></ul><ol><li><p><strong>颜色操作</strong></p><ul><li><p>saturate</p><blockquote><p>增加一定数值的颜色饱和度。</p></blockquote></li><li><p>lighten</p><blockquote><p>增加一定数值的颜色亮度。</p></blockquote></li><li><p>darken</p><blockquote><p>降低一定数值的颜色亮度。</p></blockquote></li><li><p>fade</p><blockquote><p>给颜色设定一定数值的透明度。</p></blockquote></li><li><p>mix</p><blockquote><p>根据比例混合两种颜色。</p></blockquote></li></ul></li><li><p><strong>数学函数</strong></p><ul><li><p>ceil</p><blockquote><p>向上取整。</p></blockquote></li><li><p>floor</p><blockquote><p>向下取整。</p></blockquote></li><li><p>percentage</p><blockquote><p>将浮点数转换为百分比字符串。</p></blockquote></li><li><p>round</p><blockquote><p>四舍五入。</p></blockquote></li><li><p>sqrt</p><blockquote><p>计算一个数的平方根。</p></blockquote></li><li><p>abs</p><blockquote><p>计算数字的绝对值，原样保持单位。</p></blockquote></li><li><p>pow</p><blockquote><p>计算一个数的乘方。</p></blockquote></li></ul></li></ol><p>由于 文章 篇幅有限，所以 只能介绍一些 使用效率高的函数。<br>如果你想了解更多，可以去官网的<a href="http://lesscss.cn/functions/" target="_blank" rel="noopener">函数链接</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li><strong>注释</strong><ul><li>/* */ CSS 原生注释，会被编译在 CSS 文件中。</li><li>/   / Less 提供的一种注释，不会被编译在 CSS 文件中。</li></ul></li><li><strong>避免编译</strong></li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token selector">#main</span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span>~<span class="token string">'calc(300px-30px)'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token selector">#main</span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span><span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">300</span>px<span class="token operator">-</span><span class="token number">30</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码</code></pre><ol><li>结构： <code>~&#39; 值 &#39;</code></li><li><strong>变量拼串</strong><br>在平时工作中，这种需求 太常见了。 在下面例子中， 实现了不同的 transtion-delay、animation、@keyframes</li></ol><pre class=" language-less"><code class="language-less"><span class="token selector">.judge(<span class="token variable">@i</span>) when(<span class="token variable">@i</span>=1)</span><span class="token punctuation">{</span>  <span class="token variable">@size<span class="token punctuation">:</span></span><span class="token number">15</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.judge(<span class="token variable">@i</span>) when(<span class="token variable">@i</span>>1)</span><span class="token punctuation">{</span>  <span class="token variable">@size<span class="token punctuation">:</span></span><span class="token number">16</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.loopAnimation(<span class="token variable">@i</span>) when (<span class="token variable">@i</span>&lt;16)</span> <span class="token punctuation">{</span>  <span class="token selector">.circle:nth-child(@{i})</span><span class="token punctuation">{</span>      <span class="token mixin-usage function">.judeg</span><span class="token punctuation">(</span><span class="token variable">@i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token property">border-radius</span><span class="token punctuation">:</span><span class="token variable">@size</span> <span class="token variable">@size</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token property">animation</span><span class="token punctuation">:</span> ~<span class="token string">"circle-@{i}"</span> <span class="token variable">@duration</span> infinite <span class="token variable">@ease</span><span class="token punctuation">;</span>      <span class="token property">transition-delay</span><span class="token punctuation">:</span>~<span class="token string">"@{i}ms"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token atrule">@keyframes ~"circle-@</span><span class="token punctuation">{</span>i<span class="token punctuation">}</span><span class="token selector">"</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// do something...</span>  <span class="token punctuation">}</span>  <span class="token number">.</span><span class="token function">loopAnimation</span><span class="token punctuation">(</span><span class="token variable">@i</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码</code></pre><ol><li>结构： <code>~&quot;字符@{变量}字符&quot;</code>;</li><li><strong>使用 JS</strong><br>因为 Less 是由 JS 编写，所以 Less 有一得天独厚的特性：代码中使用 Javascript 。</li></ol><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token variable">@content<span class="token punctuation">:</span></span>` <span class="token string">"aaa"</span><span class="token number">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>`<span class="token punctuation">;</span><span class="token selector">#randomColor</span> <span class="token punctuation">{</span>  <span class="token variable">@randomColor<span class="token punctuation">:</span></span> ~<span class="token string">"rgb(`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`)"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#wrap</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> ~<span class="token string">"`Math.round(Math.random() * 100)`px"</span><span class="token punctuation">;</span>  <span class="token selector">&amp;:after</span> <span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token variable">@content</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token property">height</span><span class="token punctuation">:</span> ~<span class="token string">"`window.innerHeight`px"</span><span class="token punctuation">;</span>  <span class="token property">alert</span><span class="token punctuation">:</span> ~<span class="token string">"`alert(1)`"</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">#randomColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token variable">@randomColor</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token comment" spellcheck="true">// 弹出 1</span><span class="token selector">#wrap</span> <span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> 随机值（<span class="token number">0</span>~<span class="token number">100</span>）px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">743</span>px<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//由电脑而异</span>  <span class="token property">background</span><span class="token punctuation">:</span> 随机颜色<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">#wrap::after</span> <span class="token punctuation">{</span>  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">"AAA"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="文章引用："><a href="#文章引用：" class="headerlink" title="文章引用："></a>文章引用：</h2><p><a href="https://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2012/06/sass.html</a><br><a href="https://juejin.im/post/6844903520441729037" target="_blank" rel="noopener">https://juejin.im/post/6844903520441729037</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> less </tag>
            
            <tag> sass </tag>
            
            <tag> scss </tag>
            
            <tag> stylus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试（3）vue</title>
      <link href="/leader755/26383.html"/>
      <url>/leader755/26383.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue:"></a>Vue:</h2><ul><li>vue 数据双向绑定原理；</li><li>vue computed 原理、watch 和 methods 的区别；</li><li>vue 编译器结构图、生命周期、vue 组件通信；</li><li>mvc 模式、mvp 模式、mvvm 模式；</li><li>vue dom diff、vuex、vue-router</li></ul><h2 id="数据双向绑定："><a href="#数据双向绑定：" class="headerlink" title="数据双向绑定："></a>数据双向绑定：</h2><pre><code>理解：**vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的.**原理：是观察者`observer`通过`Object.defineProperty()`来劫持到各个属性的`getter` `setter`，在数据变动的时候，会被`observer`观察到，会通过`Dep`通知数据的订阅者watcher，之后进行相应的视图上面的变化。</code></pre><p><a href="https://juejin.im/entry/6844903479044112391" target="_blank" rel="noopener">https://juejin.im/entry/6844903479044112391</a></p><h2 id="computed-原理、computed-和-watch-的区别"><a href="#computed-原理、computed-和-watch-的区别" class="headerlink" title="computed 原理、computed 和 watch 的区别"></a>computed 原理、computed 和 watch 的区别</h2><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><p>定义：是一个计算属性,类似于过滤器,对绑定到 view 的数据进行处理</p><blockquote><p>适用于重新计算比较费时不用重复数据计算的环境。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。如果一个数据依赖于其他数据，那么把这个数据设计为 computed。</p></blockquote><h5 id="computed-的常规使用"><a href="#computed-的常规使用" class="headerlink" title="computed 的常规使用"></a>computed 的常规使用</h5><pre class=" language-javascript"><code class="language-javascript">    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    firstName<span class="token punctuation">:</span> <span class="token string">'Foo'</span><span class="token punctuation">,</span>    lastName<span class="token punctuation">:</span> <span class="token string">'Bar'</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//默认使用方式，读取并返回当前的属性值（无法去修改读取到的值）</span>     fullNameone<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//使用get 和 set 方去修改获取到的属性值</span>      fullNameSed：<span class="token punctuation">{</span>           <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//回调函数 当需要读取当前属性值是执行，根据相关数据计算并返回当前属性的值</span>              <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName        <span class="token punctuation">}</span><span class="token punctuation">,</span>           <span class="token keyword">set</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//监视当前属性值的变化，当属性值发生变化时执行，更新相关的属性数据</span>           <span class="token comment" spellcheck="true">//val就是fullName的最新属性值</span>           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>           <span class="token keyword">const</span> names <span class="token operator">=</span> val<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span>           <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> names<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> names<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><h5 id="vue-中-computed-的传参：利用闭包："><a href="#vue-中-computed-的传参：利用闭包：" class="headerlink" title="vue 中 computed 的传参：利用闭包："></a>vue 中 computed 的传参：利用闭包：</h5><pre class=" language-javascript"><code class="language-javascript">computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>Ratedata<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>currentRate<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'%'</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>####</p><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>定义：watch 是一个观察的动作</p><h5 id="1-watch-监听数据变化"><a href="#1-watch-监听数据变化" class="headerlink" title="1.watch 监听数据变化"></a>1.watch 监听数据变化</h5><h6 id="1-gt-监听数据-单一数据"><a href="#1-gt-监听数据-单一数据" class="headerlink" title="1&gt;监听数据(单一数据)"></a>1&gt;监听数据(单一数据)</h6><pre class=" language-javascript"><code class="language-javascript"><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>       firstname<span class="token punctuation">:</span><span class="token string">''</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span>watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token function">firstname</span><span class="token punctuation">(</span>newVal<span class="token punctuation">,</span>oldVal<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>fullname <span class="token operator">=</span> newVal <span class="token operator">+</span> <span class="token string">'-'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastname      <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><h6 id="2-gt-监听对象的属性变化"><a href="#2-gt-监听对象的属性变化" class="headerlink" title="2&gt;监听对象的属性变化"></a>2&gt;监听对象的属性变化</h6><p><strong>1.直接通过 watch 的深度监听去监听对象的属性变化(deep 开启深度监听)</strong><br>**<code>deep</code>的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改<code>obj</code>里面任何一个属性都会触发这个监听器里的 handler。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    formData<span class="token punctuation">:</span> <span class="token punctuation">{</span>      channel<span class="token punctuation">:</span> <span class="token string">"音乐"</span><span class="token punctuation">,</span>      style<span class="token punctuation">:</span> <span class="token string">"活泼"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>    formData<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token function">handler</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//监听对象的所有属性(性能开销就会非常大)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newValue<span class="token punctuation">.</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回的当前对象</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      deep<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>优化，使用字符串形式监听,一层一层解析下去，直到遇到属性<code>a</code>，然后才给<code>a</code>设置监听函数</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    formData<span class="token punctuation">:</span> <span class="token punctuation">{</span>      channel<span class="token punctuation">:</span> <span class="token string">"音乐"</span><span class="token punctuation">,</span>      style<span class="token punctuation">:</span> <span class="token string">"活泼"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"formData.channel"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token function">handler</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回的为当前对象的属性channel的值</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h6 id="3-gt-初始化时就监听，由于初始化时-watch-不执行。"><a href="#3-gt-初始化时就监听，由于初始化时-watch-不执行。" class="headerlink" title="3&gt;初始化时就监听，由于初始化时 watch 不执行。"></a>3&gt;初始化时就监听，由于初始化时 watch 不执行。</h6><pre class=" language-javascript"><code class="language-javascript"> watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">'defaultVal'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>      immediate<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// immediate选项可以开启首次赋值监听</span>      handler <span class="token punctuation">(</span>newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newVal，oldVal<span class="token punctuation">)</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>selectVal <span class="token operator">=</span> newVal        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h5 id="2-利用-computed-的属性-将对象的属性提取出来进行监听"><a href="#2-利用-computed-的属性-将对象的属性提取出来进行监听" class="headerlink" title="2.利用 computed 的属性(将对象的属性提取出来进行监听)"></a>2.利用 computed 的属性(将对象的属性提取出来进行监听)</h5><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    formData<span class="token punctuation">:</span> <span class="token punctuation">{</span>      channel<span class="token punctuation">:</span> <span class="token string">"音乐"</span><span class="token punctuation">,</span>      style<span class="token punctuation">:</span> <span class="token string">"活泼"</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>formData<span class="token punctuation">.</span>channel<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">channel</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newval<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="2-watch-监听路由变化"><a href="#2-watch-监听路由变化" class="headerlink" title="2.watch 监听路由变化"></a>2.watch 监听路由变化</h5><pre class=" language-javascript"><code class="language-javascript">watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token function">$route</span><span class="token punctuation">(</span> to <span class="token punctuation">,</span> <span class="token keyword">from</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// to要跳转到的路由的地址 , from 表示从哪跳转</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> to <span class="token punctuation">,</span> <span class="token keyword">from</span> <span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h4><blockquote><ul><li>可以使用 methods 来代替 computed，实际上效果是一样；</li><li>其中 methods【有括号（）】，computed 不带括号；</li><li>computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值；</li><li>methods 在重新渲染的时候，函数总会重新调用执行；</li><li>使用 computed 会比 methods 方法性能更好。</li></ul></blockquote><blockquote></blockquote><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote><p>1.如果一个数据依赖于其他数据，那么把这个数据设计为 computed 的 。 2.如果你需要在某个数据变化时做一些事情，使用 watch 来观察这个数据变化 3.如果需要实时调用，使用 methods 比 computed 更合适</p></blockquote><h4 id="computed-和-watch-的区别："><a href="#computed-和-watch-的区别：" class="headerlink" title="computed 和 watch 的区别："></a>computed 和 watch 的区别：</h4><blockquote><p>1.computed 是计算属性，watch 是监听，即观察属性。<br>2.comPuted 具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数。watch 每次都会去执行函数。<br>3.computed 是需要返回值的，且一般是对源数据进行过滤，为同步。watch 可监听异步请求返回的值。</p></blockquote><p>相关文章：<a href="https://www.yuque.com/docs/share/e153d391-2487-4dc7-a442-6a1ef00e6f20?#" target="_blank" rel="noopener">https://www.yuque.com/docs/share/e153d391-2487-4dc7-a442-6a1ef00e6f20?#</a> 《vue 的 data,props,computed,watch 详解》</p><h2 id="vue-编译器结构图、生命周期"><a href="#vue-编译器结构图、生命周期" class="headerlink" title="vue 编译器结构图、生命周期"></a>vue 编译器结构图、生命周期</h2><h3 id="生命周期详解："><a href="#生命周期详解：" class="headerlink" title="生命周期详解："></a>生命周期详解：</h3><ul><li><strong>beforeCreate（初始化界面前）</strong>组件未创建（加载动画）</li><li><strong>created（初始化界面后）</strong>组件被创建了（获取数据）</li><li><strong>beforeMount（渲染 dom 前）</strong>组件挂载前</li><li><strong>mounted（渲染 dom 后）</strong>组件挂载（页面显示完成）</li><li><strong>beforeUpdate（更新数据前）</strong>组件更新前调用的函数</li><li><strong>updated（更新数据后）</strong>组件更新完毕</li><li><strong>beforeDestroy（卸载组件前）</strong>组件销毁之前</li><li><strong>destroyed（卸载组件后）</strong>组件销毁之后</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1597640375098-b2844b7d-609b-4e9d-a953-9d91bc6bd4a4.png#align=left&display=inline&height=1350&margin=%5Bobject%20Object%5D&name=image.png&originHeight=3039&originWidth=1200&size=204653&status=done&style=none&width=533" alt="image.png"></p><p>异步请求数据时应该位于生命周期：<br>一般在  <code>created</code>  里面就可以，如果涉及到需要页面加载完成之后的话就用  <code>mounted</code>。</p><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p>定义：$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM.<br>使用场景：在 Vue 生命周期的<code>created()</code>钩子函数进行的 DOM 操作一定要放在<code>Vue.nextTick()</code>的回调函数中  。</p><h2 id="vue-组件通信"><a href="#vue-组件通信" class="headerlink" title="vue 组件通信"></a>vue 组件通信</h2><h3 id="父传子："><a href="#父传子：" class="headerlink" title="父传子："></a>父传子：</h3><h3 id="子传父："><a href="#子传父：" class="headerlink" title="子传父："></a>子传父：</h3><h2 id="同步异步父子组件生命周期顺序"><a href="#同步异步父子组件生命周期顺序" class="headerlink" title="同步异步父子组件生命周期顺序"></a>同步异步父子组件生命周期顺序</h2><blockquote><p>在单一组件中，钩子的执行顺序是 beforeCreate-&gt; created -&gt; mounted-&gt;… -&gt;destroyed，但当父子组件嵌套时，父组件和子组件各拥有各自独立的钩子函数，<strong>这些父子组件的这些钩子是如何交融执行，且执行顺序又是怎样的呢?</strong></p></blockquote><h3 id="同步父子组件："><a href="#同步父子组件：" class="headerlink" title="同步父子组件："></a>同步父子组件：</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//同步组件引入方式</span><span class="token keyword">import</span> Page <span class="token keyword">from</span> <span class="token string">"@/components/page"</span><span class="token punctuation">;</span></code></pre><h4 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h4><pre class=" language-javascript"><code class="language-javascript">父beforeCreate<span class="token operator">-</span><span class="token operator">></span>父created<span class="token operator">-</span><span class="token operator">></span>父beforeMount<span class="token operator">-</span><span class="token operator">></span>子beforeCreate<span class="token operator">-</span><span class="token operator">></span>子created<span class="token operator">-</span><span class="token operator">></span>子beforeMount<span class="token operator">-</span><span class="token operator">></span>子mounted<span class="token operator">-</span><span class="token operator">></span>父mounted</code></pre><p>####</p><h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><pre class=" language-javascript"><code class="language-javascript">父beforeUpdate<span class="token operator">-</span><span class="token operator">></span>子beforeUpdate<span class="token operator">-</span><span class="token operator">></span>子updated<span class="token operator">-</span><span class="token operator">></span>父updated</code></pre><p>####</p><h4 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h4><pre class=" language-javascript"><code class="language-javascript">父beforeDestroy<span class="token operator">-</span><span class="token operator">></span>子beforeDestroy<span class="token operator">-</span><span class="token operator">></span>子destroyed<span class="token operator">-</span><span class="token operator">></span>父destroyed</code></pre><p>####</p><h4 id="常用钩子简易版"><a href="#常用钩子简易版" class="headerlink" title="常用钩子简易版"></a>常用钩子简易版</h4><pre class=" language-javascript"><code class="language-javascript">父create<span class="token operator">-</span><span class="token operator">></span>子created<span class="token operator">-</span><span class="token operator">></span>子mounted<span class="token operator">-</span><span class="token operator">></span>父mounted</code></pre><blockquote><p><strong>总结：</strong> &gt; <strong>同步父子组件渲染，更新，销毁的生命周期都是在当前父组件的生命周期中执行 **</strong>父 beforeMount， 父 beforeUpdate，beforeDestory 后，中间插入子组件的生命周期，最后才使用 父 Mounted，父 updated，父 destroyed。**</p></blockquote><p>**</p><h3 id="异步父子组件："><a href="#异步父子组件：" class="headerlink" title="异步父子组件："></a>异步父子组件：</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//异步组件引入</span><span class="token keyword">const</span> Page <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"@/components/page"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> Page <span class="token operator">=</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"@/components/page"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="加载渲染过程-1"><a href="#加载渲染过程-1" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h4><pre class=" language-javascript"><code class="language-javascript">父beforeCreate<span class="token operator">-</span><span class="token operator">></span>父created<span class="token operator">-</span><span class="token operator">></span>父beforeMount<span class="token operator">-</span><span class="token operator">></span>父mounted<span class="token operator">-</span><span class="token operator">></span>父beforeUpdate<span class="token operator">-</span><span class="token operator">></span>子beforeCreate<span class="token operator">-</span><span class="token operator">></span>子created<span class="token operator">-</span><span class="token operator">></span>子beforeMount<span class="token operator">-</span><span class="token operator">></span>子mounted<span class="token operator">-</span><span class="token operator">></span>父updated</code></pre><p>####</p><h4 id="更新过程（异步和同步相同）"><a href="#更新过程（异步和同步相同）" class="headerlink" title="更新过程（异步和同步相同）"></a>更新过程（异步和同步相同）</h4><pre class=" language-javascript"><code class="language-javascript">父beforeUpdate<span class="token operator">-</span><span class="token operator">></span>子beforeUpdate<span class="token operator">-</span><span class="token operator">></span>子updated<span class="token operator">-</span><span class="token operator">></span>父updated</code></pre><p>####</p><h4 id="销毁过程（异步和同步相同）"><a href="#销毁过程（异步和同步相同）" class="headerlink" title="销毁过程（异步和同步相同）"></a>销毁过程（异步和同步相同）</h4><pre class=" language-javascript"><code class="language-javascript">父beforeDestroy<span class="token operator">-</span><span class="token operator">></span>子beforeDestroy<span class="token operator">-</span><span class="token operator">></span>子destroyed<span class="token operator">-</span><span class="token operator">></span>父destroyed</code></pre><blockquote><p><strong>总结：</strong><br>异步父子组件的渲染，更新，销毁，更新和销毁的生命周期和同步组件相同，但是渲染与同步的不同，<br>父组件的<code>beforeCreate、created、beforeMount、mounted、``beforeUpdate (其中多了一步 update)</code> –&gt;所有子组件的<code>mounted</code> —-&gt; 父组件的<code>Updated</code></p></blockquote><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><blockquote></blockquote><h5 id="两种引入方式的不同之处在于："><a href="#两种引入方式的不同之处在于：" class="headerlink" title="两种引入方式的不同之处在于："></a>两种引入方式的不同之处在于：</h5><blockquote><p>同步引入时生命周期顺序为：父组件的<code>beforeCreate、created、beforeMount</code> –&gt; 所有子组件的<code>beforeCreate、created、beforeMount</code> –&gt; 所有子组件的<code>mounted</code> –&gt; 父组件的<code>mounted</code></p></blockquote><blockquote><p>异步引入时生命周期顺序：父组件的<code>beforeCreate、created、beforeMount、mounted</code> –&gt; 子组件的<code>beforeCreate、created、beforeMount、mounted</code></p></blockquote><p>**<br>**</p><h2 id="mvc、mvp、mvvm"><a href="#mvc、mvp、mvvm" class="headerlink" title="mvc、mvp、mvvm"></a>mvc、mvp、mvvm</h2><blockquote><p>MVC，MVP 和 MVVM 都是常见的软件架构设计模式（Architectural Pattern），它通过分离关注点来改进代码的组织方式。不同于设计模式（Design Pattern），只是为了解决一类问题而总结出的抽象方法，一种架构模式往往使用了多种设计模式。</p></blockquote><blockquote><p>要了解 MVC、MVP 和 MVVM，就要知道它们的相同点和不同点。不同部分是 C(Controller)、P(Presenter)、VM(View-Model)，而相同的部分则是 MV(Model-View)。</p></blockquote><p>Model（数据层）：Model 层用于封装和应用程序的业务逻辑相关的数据以及对数据的处理方法。<br>View（视图层）：主要负责数据的展示</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC 模式的意思是，软件可以分成三个部分。</p><ul><li>视图（View）：用户界面。</li><li>控制器（Controller）：业务逻辑</li><li>模型（Model）：数据保存</li></ul><p>各部分之间的通信方式如下<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1597731631277-85e1a79d-6f5b-414c-affa-d6b574dfbcf3.png#align=left&display=inline&height=365&margin=%5Bobject%20Object%5D&originHeight=365&originWidth=601&size=0&status=done&style=none&width=601" alt=""></p><blockquote><ol><li>MVC 是单向通信。也就是 View 跟 Model，必须通过 Controller 来承上启下。</li><li>实例化 View 并向对应的 Model 实例注册，当 Model 发生变化时就去通知 View 做更新，这里用到了观察者模式。</li><li>Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。</li></ol></blockquote><ul><li>接受用户指令时，MVC 可以分成两种方式：<ul><li>通过 View 接受指令，传递给 Controller。</li><li>直接通过 controller 接受指令。</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1597731692262-e83df13a-deea-40e2-aa2e-d5eb523c5752.png#align=left&display=inline&height=255&margin=%5Bobject%20Object%5D&name=image.png&originHeight=510&originWidth=583&size=28897&status=done&style=none&width=291.5" alt="image.png">)<img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1597731701799-cc0f8053-b059-49f4-83a3-099a510e7647.png#align=left&display=inline&height=255&margin=%5Bobject%20Object%5D&name=image.png&originHeight=486&originWidth=562&size=26205&status=done&style=none&width=295" alt="image.png"></p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>定义：Model-View-Presenter，<br>MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1597731802955-171db3ab-b2af-46bd-b2c8-9bfa4356c12c.png#align=left&display=inline&height=323&margin=%5Bobject%20Object%5D&originHeight=323&originWidth=537&size=0&status=done&style=none&width=537" alt=""></p><ol><li>各部分之间的通信，都是双向的。</li><li>View 与 Model 不发生联系，都通过 Presenter 传递。</li><li><strong>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter 非常厚，所有逻辑都部署在 Presenter。</strong></li></ol><h3 id="MVVM："><a href="#MVVM：" class="headerlink" title="MVVM："></a>MVVM：</h3><p><strong>定义：指的是 Model - View -ViewModel 的简写，即模型-视图-视图模型</strong><br>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。唯一的区别是，它采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1597731867672-4e25f08d-d2c8-419a-a9bc-5d532b609374.png#align=left&display=inline&height=380&margin=%5Bobject%20Object%5D&originHeight=423&originWidth=556&size=0&status=done&style=none&width=499" alt=""></p><p>优点：<br>1、&gt; <strong>提高可维护性</strong>。解决了 MVP 大量的手动 View 和 Model 同步的问题，提供双向绑定机制。2、&gt; <strong>简化测试。</strong>因为同步逻辑是交由 Binder 做的，View 跟着 Model 同时变更，所以只需要保证 Model 的正确性，View 就正确。大大减少了对 View 同步更新的测试。<br>缺点：<br>1、过于简单的图形界面不适用，或说牛刀杀鸡。2、对于大型的图形应用程序，视图状态较多，ViewModel 的构建和维护的成本都会比较高。3、数据绑定的声明是指令式地写在 View 的模版当中的，这些内容是没办法去打断点 debug 的。</p><h3 id="MVVM-模式及与-MVP-和-MVC-的区别"><a href="#MVVM-模式及与-MVP-和-MVC-的区别" class="headerlink" title="MVVM 模式及与 MVP 和 MVC 的区别"></a>MVVM 模式及与 MVP 和 MVC 的区别</h3><h4 id="MVC-和-MVP-的关系"><a href="#MVC-和-MVP-的关系" class="headerlink" title="MVC 和 MVP 的关系"></a>MVC 和 MVP 的关系</h4><ul><li>相同点：MVP 是从经典的模式 MVC 演变而来，它们的基本思想有相通的地方：Controller/Presenter 负责逻辑的处理，Model 提供数 据，View 负责显示。</li><li>不同点：在 MVP 中 View 并不直接使用 Model，它们之间的通信是通过 Presenter (MVC 中的 Controller)来进行的，所有的交互都发生在 Presenter 内部，而在 MVC 中 View 会直接从 Model 中读取数据而不是通过 Controller。MVC 全部是单项通信，而 MVP 是双向通信。</li></ul><h4 id="MVVM-和-MVP-的关系"><a href="#MVVM-和-MVP-的关系" class="headerlink" title="MVVM 和 MVP 的关系"></a>MVVM 和 MVP 的关系</h4><ul><li>相同点：MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，</li><li>不同点：MVVM 采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。这样     开发者就不用处理接收事件和 View 更新的工作。MVVM 把 View 和 Model 的同步逻辑自动化了。以前 Presenter 负责的 View 和 Model 同步不再手动地进行操作，而是交给框架所提供的数据绑定功能进行负责，只需要告诉它 View 显示的数据对应的是 Model 哪一部分即可。简化了业务与界面的依赖，还解决了数据频繁更新的问题（以前用 jQuery 操作 DOM 很繁琐）。</li></ul><h2 id="vue-数据双向绑定原理"><a href="#vue-数据双向绑定原理" class="headerlink" title="vue 数据双向绑定原理"></a>vue 数据双向绑定原理</h2><p>在 Vue 中，使用了双向绑定技术（Two-Way-Data-Binding），就是 View 的变化能实时让 Model 发生变化，而 Model 的变化也能实时更新到 View。</p><p>不同的 MVVM 框架中，实现双向数据绑定的技术有所不同。目前一些主流的前端框架实现数据绑定的方式大致有以下几种：</p><ul><li>数据劫持 (Vue)</li><li>发布-订阅模式 (Knockout、Backbone)</li><li>脏值检查 (Angular)</li></ul><p>我们这里主要讲讲<strong>Vue 的双向绑定</strong>：<br>Vue 采用数据劫持&amp;发布-订阅模式的方式，通过 ES5 提供的 <code>Object.defineProperty()</code> 方法来劫持（监控）各属性的 <code>getter</code> 、<code>setter</code> ，并在数据（对象）发生变动时通知订阅者，触发相应的监听回调。并且，由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的视图，而不是对所有的数据都执行一次检测。 要实现 Vue 中的双向数据绑定，大致可以划分三个模块：Observer、Compile、Watcher，如图：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597731278950-a02bf7fb-5b5c-4274-ae59-1f9e74e8829b.webp#align=left&display=inline&height=396&margin=%5Bobject%20Object%5D&originHeight=396&originWidth=1280&size=0&status=done&style=none&width=1280" alt=""></p><ul><li>Observer 数据监听器<br>负责对数据对象的所有属性进行监听（数据劫持），监听到数据发生变化后通知订阅者。</li><li>Compiler 指令解析器<br>扫描模板，并对指令进行解析，然后绑定指定事件。</li><li>Watcher 订阅者<br>关联 Observer 和 Compile，能够订阅并收到属性变动的通知，执行指令绑定的相应操作，更新视图。Update()是它自身的一个方法，用于执行 Compile 中绑定的回调，更新视图。</li></ul><h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><p>一般对数据的劫持都是通过 Object.defineProperty 方法进行的，Vue 中对应的函数为  <code>defineReactive</code> ，其普通对象的劫持的精简版代码如下：<br>从 MVC –&gt; MVP –&gt; MVVM</p><h3 id="vue-的单项数据流："><a href="#vue-的单项数据流：" class="headerlink" title="vue 的单项数据流："></a>vue 的单项数据流：</h3><p>• Vue 是单向数据流，不是双向绑定<br>• Vue 的双向绑定不过是语法糖<br>• Object.definePropert 是劫持属性的 get 和 set 用来做响应式更新的。</p><p>vue 还是单向数据流，v-model 只不过是语法糖，它是:value=”sth”和@change=”val =&gt; sth = val”的简写形式。</p><h3 id="Vue-是怎么实现数据响应式更新的："><a href="#Vue-是怎么实现数据响应式更新的：" class="headerlink" title="Vue 是怎么实现数据响应式更新的："></a>Vue 是怎么实现数据响应式更新的：</h3><p>面试官期望听到的回答是：<strong>通过 Object.defineProperty()的 get 和 set 方法来实现响应式更新。</strong></p><h2 id="Vue-的虚拟-Dom"><a href="#Vue-的虚拟-Dom" class="headerlink" title="Vue 的虚拟 Dom"></a>Vue 的虚拟 Dom</h2><p>浏览器解析一个 html 大致分为五步：<br><strong>创建 DOM tree –&gt; 创建 Style Rules -&gt; 构建 Render tree -&gt; 布局 Layout –&gt; 绘制 Painting。</strong><br><em>*<br>每次对真实 dom 进行操作的时候，浏览器都会从构建 dom 树开始从头到尾执行一遍流程。真实的 dom 操作代价昂贵，操作频繁还会引起页面卡顿影响用户体验，*<em>虚拟 dom 就是为了解决这个浏览器性能问题才被创造出来\</em>\</em><br>虚拟 dom 在执行 dom 的更新操作后，虚拟 dom 不会直接操作真实 dom，而是将更新的 diff 内容保存到本地 js 对象中，然后一次性 attach 到 dom 树上，通知浏览器进行 dom 绘制避免大量无谓的计算。</p><p>简单总结：虚拟 DOM 是将真实的 DOM 节点用 JavaScript 模拟出来，将 DOM 变化的对比，放到 Js 层来做。</p><h3 id="你的知道浏览器的虚拟-DOM-与真实-DOM-的区别"><a href="#你的知道浏览器的虚拟-DOM-与真实-DOM-的区别" class="headerlink" title="你的知道浏览器的虚拟 DOM 与真实 DOM 的区别"></a>你的知道浏览器的虚拟 DOM 与真实 DOM 的区别</h3><p>（<strong>注意：需不需要虚拟 DOM，其实与框架的 DOM 操作机制有关</strong>）：</p><ol><li>虚拟 DOM 不会进行排版与重绘操作</li><li>虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分（注意！），最后并在真实 DOM 中进行排版与重绘，减少过多 DOM 节点排版与重绘损耗</li><li>真实 DOM 频繁排版与重绘的效率是相当低的</li><li>虚拟 DOM 有效降低大面积（真实 DOM 节点）的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部（同 2）</li></ol><p>使用虚拟 DOM 的损耗计算：</p><pre class=" language-javascript"><code class="language-javascript">总损耗 <span class="token operator">=</span> 虚拟DOM增删改 <span class="token operator">+</span> （与Diff算法效率有关）真实DOM差异增删改 <span class="token operator">+</span> （较少的节点）排版与重绘</code></pre><p>直接使用真实 DOM 的损耗计算：</p><pre class=" language-javascript"><code class="language-javascript">总损耗 <span class="token operator">=</span> 真实DOM完全增删改 <span class="token operator">+</span> （可能较多的节点）排版与重绘</code></pre><p>**<br><strong>总之，一切为了减弱频繁的大面积重绘引发的性能问题，不同框架不一定需要虚拟 DOM，关键看框架是否频繁会引发大面积的 DOM 操作</strong></p><h3 id="vue-的-diff-是算法"><a href="#vue-的-diff-是算法" class="headerlink" title="vue 的 diff 是算法"></a>vue 的 diff 是算法</h3><p>在采取 diff 算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。Vue 的 diff 算法是<strong>仅在同级的 vnode 间做 diff，递归地进行同级 vnode 的 diff，最终实现整个 DOM 树的更新</strong>。因为跨层级的操作是非常少的，忽略不计，这样时间复杂度就从 O(n3)变成 O(n)。</p><h2 id="JavaScript：回流（重排）与重绘"><a href="#JavaScript：回流（重排）与重绘" class="headerlink" title="JavaScript：回流（重排）与重绘"></a><a href="https://segmentfault.com/a/1190000018452924" target="_blank" rel="noopener">JavaScript：回流（重排）与重绘</a></h2><h3 id="回流（元素的布局位置，规模尺寸，隐藏等改变）"><a href="#回流（元素的布局位置，规模尺寸，隐藏等改变）" class="headerlink" title="回流（元素的布局位置，规模尺寸，隐藏等改变）"></a>回流（元素的布局位置，规模尺寸，隐藏等改变）</h3><p>回流当 render tree 中的一部分或全部因为元素的规模尺寸、布局、隐藏等改变时，浏览器重新渲染部分 DOM 或全部 DOM 的过程。回流也被称为重排，其实从字面上来看，重排更容易让人形象易懂（即重新排版整个页面）。</p><h3 id="重绘（不改变元素的位置，只改变元素的样式）"><a href="#重绘（不改变元素的位置，只改变元素的样式）" class="headerlink" title="重绘（不改变元素的位置，只改变元素的样式）"></a>重绘（不改变元素的位置，只改变元素的样式）</h3><p><strong>当页面元素样式改变不影响元素在文档流中的位置时</strong>（如 background-color，border-color，visibility），浏览器只会将新样式赋予元素并进行重新绘制操作。</p><p><strong>回流必将引起重绘，而重绘不一定会引起回流。</strong></p><h3 id="如何减少回流、重绘"><a href="#如何减少回流、重绘" class="headerlink" title="如何减少回流、重绘"></a>如何减少回流、重绘</h3><h4 id="CSS-中避免回流、重绘"><a href="#CSS-中避免回流、重绘" class="headerlink" title="CSS 中避免回流、重绘"></a>CSS 中避免回流、重绘</h4><p>1.尽可能在 DOM 树的最末端改变 class 2.避免设置多层内联样式 3.动画效果应用到 position 属性为 absolute 或 fixed 的元素上 4.避免使用 table 布局 5.使用 css3 硬件加速，可以让 transform、opacity、filters 等动画效果不会引起回流重绘</p><h4 id="JS-操作避免回流、重绘"><a href="#JS-操作避免回流、重绘" class="headerlink" title="JS 操作避免回流、重绘"></a>JS 操作避免回流、重绘</h4><p><strong>1.避免使用 JS 一个样式修改完接着改下一个样式，最好一次性更改 CSS 样式，或者将样式列表定义为 class 的名称</strong> 2.避免频繁操作 DOM，使用文档片段创建一个子树，然后再拷贝到文档中 3.先隐藏元素，进行修改后再显示该元素，因为 display:none 上的 DOM 操作不会引发回流和重绘 4.避免循环读取 offsetLeft 等属性，在循环之前把它们存起来 5.对于复杂动画效果,使用绝对定位让其脱离文档流，否则会引起父元素及后续元素大量的回流</p><h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><p><strong>回流在浏览器中属于一种用户主导的操作，所以知道如何去改进回流时间以及知道各种文档属性（DOM 节点深度，css 的渲染效率，各种各样的样式改变）对回流时间的影响对于前端开发来讲是很有帮助的。有时即便是回流一个单一的元素，也可能要求它的父元素以及任何跟随它的元素也产生回流。例如需要改变某个元素的背景，这就不涉及该元素的属性，所以只发生重绘。</strong></p><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h3 id="定义：vue-js-应用程序开发的状态管理模式"><a href="#定义：vue-js-应用程序开发的状态管理模式" class="headerlink" title="定义：vue.js 应用程序开发的状态管理模式"></a>定义：vue.js 应用程序开发的状态管理模式</h3><h3 id="vuex-五大核心属性：state，getter，mutation，action，module"><a href="#vuex-五大核心属性：state，getter，mutation，action，module" class="headerlink" title="vuex 五大核心属性：state，getter，mutation，action，module"></a>vuex 五大核心属性：state，getter，mutation，action，module</h3><ul><li>state：存储数据，存储状态；在根实例中注册了 store 后，用 this.$store.state  访问数据。</li><li>getters: store 的计算属性，它的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算，多用于过滤 state 的数据，用 this.$store.getter 访问数据。</li><li>mutation：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。用 this.$store.commit(‘add’, { amount: 10 })来提交数据。</li><li>action：包含任意异步操作，通过提交 mutation 方法，通过 mutation 来改变 state。通过 this.$store.dispatch(‘addCountAction’)发起异步。</li><li>module：将 store 分割成模块，每个模块都具有 state、mutation、action、getter、甚至是嵌套子模块。</li></ul><pre class=" language-javascript"><code class="language-javascript">└── store    ├── index<span class="token punctuation">.</span>js          # 我们组装模块并导出 store 的地方    ├── actions<span class="token punctuation">.</span>js        # 根级别的 action    ├── mutations<span class="token punctuation">.</span>js      # 根级别的 mutation    ├── state<span class="token punctuation">.</span>js          # 根级别的 state    └── modules        ├── module1<span class="token punctuation">.</span>js   # 模块<span class="token number">1</span>的state树        └── module2<span class="token punctuation">.</span>js   # 模块<span class="token number">2</span>的state树</code></pre><p>module1.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> WIDTH_ADD <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"@/store/mutation-types.js"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引入事件类型</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  namespaced<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>    width<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>    height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  getters<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">modulegGetWidth</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> getters<span class="token punctuation">,</span> rootState<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> state<span class="token punctuation">.</span>width<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">modulegetHeight</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> getters<span class="token punctuation">,</span> rootState<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> state<span class="token punctuation">.</span>height<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token punctuation">[</span>WIDTH_ADD<span class="token punctuation">]</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 使用常量替代 Mutation 事件类型</span>      <span class="token keyword">return</span> state<span class="token punctuation">.</span>width<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">addHeight</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 不使用常量</span>      <span class="token keyword">return</span> state<span class="token punctuation">.</span>height<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>index.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> state <span class="token keyword">from</span> <span class="token string">"./state"</span><span class="token punctuation">;</span><span class="token keyword">import</span> getters <span class="token keyword">from</span> <span class="token string">"./getters"</span><span class="token punctuation">;</span><span class="token keyword">import</span> mutations <span class="token keyword">from</span> <span class="token string">"./mutations"</span><span class="token punctuation">;</span><span class="token keyword">import</span> actions <span class="token keyword">from</span> <span class="token string">"./actions"</span><span class="token punctuation">;</span><span class="token keyword">import</span> module1 <span class="token keyword">from</span> <span class="token string">"./modules/module1.js"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引入module1</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  state<span class="token punctuation">,</span>  getters<span class="token punctuation">,</span>  mutations<span class="token punctuation">,</span>  actions<span class="token punctuation">,</span>  modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>    module1<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 注册完成</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p><strong>定义：简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源（</strong>请求不同的页面是路由的其中一种功能<strong>）</strong>。</p><p>异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。</p><h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><h4 id="1-hash-模式"><a href="#1-hash-模式" class="headerlink" title="1. hash 模式"></a>1. hash 模式</h4><p>改变 url 的情况下，保证页面的不刷新。后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发<code>hashchange</code>  这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听<code>hashchange</code>来实现更新页面部分内容的操作：<br><strong>hash 模式背后的原理是<code>onhashchange</code>事件,可以在<code>window</code>对象上监听这个事件。</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//www.xxx.com/#/login</span>http<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">matchAndUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// todo 匹配 hash 做 dom 更新操作</span><span class="token punctuation">}</span>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"hashchange"</span><span class="token punctuation">,</span> matchAndUpdate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//onhashChange</span>window<span class="token punctuation">.</span>onhashchange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>oldURL<span class="token punctuation">,</span> event<span class="token punctuation">.</span>newURL<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> hash <span class="token operator">=</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> hash<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="2-history-模式"><a href="#2-history-模式" class="headerlink" title="2. history 模式"></a>2. history 模式</h4><p>因为 HTML5 标准发布，多了两个 API，<code>pushState()</code>  和  <code>replaceState()。</code>通过这两个 API （1）可以改变 url 地址且不会发送请求，（2）不仅可以读取历史记录栈，还可以对<strong>浏览器历史记录栈进行修改。</strong><br>同时还有<code>popstate</code>  事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">matchAndUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// todo 匹配路径 做 dom 更新操作</span><span class="token punctuation">}</span>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"popstate"</span><span class="token punctuation">,</span> matchAndUpdate<span class="token punctuation">)</span><span class="token punctuation">;</span>window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span>stateObject<span class="token punctuation">,</span> title<span class="token punctuation">,</span> URL<span class="token punctuation">)</span><span class="token punctuation">;</span>window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span>stateObject<span class="token punctuation">,</span> title<span class="token punctuation">,</span> URL<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>用了 HTML5 的实现，单页路由的 url 就不会多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。</p></blockquote><blockquote><p>区别：</p><ul><li>前面的 hashchange，你只能改变#后面的 url 片段。而 pushState 设置的新 URL 可以是与当前 URL 同源的任意 URL。</li><li>history 模式则会将 URL 修改得就和正常请求后端的 URL 一样,如后端没有配置对应/user/id 的路由处理，则会返回 404 错误</li></ul><p>当用户刷新页面之类的操作时，浏览器会给服务器发送请求，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。</p></blockquote><h2 id="vue-路由传参方式"><a href="#vue-路由传参方式" class="headerlink" title="vue 路由传参方式"></a>vue 路由传参方式</h2><h3 id="1-params-传参（刷新参数会丢失）："><a href="#1-params-传参（刷新参数会丢失）：" class="headerlink" title="1.params 传参（刷新参数会丢失）："></a>1.params 传参<strong>（刷新参数会丢失）</strong>：</h3><p><strong>name 与 params 结合使用   相当于 post。</strong><br>传参方式：this.$router.push({name:’路由命名’,params:{参数名:参数值,参数名:参数<strong>值}})</strong><br>url 展现方式：/detail</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//父组件传参</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"Describe"</span><span class="token punctuation">,</span>  params<span class="token punctuation">:</span> <span class="token punctuation">{</span>    id<span class="token punctuation">:</span> id<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//子组件接收</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id<span class="token punctuation">;</span></code></pre><h3 id="2-query-传参：（刷新不会丢失参数）"><a href="#2-query-传参：（刷新不会丢失参数）" class="headerlink" title="2.query 传参：（刷新不会丢失参数）"></a>2.query 传参：<strong>（刷新不会丢失参数）</strong></h3><p><strong>path 与 query 结合使用，相当于 get，参数会显示在地址栏里</strong><br><strong>传参方式：this.$router.push({path:’路由命名’, query:{ 参数名:参数值 } })</strong><br>url 展现方式：/detail?id=1&amp;user=123&amp;identity=1</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//父组件传值</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  path<span class="token punctuation">:</span> <span class="token string">"/describe"</span><span class="token punctuation">,</span>  query<span class="token punctuation">:</span> <span class="token punctuation">{</span>    id<span class="token punctuation">:</span> id<span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//子组件</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>id<span class="token punctuation">;</span></code></pre><h3 id="3-params-动态路由传参-刷新不会丢失参数）："><a href="#3-params-动态路由传参-刷新不会丢失参数）：" class="headerlink" title="3.params+动态路由传参(刷新不会丢失参数）："></a>3.params+动态路由传参(<strong>刷新不会丢失参数）</strong>：</h3><p><strong>参数会显示在地址栏</strong><br>**this.$router.push({path:’路由命名’, params:{ 参数名:参数值 } })url 展现方式：/detail/3/1</p><p>父组件：</p><pre class=" language-javascript"><code class="language-javascript">    <span class="token comment" spellcheck="true">//父组件</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          path<span class="token punctuation">:</span> <span class="token string">'/describe'</span><span class="token punctuation">,</span>          params<span class="token punctuation">:</span> <span class="token punctuation">{</span>            id<span class="token punctuation">:</span> id          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//路由写法</span>            <span class="token punctuation">{</span>                  path<span class="token punctuation">:</span> <span class="token string">'/describe/:id'</span><span class="token punctuation">,</span>                  name<span class="token punctuation">:</span> <span class="token string">'Describe'</span><span class="token punctuation">,</span>                  component<span class="token punctuation">:</span> Describe            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//子组件</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id</code></pre><h3 id="4-router-link-传参"><a href="#4-router-link-传参" class="headerlink" title="4.router-link 传参"></a>4.router-link 传参</h3><p>1.路径：<a href="http://localhost:8081/#/test?name=1" target="_blank" rel="noopener">http://localhost:8081/#/test?name=1</a>(jquery 和 params 的结合)</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//(id是参数)</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token punctuation">:</span>to<span class="token operator">=</span><span class="token string">"{path:'/test',query: {name: id}, params:{id:id}}"</span><span class="token operator">></span>跳转<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">></span><span class="token comment" spellcheck="true">//使用</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>id<span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id</code></pre><p>2.路径：<a href="http://localhost:8081/#/test/1（相当一动态路由传参）" target="_blank" rel="noopener">http://localhost:8081/#/test/1（相当一动态路由传参）</a></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//(id是参数)</span><span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token punctuation">:</span>to<span class="token operator">=</span><span class="token string">"'/test/'+id"</span><span class="token operator">></span>跳转<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">></span><span class="token comment" spellcheck="true">//路由</span><span class="token punctuation">{</span>    path<span class="token punctuation">:</span><span class="token string">'/test/:id/'</span><span class="token punctuation">,</span>    name<span class="token punctuation">:</span><span class="token string">'Test'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./components/Test.vue'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id   <span class="token comment" spellcheck="true">// (这个id给上图路由的配置有关）</span></code></pre><p><strong>注意：router-link 中链接如果是‘/’开始就是从根路由开始，如果开始不带‘/’，则从当前路由开始</strong></p><h3 id="5-vuex-传参"><a href="#5-vuex-传参" class="headerlink" title="5.vuex 传参"></a>5.vuex 传参</h3><p>页面刷新 store.state 中的数据消失是不可避免的，那么使用 localStorage 或者 sessionStorage 来避免这个问题。如果是一个一个数据添加实在是太繁琐了。那么就需要一个全局的方法来，将 store 的数据存储在 localStorage 里。<br>App.vue</p><pre class=" language-javascript"><code class="language-javascript">created<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//在页面刷新时将vuex里的信息保存到localStorage里</span>  window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"beforeunload"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">"messageStore"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//在页面加载时读取localStorage里的状态信息</span>  localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">"messageStore"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span>      Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">,</span>        JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">"messageStore"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="router-和-route-区别"><a href="#router-和-route-区别" class="headerlink" title="$router 和 $route 区别"></a>$router 和 $route 区别</h2><h3 id="1-gt-router-和-route-的区别"><a href="#1-gt-router-和-route-的区别" class="headerlink" title="1&gt;router 和 route 的区别"></a>1&gt;router 和 route 的区别</h3><ul><li><strong>router：router 为 VueRouter 实例(路由实例)，是路由的操作对象，对象包括了路由的跳转方法，钩子函数等。</strong></li><li><strong>route：route 为当前 router 跳转对象, 包含路由信息对象, 只读对象, 包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。</strong></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//1、手写完整的 path:</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`/user/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>userId<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>userId<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2、用 params 传递(url 不带参数，http:localhost:8080/#/user)：</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"user"</span><span class="token punctuation">,</span> params<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId<span class="token punctuation">:</span> <span class="token string">"123"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>params<span class="token punctuation">.</span>userId<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3、用 query 传递(url 带参数:http:localhost:8080/#/user?userId=123)：</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">"/user"</span><span class="token punctuation">,</span> query<span class="token punctuation">:</span> <span class="token punctuation">{</span> userId<span class="token punctuation">:</span> <span class="token string">"123"</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>userId<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="vue-的首屏优化"><a href="#vue-的首屏优化" class="headerlink" title="vue 的首屏优化"></a>vue 的首屏优化</h2><h3 id="一、减小-chunk-vendors-js-体积"><a href="#一、减小-chunk-vendors-js-体积" class="headerlink" title="一、减小 chunk-vendors.js 体积**"></a>一、减小 chunk-vendors.js 体积**</h3><p>解决方式：<br><strong>1、路由懒加载</strong></p><pre><code>const Home = () =&gt; import(/* webpackChunkName: &quot;home&quot; */ &#39;@/views/home&#39;);const Design = () =&gt; import(/* webpackChunkName: &quot;design&quot; */ &#39;@/views/design&#39;);const HotZone = () =&gt; import(/* webpackChunkName: &quot;hot-zone&quot; */ &#39;@/views/hot-zone&#39;);</code></pre><p><strong>2、lodash 按需加载</strong></p><pre><code>import _ from &#39;lodash&#39;; // 或 import lodash from &#39;lodash&#39;// 改成import flow from &#39;lodash/flow&#39;;</code></pre><p>**<br><strong>3、gd-components 组件按需引入</strong><br>安装<code>babel-plugin-import</code> 插件，修改<code>babel.config.js</code> 文件</p><pre><code>module.exports = {    presets: [&#39;@vue/app&#39;],    plugins: [        [&#39;import&#39;, {            &quot;libraryName&quot;: &#39;@gaoding/gd-components&#39;,            &quot;libraryDirectory&quot;: &#39;lib/components&#39;        }]    ]};</code></pre><p>4.对 css 和 js 进行压缩</p><h3 id="二、DNS预解析"><a href="#二、DNS预解析" class="headerlink" title="二、DNS预解析"></a>二、<code>DNS</code>预解析</h3><pre><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//retcode.alicdn.com&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//st-gdx.dancf.com&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//alicdn.huanleguang.com&quot;&gt;</code></pre><p>关于这点，底下有详细的文章介绍，有兴趣的朋友可以点进去了解，这边不多介绍。</p><h3 id="三、图片懒加载"><a href="#三、图片懒加载" class="headerlink" title="三、图片懒加载"></a>三、图片懒加载</h3><p>**<br><strong>四、减少 dom 数量和请求数</strong><br>由图片 lazy load，我们自然就考虑到了 dom 也可以 lazy load，所以把之前图片懒加载的方式延伸一下，改成 dom lazy load，同时对应的请求也放到后面再执行。<br>优化前的节点数和请求数：<br><strong>可以看到请求数和 dom 节点数都已经大幅度的减少。</strong><br>具体实现的原理很简单，也是利用<code>IntersectionObserver api</code>， 当 dom 刚刚进入视口再开始请求和渲染，对应的代码实现。</p><pre><code>lazyLoadTemplate() {    this.intersectionObservers = new IntersectionObserver(entries =&gt; {        entries.forEach(e =&gt; {            if (e.intersectionRatio &lt; this.ratio) return;            const id = e.target.dataset.id;            this.loaded[id] = true;            const funcName = `load${firstUpperCase(id)}`;            this[funcName] &amp;&amp; this[funcName]();            this.intersectionObservers.unobserve(e.target);        });    }, {        threshold: [0, 0.1, 0.25, 1]    });    const sections = this.$el.querySelectorAll(&#39;.home-sections&#39;);    [...sections].forEach(item =&gt; {        this.intersectionObservers.observe(item);    });},</code></pre><h3 id="五、-SSR"><a href="#五、-SSR" class="headerlink" title="五、 SSR"></a>五、 SSR</h3><p>与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于：</p><ul><li><strong>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</strong></li><li><strong>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备</strong>。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content) 与转化率直接相关」的应用程序而言，服务器端渲染 (SSR) 至关重要。</li></ul><p>服务端渲染实现原理机制：<strong>在服务端拿数据进行解析渲染，直接生成 html 片段返回给前端。然后前端可以通过解析后端返回的 html 片段到前端页面，大致有以下两种形式：</strong><br>1、服务器通过模版引擎直接渲染整个页面，例如 java 后端的 vm 模版引擎，php 后端的 smarty 模版引擎。<br>2、服务渲染生成 html 代码块, 前端通过 AJAX 获取然后使用 js 动态添加。</p><p>作者：wqzwh<br>链接：<a href="https://juejin.im/post/6844903545448169479" target="_blank" rel="noopener">https://juejin.im/post/6844903545448169479</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="六-预渲染-prerender-spa-plugin"><a href="#六-预渲染-prerender-spa-plugin" class="headerlink" title="六.预渲染(prerender-spa-plugin)"></a>六.预渲染(<a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">prerender-spa-plugin</a>)</h3><p>我们知道 SPA 有很多优点，不过一个缺点就是对(不是 Google 的)愚蠢的搜索引擎的 SEO 不友好，为了照顾这些引擎，目前主要有两个方案：<strong>服务端渲染</strong>(Server Side Rendering)、<strong>预渲染</strong>(Prerending)。<br>如果你只需要改善少数页面（例如 <code>/</code>, <code>/about</code>, <code>/contact</code> 等）的 <code>SEO</code>，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML (服务端渲染, SSR)，<strong>而是使用预渲染方式，在构建时(build time)简单地生成针对特定路由的静态 HTML 文件。</strong>它主要使用 <a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">prerender-spa-plugin</a> 插件，其与 SSR 一样都可以加快页面的加载速度，并且侵入性更小，在已上线的项目稍加改动也可以轻松引入预渲染机制，而 SSR 方案则需要将整个项目结构推翻；<br>访问预渲染出来的页面在访问时与<code>SSR</code>一样快，并且它将服务端编译 HTML 的时机提前到了构建时，因此也降低了服务端的压力，如果你的服务器跟我的一样买的 <strong>1M1G1 核</strong> 的小水管服务器 ( 穷 )，那么预渲染可能更适合你。不过 SSR 和预渲染的使用场景还是有较明显的区别的。预渲染的使用场景更多是简单的静态页面。服务端渲染适用于复杂、较大型、与服务端交互频繁的功能型网站，比如电商网站。</p><p>最后如果希望进一步优化生成出来页面的 SEO，可以配合  <a href="https://github.com/muwoo/vue-meta-info" target="_blank" rel="noopener">vue-meta-info</a>  这个网上有很多文章，就不赘述了</p><p>作者：SHERlocked93<br>链接：<a href="https://juejin.im/post/6844903668488093704" target="_blank" rel="noopener">https://juejin.im/post/6844903668488093704</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="七-服务端开启-gzip-压缩"><a href="#七-服务端开启-gzip-压缩" class="headerlink" title="七.服务端开启 gzip 压缩"></a>七.服务端开启 gzip 压缩</h3><h3 id="8-app-js-分包"><a href="#8-app-js-分包" class="headerlink" title="8.app.js 分包"></a>8.app.js 分包</h3><h3 id="9-首页加-loading-或-骨架屏-（仅仅是优化体验）"><a href="#9-首页加-loading-或-骨架屏-（仅仅是优化体验）" class="headerlink" title="9.首页加 loading 或 骨架屏 （仅仅是优化体验）"></a>9.首页加 loading 或 骨架屏 （仅仅是优化体验）</h3><h2 id="webpack-模块"><a href="#webpack-模块" class="headerlink" title="webpack 模块"></a>webpack 模块</h2><h3 id="webpack-的优点："><a href="#webpack-的优点：" class="headerlink" title="webpack 的优点："></a>webpack 的优点：</h3><ul><li>代码转换: <code>typeScript</code> 编译成 <code>javaScript</code>、<code>scss，less</code> 编译成 <code>css</code>.</li><li>文件优化：压缩 <code>javaScript</code>、<code>css</code>、<code>html</code> 代码，压缩合并图片。</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li><li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li><li>扩展性强，插件机制完善。</li></ul><h3 id="webpack-打包过程："><a href="#webpack-打包过程：" class="headerlink" title="webpack 打包过程："></a>webpack 打包过程：</h3><p>1.利用 babel 完成代码转换,并生成单个文件的依赖 2.从入口开始递归分析，并生成依赖图谱 3.将各个引用模块打包为一个立即执行函数 4.将最终的 bundle 文件写入 bundle.js 中</p><h3 id="Webpack-的四大核心："><a href="#Webpack-的四大核心：" class="headerlink" title="Webpack 的四大核心："></a>Webpack 的四大核心：</h3><ul><li>entry：js 入口源文件</li><li>output：生成文件</li><li>loader：进行文件处理</li><li>plugins：插件，比 loader 更强大，能使用更多 webpack 的 api</li></ul><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>webpack 应该使用哪个模块做为<strong>入口文件，</strong>来作为构建其内部依赖图的开始。进去入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的，每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。<br>单⼊⼝：entry 是⼀个字符串</p><pre><code>module.exports = {  entry: &#39;./src/index.js&#39;}</code></pre><p>多⼊⼝：entry 是⼀个对象</p><pre><code>module.exports = {  entry: {    index: &#39;./src/index.js&#39;,    manager: &#39;./src/manager.js&#39;  }}</code></pre><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>告诉 webpack 在哪里<strong>输出它所创建的 bund</strong>les，以及如何命名这些文件，这些都可以在 webpack 的配置文件中指定。<br>单⼊⼝配置</p><pre><code>module.exports = {    entry: &#39;./src/index.js&#39;,    output: {        filename: &#39;bundle.js’,        path: __dirname + &#39;/dist&#39;    }};</code></pre><p>多⼊⼝配置</p><pre><code>module.exports = {  entry: {    app: &#39;./src/app.js&#39;,    search: &#39;./src/search.js&#39;  },  output: {    filename: &#39;[name].js&#39;,    path: __dirname + &#39;/dist&#39;  }}</code></pre><p>通过[name]占位符确保⽂件名称的唯⼀</p><h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p><code>loader</code> 让 <code>webpack</code> 能够去处理那些非 <code>javaScript</code> 文件（<strong><code>webpack</code> 自身只理解 <code>javaScript</code></strong>）。<code>loader</code> 可以<strong>将所有类型的文件转换为 <code>webpack</code> 能够处理的有效模块</strong>，然后你就可以利用 <code>webpack</code> 的打包能力，对它们进行处理。</p><h3 id="loader-的特点"><a href="#loader-的特点" class="headerlink" title="loader 的特点"></a>loader 的特点</h3><ul><li>一个 Loader 的职责是单一的，只需要完成一种转换</li><li>一个 Loader 其实就是一个 Node.js 模块，这个模块需要导出一个函数</li><li>loader 总是从右到左地被调用。</li></ul><h3 id="常用的-loader"><a href="#常用的-loader" class="headerlink" title="常用的 loader"></a>常用的 loader</h3><h4 id="处理样式"><a href="#处理样式" class="headerlink" title="处理样式"></a>处理样式</h4><ul><li><strong><code>css-loader</code>: 加载.css 文件，</strong></li><li><strong><code>style-loader</code>:使用 style 标签将 <code>css-loader</code> 内部样式注入到我们的 html 页面</strong></li><li><strong><code>less-loader, sass-loader</code>: 解析 css 预处理器</strong></li></ul><h4 id="处理-js"><a href="#处理-js" class="headerlink" title="处理 js"></a>处理 js</h4><ul><li>让你能使用最新的 js 代码（ES6，ES7…）</li><li>让你能使用基于 js 进行了拓展的语言，比如 React 的 JSX；</li></ul><h4 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h4><p>处理图片资源时，我们常用的两种 loader 是<code>file-loader</code>或者<code>url-loader</code>，两者的主要差异在于。<code>url-loader</code>可以设置图片大小限制，当图片超过限制时，其表现行为等同于<code>file-loader</code>，而当图片不超过限制时，则会将图片以<code>base64</code>的形式打包进 css 文件，以减少请求次数</p><h4 id="处理-vue-文件"><a href="#处理-vue-文件" class="headerlink" title="处理.vue 文件"></a>处理.vue 文件</h4><p><code>vue-loader</code> 是 <code>webpack</code> 的加载器模块，它使我们可以用 <code>.vue</code> 文件格式编写单文件组件。单文件组件文件有三个部分，即模板、脚本和样式。 <code>vue-loader</code> 模块允许 <code>webpack</code> 使用单独的加载器模块（例如 <code>sass 或 scss 加载器</code>）提取和处理每个部分。该设置使我们可以使用 <code>.vue</code> 文件无缝编写程序。</p><h3 id="开发一个-loader"><a href="#开发一个-loader" class="headerlink" title="开发一个 loader"></a>开发一个 loader</h3><p>需求：手写一个 <code>loader</code>，将 <code>&#39;kobe&#39;</code> 转换成 <code>&#39;Black Mamba&#39;</code>。当然大家可以根据自己的需求进行设计。这里只是讲解方法。</p><h4 id="1、编写-loader"><a href="#1、编写-loader" class="headerlink" title="1、编写 loader"></a>1、编写 loader</h4><p>在根目录下，新建目录 <code>kobe-loader</code> 作为我们编写 <code>loader</code> 的名称，执行 <code>npm init -y</code> 命令，新建一个模块化项目，然后新建 <code>index.js</code> 文件，相关源码如下：</p><pre><code>module.exports = function(content) {  return content &amp;&amp; content.replace(/kobe/gi, &#39;Black Mamba&#39;)}</code></pre><h4 id="2、注册模块"><a href="#2、注册模块" class="headerlink" title="2、注册模块"></a>2、注册模块</h4><p>正常我们安装的 <code>loader</code> 是从 <code>npm</code> 下载安装，但是我们可以在 <code>kobe-loader</code> 目录底下使用 <code>npm link</code> 做到在不发布模块的情况下，将本地的一个正在开发的模块的源码链接到项目的 <code>node_modules</code> 目录下，让项目可以直接使用本地的 <code>npm</code> 模块。</p><pre><code>npm link</code></pre><p>然后在项目根目录执行以下命令，将注册到全局的本地 <code>npm</code> 模块链接到项目的 <code>node_modules</code> 下</p><pre><code>$ npm link kobe-loader</code></pre><p>注册成功后，我们可以在 <code>node_modules</code> 目录下能查找到对应的 <code>loader</code>。</p><h4 id="3、在-webpack-中配置-loader"><a href="#3、在-webpack-中配置-loader" class="headerlink" title="3、在 webpack 中配置 loader"></a>3、在 webpack 中配置 loader</h4><p>在 <code>webpack.base.conf.js</code> 加上如下配置</p><pre><code>{  test:/\.js/,  loader: &#39;kobe-loader&#39;}</code></pre><p>此时，我们在所有 js 文件下书写的 <code>&#39;kobe&#39;</code> 就全部替换成 <code>&#39;Black Mamba&#39;</code>了。</p><h4 id="4、配置参数"><a href="#4、配置参数" class="headerlink" title="4、配置参数"></a>4、配置参数</h4><p>上面我们是写死的替换文案，假如我想通过配置项来改变，可以在 loader 中做以下调整</p><pre><code>// custom-loader/index.jsvar utils = require(&#39;loader-utils&#39;)module.exports = function (content) {  const options = utils.getOptions(this)  return content &amp;&amp; content.replace(/kobe/gi, options.name)}// webpack.base.conf.js{  test:/\.js/,  use: {    loader: &#39;kobe-loader&#39;,    options: {      name: &#39;kobe&#39;,    }  }}</code></pre><h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><p><strong>专注处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。</strong></p><h3 id="Plugin-的特点"><a href="#Plugin-的特点" class="headerlink" title="Plugin 的特点"></a>Plugin 的特点</h3><ul><li>是一个独立的模块</li><li>模块对外暴露一个 js 函数</li><li>函数的原型 <code>(prototype)</code> 上定义了一个注入 <code>compiler</code> 对象的 <code>apply</code>方法 <code>apply</code> 函数中需要有通过 <code>compiler</code> 对象挂载的 <code>webpack</code> 事件钩子，钩子的回调中能拿到当前编译的 <code>compilation</code> 对象，如果是异步编译插件的话可以拿到回调 <code>callback</code></li><li>完成自定义子编译流程并处理 <code>complition</code> 对象的内部数据</li><li>如果异步编译插件的话，数据处理完成后执行 <code>callback</code> 回调。</li></ul><h3 id="常用-Plugin"><a href="#常用-Plugin" class="headerlink" title="常用 Plugin"></a>常用 Plugin</h3><ul><li><code>HotModuleReplacementPlugin</code> 代码热替换。因为 <code>Hot-Module-Replacement</code> 的热更新是依赖于 <code>webpack-dev-server</code>，后者是在打包文件改变时更新打包文件或者 reload 刷新整个页面，<code>HRM</code> 是只更新修改的部分。</li><li><code>HtmlWebpackPlugin</code>, 生成 html 文件。将 webpack 中<code>entry</code>配置的相关入口 chunk 和 <code>extract-text-webpack-plugin</code>抽取的 css 样式 插入到该插件提供的<code>template</code>或者<code>templateContent</code>配置项指定的内容基础上生成一个 html 文件，具体插入方式是将样式<code>link</code>插入到<code>head</code>元素中，<code>script</code>插入到<code>head</code>或者<code>body</code>中。</li><li><code>ExtractTextPlugin</code>, 将 css 成生文件，而非内联 。该插件的主要是为了抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象。</li><li><code>NoErrorsPlugin</code>报错但不退出 webpack 进程</li><li><code>UglifyJsPlugin</code>，代码丑化，开发过程中不建议打开。 <code>uglifyJsPlugin</code> 用来对 js 文件进行压缩，从而减小 js 文件的大小，加速 load 速度。<code>uglifyJsPlugin</code> 会拖慢 webpack 的编译速度，所有建议在开发简单将其关闭，部署的时候再将其打开。多个 html 共用一个 js 文件(chunk)，可用 <code>CommonsChunkPlugin</code></li><li><code>purifycss-webpack</code>  。打包编译时，可剔除页面和 js 中未被使用的 css，这样使用第三方的类库时，只加载被使用的类，大大减小 css 体积</li><li><code>optimize-css-assets-webpack-plugin</code>   压缩 css，优化 css 结构，利于网页加载和渲染</li><li><code>webpack-parallel-uglify-plugin</code>   可以并行运行 UglifyJS 插件，这可以有效减少构建时间</li></ul><h3 id="开发一个-plugin"><a href="#开发一个-plugin" class="headerlink" title="开发一个 plugin"></a>开发一个 plugin</h3><ul><li>Webpack 在编译过程中，会广播很多事件，例如 run、compile、done、fail 等等，可以查看官网；</li><li>Webpack 的事件流机制应用了观察者模式，我们编写的插件可以监听 Webpack 事件来触发对应的处理逻辑；</li><li>插件中可以使用很多 Webpack 提供的 API，例如读取输出资源、代码块、模块及依赖等；</li></ul><h4 id="1、编写插件"><a href="#1、编写插件" class="headerlink" title="1、编写插件"></a>1、编写插件</h4><p>在根目录下，新建目录 my-plugin 作为我们编写插件的名称，执行 npm init -y 命令，新建一个模块化项目，然后新建 index.js 文件，相关源码如下：</p><pre><code>class MyPlugin {  constructor(doneCallback, failCallback) {    // 保存在创建插件实例时传入的回调函数    this.doneCallback = doneCallback    this.failCallback = failCallback  }  apply(compiler) {    // 成功完成一次完整的编译和输出流程时，会触发 done 事件    compiler.plugin(&#39;done&#39;, stats =&gt; {      this.doneCallback(stats)    })    // 在编译和输出的流程中遇到异常时，会触发 failed 事件    compiler.plugin(&#39;failed&#39;, err =&gt; {      this.failCallback(err)    })  }}module.exports = MyPlugin</code></pre><h4 id="2、注册模块-1"><a href="#2、注册模块-1" class="headerlink" title="2、注册模块"></a>2、注册模块</h4><p>按照以上的方法，我们在 my-plugin 目录底下使用 npm link 做到在不发布模块的情况下，将本地的一个正在开发的模块的源码链接到项目的 node_modules 目录下，让项目可以直接使用本地的 npm 模块。</p><pre><code>npm link</code></pre><p>然后在项目根目录执行以下命令，将注册到全局的本地 npm 模块链接到项目的 node_modules 下</p><pre><code>$ npm link my-plugin</code></pre><p>注册成功后，我们可以在 node_modules 目录下能查找到对应的插件了。</p><h4 id="3、配置插件"><a href="#3、配置插件" class="headerlink" title="3、配置插件"></a>3、配置插件</h4><p>在 webpack.base.conf.js 加上如下配置</p><pre><code>plugins: [  new MyPlugin(    stats =&gt; {      console.info(&#39;编译成功!&#39;)    },    err =&gt; {      console.error(&#39;编译失败!&#39;)    }  )]</code></pre><p>执行运行 or 编译命令，就能看到我们的 plugin 起作用了。</p><blockquote><p>loader 是一个编译器，<code>loader</code> 让 <code>webpack</code> 能够去处理那些非 <code>javaScript</code> 文件（<strong><code>webpack</code> 自身只理解 <code>javaScript</code></strong>）。<code>loader</code> 可以<strong>将所有类型的文件转换为 <code>webpack</code> 能够处理的有效模块</strong>，<br>**<br>loader，它是一个转换器，将 A 文件进行编译成 B 文件，比如：将 A.less 转换为 A.css，单纯的文件转换过程。</p></blockquote><blockquote><p>plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务</p></blockquote><p>文章引用：<br><a href="https://juejin.im/post/6844904113914773518" target="_blank" rel="noopener">https://juejin.im/post/6844904113914773518</a><br><a href="https://juejin.im/post/6844903480126078989" target="_blank" rel="noopener">https://juejin.im/post/6844903480126078989</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vuex </tag>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试（2）javascript</title>
      <link href="/leader755/11225.html"/>
      <url>/leader755/11225.html</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h2><ul><li>原型、继承、原型链、this 指向、设计模式、call, apply, bind,；</li><li>new 实现、防抖节流、let, var, const 区别、暂时性死区、event、loop；</li><li>promise 使用及实现、promise 并行执行和顺序执行；</li><li>async/await 的优缺点；</li><li>闭包、垃圾回收和内存泄漏、数组方法、数组乱序, 数组扁平化、事件委托、事件监听、事件模型。</li></ul><hr><h2 id="原型，原型链，继承"><a href="#原型，原型链，继承" class="headerlink" title="原型，原型链，继承"></a>原型，原型链，继承</h2><h3 id="原型："><a href="#原型：" class="headerlink" title="原型："></a>原型：</h3><p><strong>当使用构造函数创建一个对象后，在这个对象内部包含一个指针，这个指针指向构造函数的 prototype 属性所对应的值，这个指针被称为对象的为原型。</strong></p><h3 id="原型链："><a href="#原型链：" class="headerlink" title="原型链："></a>原型链：</h3><p><strong>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它会去它的原型对象里查找属性，这个原型对象又会有一个自己的原型，于是一直这样</strong>向上<strong>找（因为继承的，所以是向上找），于是就形成了原型链。</strong> 原型链的最顶端是 Object.prototype <strong>，</strong>Object.prototype  的原型是 null（null 没有原型），所以原型链的尽头为 null。</p><p>在 js 中我们使用构造函数来创建一个新的对象，每个构造函数内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。</p><h3 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h3><p><strong>继承：利用原型让一个引用类型继承另一个引用类型的属性和方法，并且将原型链作为实现继承的主要方法。</strong><br>继承一般有 2 种：接口继承和实现继承。接口继承只继承方法签名，实现继承则继承实际的方法。ECMAscript 中只支持实现继承，而且实现继承主要依靠原型链来实现的。</p><h4 id="实现继承的主要方法："><a href="#实现继承的主要方法：" class="headerlink" title="实现继承的主要方法："></a>实现继承的主要方法：</h4><h4 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h4><p><strong>核心：</strong> <strong>将父类的实例作为子类的原型</strong></p><ul><li>优点：共享了父类构造函数的方法</li><li>缺点：<ul><li>父类的引用类型值会被所有子类实例共享，但基本类型不会被共享。</li><li>子类构建时不能向父类传参</li></ul></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//在构造函数中，一般很少有数组形式的引用属性，大部分情况都是：基本属性 + 方法。</span><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"父亲"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 实例基本属性 (该属性，强调私有，不共享)</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  引用类型</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// -- 将需要复用、共享的方法定义在父类原型上</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>like<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>like <span class="token operator">=</span> like<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这里是关键，创建Parent的实例，并将该实例赋值给Child.prototype</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 核心</span><span class="token keyword">let</span> boy1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> boy2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 优点：共享了父类构造函数的say方法</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boy2<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> boy1<span class="token punctuation">.</span>say <span class="token operator">===</span> boy2<span class="token punctuation">.</span>say<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// hello , hello , true</span><span class="token comment" spellcheck="true">// 缺点1：不能传参数</span><span class="token comment" spellcheck="true">// 缺点2：多个实例对引用类型的操作会被篡改,但不会影响到基本类型。</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>name<span class="token punctuation">,</span> boy2<span class="token punctuation">.</span>name<span class="token punctuation">,</span> boy1<span class="token punctuation">.</span>name <span class="token operator">===</span> boy2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 父亲，父亲，true</span>boy1<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 修改了boy1的arr属性，boy2的arr属性，也会变化，因为两个实例的原型上(Child.prototype)有了父类构造函数的实例属性arr；所以只要修改了boy1.arr,boy2.arr的属性也会变化。  ----  原型上的arr属性是共享的。</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy2<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1,2,3]</span></code></pre><blockquote><p><strong>总结：</strong></p><ul><li>共享了父类构造函数的方法，父类的引用类型值会被所有子类实例共享，但基本类型不会被共享。</li><li>子类构建时不能向父类传参。</li></ul></blockquote><blockquote><p>原型链并非十分完美, 它包含如下两个问题：<br>问题一: 当原型链中包含引用类型值的原型时,该引用类型值会被所有实例共享;<br>问题二: 在创建子类型(例如创建 Son 的实例)时,不能向父类型(例如 Father)的构造函数中传递参数.</p></blockquote><p>####</p><h4 id="2、借用构造函数"><a href="#2、借用构造函数" class="headerlink" title="2、借用构造函数"></a>2、借用构造函数</h4><ul><li>核心：<strong>创建子类实例时调用父类**</strong>构造函数（*<strong>*等于是复制父类的实例属性给子类**</strong>）*<strong>*。</strong></li><li>优点：实例之间独立。<ul><li>子类构建时可以传参数。</li><li>子类实例不共享父类构造函数的引用属性。（如 arr 属性）</li></ul></li><li>缺点：<ul><li>只能继承父类的<strong>实例</strong>属性和方法，不能继承原型属性/方法(因为没有用到原型)</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 实例基本属性 (该属性，强调私有，不共享)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (引用类型)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 实例引用属性 (该属性，强调复用，需要共享)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>like<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//继承自Parent</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>like <span class="token operator">=</span> like<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> boy1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'小红'</span><span class="token punctuation">,</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> boy2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">,</span> <span class="token string">'orange '</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 优点1：可传参</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>name<span class="token punctuation">,</span> boy2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 小红， 小明</span><span class="token comment" spellcheck="true">// 优点2：不共享父类构造函数的引用属性</span>boy1<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>arr<span class="token punctuation">,</span>boy2<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// [1,2] [1]</span><span class="token comment" spellcheck="true">// 缺点1：方法不能复用</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>say <span class="token operator">===</span> boy2<span class="token punctuation">.</span>say<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false (说明，boy1和boy2</span>的say方法是独立，不是共享的<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 缺点2：不能继承父类原型上的方法</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>walk <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 在父类的原型对象上定义一个walk方法。</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我会走路'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>boy1<span class="token punctuation">.</span>walk<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// undefined (说明实例，不能获得父类原型上的方法)</span></code></pre><blockquote><p><strong>总结：</strong></p><ul><li>可以向父类构造函数传参，子类实例不共享父类构造函数的引用属性。（如 arr 属性）</li><li>只能继承父类的<strong>实例</strong>属性和方法，不能继承原型属性/方法(因为没有用到原型)</li><li>实例之间是独立的，每个子类都有父类实例函数的副本，无法实现复用，影响性能。</li></ul></blockquote><p>####</p><h4 id="3、组合继承（原型链继承和构造函数继承）"><a href="#3、组合继承（原型链继承和构造函数继承）" class="headerlink" title="3、组合继承（原型链继承和构造函数继承）"></a>3、组合继承（原型链继承和构造函数继承）</h4><ul><li>核心：用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。（原型链继承和构造函数继承的组合，兼具了二者的优点）</li><li>优点：<ul><li>父类的方法可以被复用</li><li>父类的引用属性不会被共享</li><li>子类构建实例时可以向父类传递参数</li></ul></li><li>缺点：<ul><li>调用了两次父类的构造函数，第一次给子类的原型添加了父类的 name, arr 属性，第二次又给子类的构造函数添加了父类的 name, arr 属性，从而覆盖了子类原型中的同名参数。这种被覆盖的情况造成了性能上的浪费。</li></ul></li><li>注意：’组合继承’这种方式，要记得修复 Child.prototype.constructor 指向</li></ul><blockquote><ul><li>第一次 Parent.call(this);从父类拷贝一份父类实例属性，作为子类的实例属性，</li><li>第二次 Child.prototype = new Parent();创建父类实例作为子类原型，此时这个父类实例就又有了一份实例属性，但这份会被第一次拷贝来的实例属性屏蔽掉，所以多余。</li></ul></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 实例基本属性 (该属性，强调私有，不共享)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (该属性，强调私有)</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// --- 将需要复用、共享的方法定义在父类原型上</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>like<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 核心   第二次</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">,</span>like<span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>like <span class="token operator">=</span> like<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 核心   第一次</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>这里是修复构造函数指向的代码<span class="token operator">--</span><span class="token operator">></span><span class="token keyword">let</span> boy1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'小红'</span><span class="token punctuation">,</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token keyword">let</span> boy2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">,</span><span class="token string">'orange'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 优点1：可以传参数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>name<span class="token punctuation">,</span>boy1<span class="token punctuation">.</span>like<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 小红，apple</span><span class="token comment" spellcheck="true">// 优点2：可复用父类原型上的方法</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>say <span class="token operator">===</span> boy2<span class="token punctuation">.</span>say<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">// 优点3：不共享父类的引用属性，如arr属性</span>boy1<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>arr<span class="token punctuation">,</span>boy2<span class="token punctuation">.</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1,2] [1] 可以看出没有共享arr属性。</span>注意：为啥要修复构造函数的指向？console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boy1<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Parent 你会发现实例的构造函数居然是Parent。</span>而实际上，我们希望子类实例的构造函数是Child<span class="token punctuation">,</span>所以要记得修复构造函数指向。修复如下Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span></code></pre><blockquote><p>其实 Child.prototype = new Parent()<br>console.log(Child.prototype.<strong>proto</strong> === Parten.prototype); // true<br>在构造函数中创建对象时，这个对象中包含一个指针，这个指针指向构造函数中属性 prototype 的所对应的值。</p></blockquote><blockquote><p><strong>总结：</strong></p><ul><li>父类的方法可以被复用，父类的引用属性不会被共享，子类构建实例时可以向父类传递参数。</li><li>调用 两次父类的构造函数，其原型中会存在两份相同的属性/方法，会被第一次拷贝来的实例属性覆盖，这种被覆盖的情况造成了性能上的浪费。</li><li>‘组合继承’这种方式，要记得修复 Child.prototype.constructor 指向为 Child，默认指向父类。</li></ul></blockquote><p>####</p><h4 id="4、原型式继承"><a href="#4、原型式继承" class="headerlink" title="4、原型式继承"></a>4、原型式继承</h4><p>object()对传入其中的对象执行了一次<code>浅复制</code>，将构造函数 F 的原型直接指向传入的对象。</p><ul><li>核心：利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</li><li>优点：父类方法可以复用</li><li>缺点：<ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"Nicholas"</span><span class="token punctuation">,</span>  friends<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"Shelby"</span><span class="token punctuation">,</span> <span class="token string">"Court"</span><span class="token punctuation">,</span> <span class="token string">"Van"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> anotherPerson <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>anotherPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Greg"</span><span class="token punctuation">;</span>anotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"Rob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> yetAnotherPerson <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>yetAnotherPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Linda"</span><span class="token punctuation">;</span>yetAnotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"Barbie"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"Shelby,Court,Van,Rob,Barbie"</span></code></pre><blockquote><p>总结：</p><ul><li>父类的方法可以复用，多个实例的<strong>引用类型属性</strong>指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul></blockquote><p>####</p><h4 id="5、寄生式继承"><a href="#5、寄生式继承" class="headerlink" title="5、寄生式继承"></a>5、寄生式继承</h4><ul><li>核心：在原型式继承的基础上，增强对象，返回构造函数.</li><li>优缺点：仅提供一种思路，函数的主要作用是为构造函数新增属性和方法，以<strong>增强函数</strong></li><li>缺点（同原型式继承）：<ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul></li><li></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> clone <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//通过调用函数创建一个新对象</span>  clone<span class="token punctuation">.</span>sayHi <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//以某种方式来增强这个对象</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> clone<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回这个对象</span><span class="token punctuation">}</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"Nicholas"</span><span class="token punctuation">,</span>  friends<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"Shelby"</span><span class="token punctuation">,</span> <span class="token string">"Court"</span><span class="token punctuation">,</span> <span class="token string">"Van"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> anotherPerson <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>anotherPerson<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"hi"</span></code></pre><p>####</p><h4 id="6、寄生组合继承（组合-构造函数和寄生模式）"><a href="#6、寄生组合继承（组合-构造函数和寄生模式）" class="headerlink" title="6、寄生组合继承（组合 构造函数和寄生模式）"></a>6、寄生组合继承（组合 构造函数和寄生模式）</h4><p>刚才说到组合继承有一个会两次调用父类的构造函数造成浪费的缺点，寄生组合继承就可以解决这个问题。<br>优缺点：这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code> 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code><br><strong>这是最成熟的方法，也是现在库实现的方法</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span>subType<span class="token punctuation">,</span> superType<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建对象，创建父类原型的一个副本</span>  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subType<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span>  subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指定对象，将新创建的对象赋值给子类的原型</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 父类初始化实例属性和原型属性</span><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>SuperType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>  SuperType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 将父类原型指向子类</span><span class="token function">inheritPrototype</span><span class="token punctuation">(</span>SubType<span class="token punctuation">,</span> SuperType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 新增子类原型属性</span>SubType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayAge <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">"xyc"</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">"lxy"</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ["red", "blue", "green", "2"]</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ["red", "blue", "green", "3"]</span></code></pre><h4 id="7、ES6-Class-extends"><a href="#7、ES6-Class-extends" class="headerlink" title="7、ES6 Class extends"></a>7、ES6 Class extends</h4><p>核心： ES6 继承的结果和寄生组合继承相似，本质上，ES6 继承是一种语法糖。但是，<br>寄生组合继承是先创建子类实例 this 对象，然后再对其增强；<br>而 ES6 先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。</p><ul><li>*<em>extends *</em>关键字实现原型继承。</li><li><strong>constructor</strong>是构造方法，this 关键字则代表实例对象。一个类中只能有一个构造函数，则会报错，如果没有显式指定构造方法，则会添加默认的 constructor 方法。</li><li><strong>super 关键字，必须显示指定是作为函数还是作为对象使用，否则会报错。</strong></li></ul><p>**<br>**<br><strong>具体可以看详细文章：</strong><a href="https://www.jianshu.com/p/8a1a60709e7e" target="_blank" rel="noopener">《es6 的类 class》</a></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// constructor</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>height<span class="token punctuation">,</span> width<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> width<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Getter</span>  <span class="token keyword">get</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">calcArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// Method</span>  <span class="token function">calcArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>width<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> rectangle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rectangle<span class="token punctuation">.</span>area<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出 200</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token punctuation">(</span>  <span class="token comment" spellcheck="true">// 继承</span>  <span class="token keyword">class</span> <span class="token class-name">Square</span> <span class="token keyword">extends</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//extends 关键字实现原型继承</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">super</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 如果子类中存在构造函数，则需要在使用“this”之前先调用 super()。</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Square"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">get</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>width<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> square <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Square</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>square<span class="token punctuation">.</span>area<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出 100</span></code></pre><p>ES6 实现继承的具体原理：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>Object<span class="token punctuation">.</span>setPrototypeOf <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>obj<span class="token punctuation">,</span> proto<span class="token punctuation">)</span> <span class="token punctuation">{</span>  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> proto<span class="token punctuation">;</span>  <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// B 的实例继承 A 的实例</span>Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>B<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> A<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// B 继承 A 的静态属性</span>Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、函数声明和类声明的区别<br>函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个 ReferenceError。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ReferenceError</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>2、ES5 继承和 ES6 继承的区别</p><ul><li><p>本质上 ES6 继承是 ES5 继承的语法糖</p></li><li><p>ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上（Parent.call(this)）.</p></li><li><p>ES6 的继承有所不同，实质上是先创建父类的实例对象 this，然后再用子类的构造函数修改 this。因为子类没有自己的 this 对象，所以必须先调用父类的 super()方法，否则新建实例报错。</p></li><li><p>ES6 继承中子类的构造函数的原型链指向父类的构造函数，ES5 中使用的是构造函数复制，没有原型链指向。</p></li><li><p>ES6 子类实例的构建，基于父类实例，ES5 中不是。</p></li></ul><blockquote><ul><li>ES6 Class extends 是 ES5 继承的语法糖</li><li>JS 的继承除了构造函数继承之外都基于原型链构建的</li><li>可以用寄生组合继承实现 ES6 Class extends，但是还是会有细微的差别</li></ul></blockquote><p>##</p><hr><h2 id="this-指向，call-apply-bind"><a href="#this-指向，call-apply-bind" class="headerlink" title="this 指向，call, apply, bind"></a>this 指向，call, apply, bind</h2><h3 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h3><p><strong>this 关键字只与函数的执行环境有关，而与声明环境没有关系.</strong><br><strong>this 关键字虽然会根据环境变化，**</strong>但是它始终指向的是调用当前函数的那个对象**</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//常见的三种调用函数的方式</span><span class="token function">func</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>child<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>func<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先不讲 apply</span></code></pre><p>从看到这篇文章起，你一定要记住，第三种调用形式，才是正常调用形式：</p><pre><code>func.call(context, p1, p2)</code></pre><p>其他两种都是语法糖，可以等价地变为 call 形式：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">func</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//等价于</span>func<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>child<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//等价于</span>obj<span class="token punctuation">.</span>child<span class="token punctuation">.</span>method<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>child<span class="token punctuation">,</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>至此我们的函数调用只有一种形式：</p><pre><code>func.call(context, p1, p2)</code></pre><p><strong>这样，this 就好解释了 this，就是上面代码中的 context。就这么简单。</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  foo<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> bar <span class="token operator">=</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj => obj.foo.call(obj)</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window    =>bar.call()转换为 bar.call()由于没有传 context,所以 this 就是 undefined,最后浏览器给你一个默认的 this —— window 对象</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  x<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>  f<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 20。典型的隐性绑定,这里 f 的this指向上下文 obj ,即输出 20</span>    <span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10 ，非箭头函数，普通函数谁调用它，this 就指向谁。</span>    foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//20改变 。使用call改变 this 的指向。</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>this 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。<br>按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则：</p><blockquote><p>如果你传的 context 是 null 或 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</p></blockquote><p><strong>this 指向什么，完全取决于什么地方以什么方式调用，而不是创建时。</strong><br>**</p><blockquote><ul><li>如果函数被 new 修饰<ul><li>this 绑定的是新创建的对象，例:var bar = new foo(); 函数 foo 中的 this 就是一个叫 foo 的新创建的对象 , 然后将这个对象赋给 bar , 这样的绑定方式叫 new 绑定 .</li></ul></li><li>如果函数是使用 call,apply,bind 来调用的<ul><li>this 绑定的是 call,apply,bind 的第一个参数.例: foo.call(obj); , foo 中的 this 就是 obj , 这样的绑定方式叫 显性绑定 .</li></ul></li><li>如果函数是在某个 上下文对象 下被调用<ul><li>this 绑定的是那个上下文对象，例 : var obj = { foo : foo }; obj.foo(); foo 中的 this 就是 obj . 这样的绑定方式叫 隐性绑定 .</li></ul></li><li>如果都不是，即使用默认绑定<ul><li>例:function foo(){…} foo() ,foo 中的 this 就是 window.(严格模式下默认绑定到 undefined).</li><li>这样的绑定方式叫 默认绑定。</li></ul></li></ul></blockquote><h3 id="apply-call-bind-改变-this-的指向"><a href="#apply-call-bind-改变-this-的指向" class="headerlink" title="apply, call, bind 改变 this 的指向"></a>apply, call, bind 改变 this 的指向</h3><ul><li>** apply(context, 实参) ，2 个参数，实参为数组， 自动执行函数**</li><li>** call(context, 实参)， 无数个参数，实参为单个参数传入，自动执行函数**</li><li>** bind(context, 实参)， 无数个参数，实参为单个参数传入 ，不会自动执行函数， 需要手动执行，并返回新的函数**</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//...赋值，表示多个参数</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"klivitam"</span><span class="token punctuation">,</span>  age<span class="token punctuation">:</span> <span class="token number">24</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span>show<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">"男"</span><span class="token punctuation">,</span> <span class="token string">"爱好唱歌"</span><span class="token punctuation">,</span> <span class="token string">"宅男"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//参数单个传入</span><span class="token comment" spellcheck="true">// ["男", "爱好唱歌", "宅男"]</span><span class="token comment" spellcheck="true">// klivitam</span>show<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"男"</span><span class="token punctuation">,</span> <span class="token string">"爱好唱歌"</span><span class="token punctuation">,</span> <span class="token string">"宅男"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//参数以数组的方式传入</span><span class="token comment" spellcheck="true">// ["男", "爱好唱歌", "宅男"]</span><span class="token comment" spellcheck="true">// klivitam</span></code></pre><p>具体可参考此篇文章：[bind，call, apply 的指向](<a href="https://www.yuque.com/docs/share/a7793549-fefe-4e1f-9d8d-8b49b7d33072?#" target="_blank" rel="noopener">https://www.yuque.com/docs/share/a7793549-fefe-4e1f-9d8d-8b49b7d33072?#</a> 《改变 this 的指向(弄懂 this 的指向)》)</p><hr><h2 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h2><h3 id="防抖：触发需要重新等待一段时间后再触发（搜索框输入，提交按钮）"><a href="#防抖：触发需要重新等待一段时间后再触发（搜索框输入，提交按钮）" class="headerlink" title="防抖：触发需要重新等待一段时间后再触发（搜索框输入，提交按钮）"></a>防抖：触发需要重新等待一段时间后再触发（搜索框输入，提交按钮）</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="节流：等待一段时间后-才会重新触发。（上拉加载更多）"><a href="#节流：等待一段时间后-才会重新触发。（上拉加载更多）" class="headerlink" title="节流：等待一段时间后 才会重新触发。（上拉加载更多）"></a>节流：等待一段时间后 才会重新触发。（上拉加载更多）</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">throtte</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> activeTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> current <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">-</span> activeTime <span class="token operator">></span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>      func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>      activeTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>##</p><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><hr><h2 id="懒加载和预加载"><a href="#懒加载和预加载" class="headerlink" title="懒加载和预加载"></a>懒加载和预加载</h2><h3 id="懒加载："><a href="#懒加载：" class="headerlink" title="懒加载："></a>懒加载：</h3><p>原理：先将 img 标签中的 src 链接设为同一张图片（默认占位图片），将其真正的图片地址存储再 img 标签的自定义属性中（比如 data-src）。当 js 监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到 src 属性中，达到懒加载的效果。</p><p>js 监听到该图片元素进入可视窗口时：当前元素距离顶部距离&lt; 当前滚动距离+当前的窗口的高度</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">isVisible</span><span class="token punctuation">(</span>$node<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> winH <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//当前窗口的高度</span>    scrollTop <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">scrollTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//当前窗口的滚动距离</span>    offSetTop <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">offSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>top<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//当前窗口距离顶部距离</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>offSetTop <span class="token operator">&lt;</span> winH <span class="token operator">+</span> scrollTop<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="预加载："><a href="#预加载：" class="headerlink" title="预加载："></a>预加载：</h3><p>提前加载,当用户需要查看时可直接从本地缓存中渲染。</p><hr><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="为什么会出现跨域问题"><a href="#为什么会出现跨域问题" class="headerlink" title="为什么会出现跨域问题"></a>为什么会出现跨域问题</h3><p>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的 javascript 脚本和另外一个域的内容进行交互。</p><h3 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h3><p>所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。</p><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p>当一个请求 url 的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面 url 不同即为跨域。</p><h3 id="跨域的解决方案："><a href="#跨域的解决方案：" class="headerlink" title="跨域的解决方案："></a>跨域的解决方案：</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1597595152704-b32b37a0-109d-4cf1-90ad-e3f520be3f8f.png#align=left&display=inline&height=448&margin=%5Bobject%20Object%5D&name=image.png&originHeight=448&originWidth=727&size=82160&status=done&style=none&width=727" alt="image.png"></p><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><ul><li><p><strong>原理</strong>：<code>JSONP</code>  主要就是利用了  <code>script</code>  标签 src 属性没有跨域限制来完成跨域。（还有 img 标签也可以没有跨域限制）</p></li><li><p><strong>限制</strong>：参数只能通过 url 传入，仅能支持 get 请求。</p></li><li><p>实现步骤:</p><ul><li>Step1: 创建 callback 方法</li><li>Step2: 插入 script 标签</li><li>Step3: 后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法</li><li>Step4: 前端执行服务端返回的方法调用。</li></ul></li></ul><h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h4><ul><li><strong>原理</strong>：使用 ws://（非加密）和 wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器端支持，无需任何配置就支持跨域。</li><li><strong>限制</strong>：</li><li><strong>使用</strong>：</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">"ws://127.0.0.1:3000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ws<span class="token punctuation">.</span>onopen <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 连接成功建立</span><span class="token punctuation">}</span><span class="token punctuation">;</span>ws<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 处理数据</span><span class="token punctuation">}</span><span class="token punctuation">;</span>ws<span class="token punctuation">.</span>onerror <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 发生错误时触发，连接中断</span><span class="token punctuation">}</span><span class="token punctuation">;</span>ws<span class="token punctuation">.</span>onclose <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 连接关闭时触发</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><ul><li><strong>原理</strong>：HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之。postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</li><li>限制：对于目标域限制不严格导致的，<em>*大多数开发人员由于对于 postmessage 防范中 targetOrigin 参数默认为\</em> **，因此只要包含了该方法页面，构造利用代码，就能够获取到敏感信息。</li><li>使用场景：<ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的 iframe 消息传递</li></ul></li></ul><ul><li>使用：</li></ul><p>a、localhost:3000 发送消息</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>  <span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span>跨域消息传递<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>  <span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> value<span class="token operator">=</span><span class="token string">"hello,missfresh"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"send"</span><span class="token operator">></span>发送消息<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>iframe      src<span class="token operator">=</span><span class="token string">"http://localhost:8080/#/reciveMessage"</span> width<span class="token operator">=</span><span class="token string">"500"</span> height<span class="token operator">=</span><span class="token string">"500"</span>id<span class="token operator">=</span><span class="token string">"receiver"</span>    <span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>iframe<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>  window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> receiver <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"receiver"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>contentWindow<span class="token punctuation">;</span>    <span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"send"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">var</span> val <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>      receiver<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>val <span class="token operator">+</span> <span class="token string">"！"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>b、localhost:8080 接收消息</p><pre class=" language-javascript"><code class="language-javascript">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> messageEle <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    messageEle<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"从"</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>origin <span class="token operator">+</span> <span class="token string">"收到消息： "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>data<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="vue-的-proxyTable-跨域"><a href="#vue-的-proxyTable-跨域" class="headerlink" title="vue 的 proxyTable 跨域"></a>vue 的 proxyTable 跨域</h4><p><strong>原理：</strong>在本地运行 npm run dev 等命令时实际上是用 node 运行了一个服务器 A，因此 proxyTable 实际上是将请求发给服务器 A，再由服务器 A 转发给后台服务器，做了一层代理，所以不会出现跨域问题。（浏览器是禁止跨域的，但是服务端不禁止。）<strong>简单来说就是使用 node 作为代理转发请求。</strong><br><strong>限制</strong>：<br><strong>使用：</strong></p><pre class=" language-javascript"><code class="language-javascript">proxyTable<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">'/api/*'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        target<span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:8088'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//实际请求的服务器地址</span>        changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        pathRewrite<span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token string">'^/api'</span><span class="token punctuation">:</span> <span class="token string">''</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        headers<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//这边可以堆headers进行设置</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h2 id="http-缓存和浏览器缓存："><a href="#http-缓存和浏览器缓存：" class="headerlink" title="http 缓存和浏览器缓存："></a>http 缓存和浏览器缓存：</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1597190312319-9a734ed7-94f8-44e0-81b3-eff39156d4e4.png#align=left&display=inline&height=409&margin=%5Bobject%20Object%5D&name=image.png&originHeight=613&originWidth=800&size=163634&status=done&style=none&width=534" alt="image.png"></p><h3 id="什么是-HTTP-缓存-？"><a href="#什么是-HTTP-缓存-？" class="headerlink" title="什么是 HTTP 缓存 ？"></a>什么是 HTTP 缓存 ？</h3><p>http 缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。<br>常见的 http 缓存只能缓存 get 请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指 GET 请求。</p><p>http 缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在 respone header 头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接 200，否则就把请求参数加到 request header 头中传给服务器，看是否命中协商缓存，命中则返回 304，否则服务器会返回新的资源。<br><strong>1、http 缓存的分类：</strong><br>根据是否需要重新向服务器发起请求来分类，可分为(强制缓存，协商缓存) 根据是否可以被单个或者多个用户使用来分类，可分为(私有缓存，共享缓存) 强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。下面是强制缓存和协商缓存的一些对比：<br><img src="//upload-images.jianshu.io/upload_images/4845448-ab0e961921da5694?imageMogr2/auto-orient/strip%7CimageView2/2/w/690/format/webp#align=left&display=inline&height=396&margin=%5Bobject%20Object%5D&originHeight=396&originWidth=690&status=done&style=none&width=690" alt=""><br>image</p><p><strong>1.1、强制缓存</strong><br>强制缓存在缓存数据未失效的情况下（即 Cache-Control 的 max-age 没有过期或者 Expires 的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http 状态码为 200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。这种情况就是我们在开发种经常遇到的，比如你修改了页面上的某个样式，在页面上刷新了但没有生效，因为走的是强缓存，所以 Ctrl + F5 一顿操作之后就好了。 跟强制缓存相关的 header 头属性有（Pragma/Cache-Control/Expires）<br><img src="//upload-images.jianshu.io/upload_images/4845448-217723260f75ed90?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&originHeight=228&originWidth=800&status=done&style=none&width=800" alt=""></p><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。</p><h3 id="HTTP-缓存的作用"><a href="#HTTP-缓存的作用" class="headerlink" title="HTTP 缓存的作用"></a>HTTP 缓存的作用</h3><p>我们都知道浏览器是基于 HTTP 协议和服务端进行通信的，一个网站一旦同时请求过多或者请求过大就容易造成页面渲染时长过长等性能问题，而且并非所有资源都需要实时更新的，将长久或一段时间内的资源进行缓存，能很大的缓解服务器压力和提升网站性能。<br>毫不夸张的说，HTTP 缓存是达到高性能的重要组成部分。</p><blockquote><p>注意：缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。</p></blockquote><h3 id="HTTP-头缓存相关字段及优先级"><a href="#HTTP-头缓存相关字段及优先级" class="headerlink" title="HTTP 头缓存相关字段及优先级"></a>HTTP 头缓存相关字段及优先级</h3><p>强缓存：<strong>Expires: Date/Cache-Control：max-age=N</strong><br>协商缓存：<strong>Last-Modified：Date</strong>和<strong>Etag：String</strong><br>通过查询标准我们知道 Cache-Control 和 Etag 属于 HTTP1.1 版本，Expires 和 Last-Modified 属于 HTTP1.0 版本，所以得出以下优先级：<br>强缓存：<strong>Cache-Control &gt; Expires</strong><br>协商缓存：<strong>Etag &gt; Last-Modified</strong></p><blockquote><p><strong>注意：</strong><br>Expires 存在的缺陷是返回的到期时间是服务器端的时间，可能与客户端的时间有较大的时间差，所以在 HTTP1.1 版开始使用 Cache-Control: max-age=秒替代<br>Last-Modified 的缺陷：由于只能精确到秒，如果一个文件在 1 秒内多次修改，这时客户端无法识别，因此 HTTP1.1 版本使用 Etag 标识资源内容是否有变更来确认资源是否需要更新，相对来说更加精确</p></blockquote><h3 id="强缓存与协商缓存"><a href="#强缓存与协商缓存" class="headerlink" title="强缓存与协商缓存"></a>强缓存与协商缓存</h3><p><strong>强缓存</strong>：资源一旦被<strong>强缓存</strong>，在缓存时间内，浏览器发起二次请求时会直接读取本地缓存，不与服务器进行通讯。 强缓存时间过期的，浏览器会判断资源的响应头是否有 Last-Modified 和 Etag 字段，有的话执行<strong>协商缓存</strong>策略<br><strong>协商缓存</strong>：如果响应头中的包括有 Etag 和 Last-Modified 字段，则客户端将 If-None-Match：Etag 的值和 If-Modified-Since：Last-Modified 的值添加到请求头发送给服务器，由源服务器校验，如果资源未过期则返回 304 状态码，浏览器直接使用缓存，否则返回 200OK 状态码和新资源。<br>当两种情况都存在时，<strong>强缓存优先级要高于协商缓存</strong>。</p><h3 id="Chrome-浏览器的三种缓存策略"><a href="#Chrome-浏览器的三种缓存策略" class="headerlink" title="Chrome 浏览器的三种缓存策略"></a>Chrome 浏览器的三种缓存策略</h3><p>_选择 Chrome 是因为它是现在最流行的网页调试工具也是最多人用的浏览器。_Chrome 浏览器返回缓存 http 状态码总共有以下三个 1、<strong>200 from memory cache</strong>客户端不与服务器通讯，直接从内存中读取缓存。此时的数据时缓存到内存中的，当关闭浏览器后，数据自然就被当垃圾回收清空。<br>2、<strong>200 from disk cache</strong>客户端不与服务器通讯，直接从磁盘中读取缓存，因为数据存在磁盘中，就算关闭浏览器数据还是存在，下次打开只要数据不过期就可以直接读取。<br>3、<strong>304 Not Modified</strong>客户端与服务器通讯，服务器验证资源是否需要更新，如果不需要更新服务器返回 304 状态码，然后客户端直接从缓存中读取数据</p><blockquote><p>注意：经过测试，我发现 Safari 和 Firefox 都有三种缓存策略，IE 和其他浏览器大家可以各自测试一下</p></blockquote><h3 id="浏览器三种缓存示例图"><a href="#浏览器三种缓存示例图" class="headerlink" title="浏览器三种缓存示例图"></a>浏览器三种缓存示例图</h3><p>Chrome 和 Safari 似乎没有办法在浏览器中直接查看缓存情况，因此只能实践中查看。 Chrome 示例图: 状态码：<strong>200 OK</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597190456008-7a79c689-007d-4d84-a29b-bf35af5d9446.webp#align=left&display=inline&height=436&margin=%5Bobject%20Object%5D&originHeight=436&originWidth=805&size=0&status=done&style=none&width=805" alt="">状态码：<strong>200 from memeory cache</strong><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597190456038-353ee511-e169-45b7-b11c-fd5ced110fe3.webp#align=left&display=inline&height=430&margin=%5Bobject%20Object%5D&originHeight=430&originWidth=721&size=0&status=done&style=none&width=721" alt="">状态码：<strong>200 from disk cache</strong><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597190455996-e6b3b611-6fc6-4150-ba58-e70600d216a7.webp#align=left&display=inline&height=437&margin=%5Bobject%20Object%5D&originHeight=437&originWidth=809&size=0&status=done&style=none&width=809" alt="">状态码：<strong>304 Not Modified</strong><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597190455976-3514054f-962c-4fa0-a701-d1fafd3c8d9e.webp#align=left&display=inline&height=369&margin=%5Bobject%20Object%5D&originHeight=369&originWidth=780&size=0&status=done&style=none&width=780" alt="">))<br>Safari 示例图： 响应头：<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597190456010-891b40f2-e533-4154-9dca-0ec262bc4b60.webp#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&originHeight=564&originWidth=1244&size=0&status=done&style=none&width=1244" alt="">状态码：200 OK<img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597190456006-5b41e3c7-ab68-49e7-ac41-aad156d64252.webp#align=left&display=inline&height=302&margin=%5Bobject%20Object%5D&originHeight=302&originWidth=1280&size=0&status=done&style=none&width=1280" alt="">状态码：200 内存<img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597190456020-93bcf783-4d71-4632-b424-d424885d47d3.webp#align=left&display=inline&height=460&margin=%5Bobject%20Object%5D&originHeight=460&originWidth=1242&size=0&status=done&style=none&width=1242" alt="">状态码：200 磁盘<img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597190455994-1bbd166a-2051-4080-952e-bbd5fe5fccf4.webp#align=left&display=inline&height=456&margin=%5Bobject%20Object%5D&originHeight=456&originWidth=1236&size=0&status=done&style=none&width=1236" alt=""><br>Firefox：在 url 上输入 about:cache 可以看到对应的缓存情况，大家可以试一下<br><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597190455993-71d57da2-268c-4a75-88bc-98f922b94c15.webp#align=left&display=inline&height=941&margin=%5Bobject%20Object%5D&originHeight=941&originWidth=1280&size=0&status=done&style=none&width=1280" alt="">从截图中可以看到 Firefox 也分为内存缓存和磁盘缓存，304Not Modified 自然也是有的。<img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597190455990-8d7c53b1-2688-4cba-bce7-21076f0e3829.webp#align=left&display=inline&height=347&margin=%5Bobject%20Object%5D&originHeight=347&originWidth=1280&size=0&status=done&style=none&width=1280" alt="">资源被强缓存后状态码依然是 200 OK，不过会在传输列下显示已缓存，但是无法看出是内存缓存还是磁盘缓存。<img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597190455999-5a96cafe-9a51-4dac-a26c-bea1cac98990.webp#align=left&display=inline&height=309&margin=%5Bobject%20Object%5D&originHeight=309&originWidth=1280&size=0&status=done&style=none&width=1280" alt="">Firefox 的 304 与 Chrome 和 Safari 差别不大。</p><h3 id="三种缓存策略实际执行的条件"><a href="#三种缓存策略实际执行的条件" class="headerlink" title="三种缓存策略实际执行的条件"></a>三种缓存策略实际执行的条件</h3><p>我在网上看到有人写文章说 <strong>js、图片和字体保存在内存中而 css 则保存在磁盘</strong>，很明显，只要自己稍微测试一下就知道这种说法是站不住脚的，那么这三种情况究竟是怎样的呢？<br>经过简单的测试以后我发现这三种策略并不复杂，默认配置情况下，Chrome 第一次请求资源后，如果资源的响应头有 Cache-Control 或者 Expires 且有效期大于现在，则加载数据后将强缓存资源到内存和磁盘。<br>刷新页面，Chrome 发起整个页面的二次请求后，通过开发者工具可以看到<strong>强缓存资源</strong>都会从内存进行读取，这就是<em>200 from memory cache</em>的情况。<br>示例：<br>这时关闭浏览器后，重新打开浏览器并打开关闭前的页面，通过开发者工具可以看到之前<strong>强缓存资源</strong>都会从磁盘中读取，这是因为关闭了浏览器后系统回收了内存资源，因此内存没有了之前的<strong>强缓存资源</strong>，需要从磁盘中读取，这就是<em>200 from disk cache</em>的情况。<br>示例：<br>如果这时使用 ctrl + f5 强刷页面则会发现全部资源都是 200 OK 状态要从服务器中获取新数据。<br>304 Not Modified 的情况则完全不同，如果资源的响应头是 Last-Modified 或 Etag，第一次请求资源后缓存到本地磁盘，但第二次也必须发起请求到服务器进行查询该资源是否过期或被修改过，当服务器验证资源没有过期后才会返回 304 Not Modified 状态码，同时响应体为空，这样可以节省流量并提高响应速度，客户端接收到 304 状态码后从本地读取数据，因此 304 比 200 from cache 响应速度要慢，但比 200 OK 快得多。</p><h3 id="Chrome-浏览器缓存机制流程图"><a href="#Chrome-浏览器缓存机制流程图" class="headerlink" title="Chrome 浏览器缓存机制流程图"></a>Chrome 浏览器缓存机制流程图</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1597190456008-d90347ea-0343-4d19-9929-b1eaf14665bf.webp#align=left&display=inline&height=844&margin=%5Bobject%20Object%5D&originHeight=844&originWidth=1280&size=0&status=done&style=none&width=1280" alt=""></p><h2 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h2><p>伪类：其核心就是用来选择那些不能够被普通选择器选择的文档之外的元素，比如:hover,:active。<br>伪元素：其核心就是需要创建通常不存在于文档中的元素，比如::before。<br>区别：<br>针对作用选择器的效果，伪类需要添加类来达到效果，而伪元素需要增加元素，所以一个叫伪类，另外一个叫伪元素。</p><ul><li>伪类和伪元素都是用来表示文档树以外的”元素”。</li><li>伪类和伪元素分别用单冒号<code>:</code>和双冒号<code>::</code>来表示。</li><li>伪类和伪元素的区别，最关键的点在于如果没有伪元素(或伪类)，是否需要添加元素才能达到目的，如果是则是伪元素，反之则是伪类。</li></ul><h2 id="浏览器渲染的过程："><a href="#浏览器渲染的过程：" class="headerlink" title="浏览器渲染的过程："></a>浏览器渲染的过程：</h2><ol><li>处理 HTML 标记并构建 DOM 树。</li><li>处理 CSS 标记并构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上。</li></ol><p>需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。</p><h2 id="var、let、const-区别"><a href="#var、let、const-区别" class="headerlink" title="var、let、const 区别"></a>var、let、const 区别</h2><p>var 申明的是全局作用域，全局变量<br><strong>let 声明的变量拥有块级作用域，局部变量</strong><br>const 就是用来声明常量，<strong>块级作用域，局部变量</strong><br>**<br>var 能够进行变量提升，是全局变量，能够重新申明你变量，let ，const 都是块级作用域，不允许重复申明，重复申明会报错，没有变量提升，const 是常量，一旦申明就不能被修改，并且需要有初始值。</p><table><thead><tr><th align="center">声明方式</th><th align="center">变量提升</th><th align="center">暂时性死区</th><th align="center">重复声明</th><th align="center">初始值</th><th align="center">作用域</th></tr></thead><tbody><tr><td align="center">var</td><td align="center">允许</td><td align="center">不存在</td><td align="center">允许</td><td align="center">不需要</td><td align="center">除块级</td></tr><tr><td align="center">let</td><td align="center">不允许</td><td align="center">存在</td><td align="center">不允许</td><td align="center">不需要</td><td align="center">块级</td></tr><tr><td align="center">const</td><td align="center">不允许</td><td align="center">存在</td><td align="center">不允许</td><td align="center">需要</td><td align="center">块级</td></tr></tbody></table><ul><li>变量提升：变量可在声明之前使用。</li></ul><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正常运行，控制台输出 undefined</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//报错，Uncaught ReferenceError: b is not defined</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//报错，Uncaught ReferenceError: c is not defined</span><span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><blockquote><p><code>var</code> 命令经常会发生<strong>变量提升</strong>现象，按照一般逻辑，变量应该在声明之后使用才对。为了纠正这个现象，ES6 规定 <code>let</code> 和 <code>const</code> 命令<strong>不发生变量提升</strong>，使用 <code>let</code> 和 <code>const</code> 命令声明变量之前，该变量是不可用的。主要是为了减少运行时错误，防止变量声明前就使用这个变量，从而导致意料之外的行为。</p></blockquote><ul><li>暂时性死区(形成封闭式死区)<ul><li>概述：如果在代码块中存在  <code>let</code>  或  <code>const</code>  命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</li></ul></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  tmp <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//报错，Uncaught ReferenceError: tmp is not defined</span>  <span class="token keyword">let</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>这段代码的原意是在 if 内定义外部的 <code>tmp</code> 为 ‘abc’。<br>但现实是，存在全局变量 <code>tmp</code>，但是块级作用域内 <code>let</code> 又声明了一个 <code>tmp</code>变量，导致后者被绑定在这个块级作用域中，所以在 <code>let</code> 声明变量前，对 <code>tmp</code> 赋值就报错了。</p></blockquote><ul><li>重复声明：指在相同作用域内，重复声明同一个变量。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> PI <span class="token operator">=</span> <span class="token number">3.1415</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 报错，Uncaught SyntaxError: Identifier 'a' has already been declared</span>  <span class="token keyword">var</span> PI <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 报错，Uncaught SyntaxError: Identifier 'PI' has already been declared</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 当调用func()时报错，Uncaught SyntaxError: Identifier 'a' has already been declared</span><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> PI <span class="token operator">=</span> <span class="token number">3.1415</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 报错，Uncaught SyntaxError: Identifier 'a' has already been declared</span>  <span class="token keyword">const</span> PI <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 报错，Uncaught SyntaxError: Identifier 'PI' has already been declared</span><span class="token punctuation">}</span></code></pre><blockquote><p><code>let</code>  和  <code>const</code>  命令声明的变量不允许重复声明，但是 var 可以重复申明</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 5</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 10</span></code></pre><blockquote><p>因为  <code>var</code>  命令没有块级作用域，所以 for 循环括号内的变量  <code>i</code>  会覆盖外层  <code>i</code>，而且  <code>var</code>  允许重复声明，所以这段代码中  <code>i</code>  被声明了两次,<code>i</code>  的最终结果就被 for 循环的 i 给覆盖了。</p></blockquote><ul><li>初始值<ul><li>由于  <code>const</code>  声明的是只读的常量，一旦声明，就必须立即初始化，声明之后值不能改变。</li></ul></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//一旦被申明，就不能再改变</span><span class="token keyword">const</span> PI <span class="token operator">=</span> <span class="token number">3.1415</span><span class="token punctuation">;</span>PI <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 报错，Uncaught TypeError: Assignment to constant variable.</span><span class="token comment" spellcheck="true">//必须要有初始值</span><span class="token keyword">const</span> PI<span class="token punctuation">;</span>PI<span class="token operator">=</span><span class="token number">3.1415</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Uncaught SyntaxError: Missing initializer in const declaration</span></code></pre><ul><li>作用域</li></ul><p>在 ES5 中只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。<br>第一种场景，内层变量可能会覆盖外层变量：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//处于全局作用域</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//处于函数作用域</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined</span></code></pre><blockquote><p>function 内部的 2 个  <code>tmp</code>  变量处在同一函数作用域，由于变量提升，导致函数作用域中的  <code>tmp</code>  覆盖全局作用域中的  <code>tmp</code>，所以，f()输出结果为 undefined。</p></blockquote><p>第二种场景，用来计数的循环变量泄露为全局变量（前面在重复声明中提到的）：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 5</span></code></pre><hr><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>promise 是异步编程的一种解决方法，从语法上说 promise 是一个对象，从它可以获取异步操作的消息。promise 的出现是为了解决<strong>回调地狱</strong> 。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>参数传递太麻烦，Promise 解决了回调地狱的问题，但是如果遇到复杂的业务，代码里面会包含大量的 then 函数，使得代码依然不是太容易阅读。</p><h3 id="Promise-状态和值"><a href="#Promise-状态和值" class="headerlink" title="Promise 状态和值"></a>Promise 状态和值</h3><p>Promise 对象存在以下三种状态：Pending(进行中)、Resolved(已成功)、Rejected(已失败)。状态只能由  Pending  变为  Resolved  或由  Pending  变为  Rejected ，且状态改变之后不会在发生变化，会一直保持这个状态。</p><h3 id="Promise…-then…catch…finally"><a href="#Promise…-then…catch…finally" class="headerlink" title="Promise….then…catch…finally"></a>Promise….then…catch…finally</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//Promise的状态值一旦改变就不会再改变, 如果二者都存在,即为只执行在前面的项</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//成功时执行</span>  <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//失败时执行(此时不执行)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//接收resolve()中的参数</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"成功"</span> <span class="token operator">+</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//接收reject()中的参数</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"失败"</span> <span class="token operator">+</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="Promise-的静态方法"><a href="#Promise-的静态方法" class="headerlink" title="Promise 的静态方法"></a>Promise 的静态方法</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//成功</span><span class="token keyword">var</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等价于</span><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//失败</span><span class="token keyword">var</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"err"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等同于</span><span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"err"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>###</p><p>###</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><blockquote><p>类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败。</p></blockquote><pre class=" language-javascript"><code class="language-javascript">Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回值为two</span></code></pre><p>###</p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><blockquote><p>类方法，多个 Promise 任务同时执行。<br>如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。 如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果。</p></blockquote><pre class=" language-javascript"><code class="language-javascript">Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"成功了"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"失败了"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//失败了</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>##</p><hr><h2 id="async-await-的优缺点"><a href="#async-await-的优缺点" class="headerlink" title="async/await 的优缺点"></a>async/await 的优缺点</h2><p>Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它。复杂逻辑中，我们就能发现<code>async/await</code>确实比 then 链有优势。<br>async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。可以说 async 是 Generator 函数的语法糖，并对 Generator 函数进行了改进。</p><p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</p><p>async 函数对 Generator 函数的改进，体现在以下四点：</p><ol><li><code>内置执行器</code>。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，无需手动执行 next() 方法。</li><li><code>更好的语义</code>。async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li><li><code>更广的适用性</code>。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li><li><code>返回值是 Promise</code>。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。</li></ol><h3 id="async-await-执行顺序"><a href="#async-await-执行顺序" class="headerlink" title="async/await 执行顺序"></a>async/await 执行顺序</h3><p>通过上面的分析，我们知道<code>async</code>隐式返回 Promise 作为结果的函数,那么可以简单理解为，await 后面的函数执行完毕时，await 会产生一个微任务(Promise.then 是微任务)。但是我们要注意这个微任务产生的时机，它是执行完 await 之后，直接跳出 async 函数，执行其他代码(此处就是协程的运作，A 暂停执行，控制权交给 B)。其他代码执行完毕后，再回到 async 函数去执行剩下的代码，然后把 await 后面的代码注册到微任务队列当中。</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"script start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"async1 end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"async2 end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"setTimeout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Promise"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"script end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// script start => async2 end => Promise => script end => promise1 => promise2 => async1 end => setTimeout</span></code></pre><p>分析这段代码：</p><ul><li>执行代码，输出<code>script start</code>。</li><li>执行 async1(),会调用 async2(),然后输出<code>async2 end</code>,此时将会保留 async1 函数的上下文，然后跳出 async1 函数。</li><li>遇到 setTimeout，产生一个宏任务</li><li>执行 Promise，输出<code>Promise</code>。遇到 then，产生第一个微任务</li><li>继续执行代码，输出<code>script end</code></li><li>代码逻辑执行完毕(当前宏任务执行完毕)，开始执行当前宏任务产生的微任务队列，输出<code>promise1</code>，该微任务遇到 then，产生一个新的微任务</li><li>执行产生的微任务，输出<code>promise2</code>,当前微任务队列执行完毕。执行权回到 async1</li><li>执行 await,实际上会产生一个 promise 返回，即</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> promise_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">resolve</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>执行完成，执行 await 后面的语句，输出<code>async1 end</code></p><ul><li>最后，执行下一个宏任务，即执行 setTimeout，输出<code>setTimeout</code></li></ul><p>使用：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">takeLongTime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">resolve</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">step1</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`step1 with </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">takeLongTime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">step2</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`step2 with </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>m<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">takeLongTime</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">step3</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`step3 with </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>k<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>m<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">takeLongTime</span><span class="token punctuation">(</span>k <span class="token operator">+</span> m <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>promise 版本</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">doIt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"doIt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> time1 <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>  <span class="token function">step1</span><span class="token punctuation">(</span>time1<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>time2<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">step2</span><span class="token punctuation">(</span>time1<span class="token punctuation">,</span> time2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>time3<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>time1<span class="token punctuation">,</span> time2<span class="token punctuation">,</span> time3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>times<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> <span class="token punctuation">[</span>time1<span class="token punctuation">,</span> time2<span class="token punctuation">,</span> time3<span class="token punctuation">]</span> <span class="token operator">=</span> times<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token function">step3</span><span class="token punctuation">(</span>time1<span class="token punctuation">,</span> time2<span class="token punctuation">,</span> time3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`result is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"doIt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">doIt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>async/await 版本</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">doIt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"doIt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> time1 <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> time2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">step1</span><span class="token punctuation">(</span>time1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> time3 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">step2</span><span class="token punctuation">(</span>time1<span class="token punctuation">,</span> time2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">step3</span><span class="token punctuation">(</span>time1<span class="token punctuation">,</span> time2<span class="token punctuation">,</span> time3<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`result is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"doIt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">doIt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态，但是只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</p><h3 id="Generator-函数暂停恢复执行原理"><a href="#Generator-函数暂停恢复执行原理" class="headerlink" title="Generator 函数暂停恢复执行原理"></a>Generator 函数暂停恢复执行原理</h3><p>要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。</p><blockquote><p>一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p></blockquote><p>协程是一种比线程更加轻量级的存在。普通线程是抢先式的，会争夺 cpu 资源，而协程是合作的，可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。它的运行流程大致如下：</p><ol><li>协程<code>A</code>开始执行</li><li>协程<code>A</code>执行到某个阶段，进入暂停，执行权转移到协程<code>B</code></li><li>协程<code>B</code>执行完成或暂停，将执行权交还<code>A</code></li><li>协程<code>A</code>恢复执行</li></ol><p>协程遇到<code>yield命令</code>就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除 yield 命令，简直一模一样。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> result1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> result2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token string">"world"</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> result1 <span class="token operator">+</span> result2<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{value : 'hello', done : false}</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{value : 'world', done : false}</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{value : 3, done: true}</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//{value : undefined, done: true}</span></code></pre><hr><h2 id="闭包、垃圾回收和内存泄漏"><a href="#闭包、垃圾回收和内存泄漏" class="headerlink" title="闭包、垃圾回收和内存泄漏"></a>闭包、垃圾回收和内存泄漏</h2><h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p><strong>闭包就是能够读取其他函数内部变量的函数</strong>。由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”<strong>定义在一个函数内部的函数</strong>“。</p><h3 id="一、变量的作用域"><a href="#一、变量的作用域" class="headerlink" title="一、变量的作用域"></a>一、变量的作用域</h3><p>要理解闭包，首先必须理解 Javascript 特殊的变量作用域。<br>变量的作用域无非就是两种：全局变量和局部变量。<br>Javascript 语言的特殊之处，就在于函数内部可以直接读取全局变量。<br>在函数外部自然无法读取函数内的局部变量，函数内部声明变量的时候，一定要使用 var 命令。如果不用的话，实际上声明了一个全局变量！</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error</span><span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  n <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span><span class="token punctuation">}</span>consoel<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//999</span></code></pre><h3 id="二、如何从外部读取局部变量？"><a href="#二、如何从外部读取局部变量？" class="headerlink" title="二、如何从外部读取局部变量？"></a>二、如何从外部读取局部变量？</h3><p>“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> f2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们不就可以在 f1 外部读取它的内部变量了吗！</p></blockquote><h3 id="三、闭包的用途"><a href="#三、闭包的用途" class="headerlink" title="三、闭包的用途"></a>三、闭包的用途</h3><ul><li>闭包可以用在许多地方。它的最大用处有两个<ul><li>一个是前面提到的可以读取函数内部的变量</li><li>另一个就是让这些变量的值始终保持在内存中。</li></ul></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span>  nAdd <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    n <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> f2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 999</span><span class="token function">nAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1000</span></code></pre><blockquote><p>在这段代码中，result 实际上就是闭包 f2 函数。它一共运行了两次，第一次的值是 999，第二次的值是 1000。这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除。<br>为什么会这样呢？原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。<br>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量。其次，nAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。</p></blockquote><h3 id="四、使用闭包的注意点"><a href="#四、使用闭包的注意点" class="headerlink" title="四、使用闭包的注意点"></a>四、使用闭包的注意点</h3><blockquote><p><strong>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，**</strong>在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除*<strong>*。</strong><br>**<br><strong>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</strong></p></blockquote><h3 id="五、闭包常见的情况"><a href="#五、闭包常见的情况" class="headerlink" title="五、闭包常见的情况"></a>五、闭包常见的情况</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"The Window"</span><span class="token punctuation">;</span><span class="token keyword">var</span> object <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"My Object"</span><span class="token punctuation">,</span>  getNameFunc<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>object<span class="token punctuation">.</span><span class="token function">getNameFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//The Window</span></code></pre><blockquote></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"The Window"</span><span class="token punctuation">;</span><span class="token keyword">var</span> object <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">"My Object"</span><span class="token punctuation">,</span>  getNameFunc<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> that<span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>object<span class="token punctuation">.</span><span class="token function">getNameFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//My object</span></code></pre><h3 id="闭包的高级写法"><a href="#闭包的高级写法" class="headerlink" title="闭包的高级写法"></a><strong>闭包的高级写法</strong></h3><p>上面的写法其实是最原始的写法，而在实际应用中，会将闭包和匿名函数联系在一起使用。下面就是一个闭包常用的写法：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>document<span class="token punctuation">)</span> <span class="token punctuation">{</span>  varviewport<span class="token punctuation">;</span>  varobj <span class="token operator">=</span> <span class="token punctuation">{</span>    init<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>      viewport <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#"</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    addChild<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>      viewport<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    removeChild<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>      viewport<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  window<span class="token punctuation">.</span>jView <span class="token operator">=</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个组件的作用是：初始化一个容器，然后可以给这个容器添加子容器，也可以移除一个容器。<br>功能很简单，但这里涉及到了另外一个概念：立即执行函数。 简单了解一下就行，需要重点理解的是这种写法是如何实现闭包功能的。<br>可以将上面的代码拆分成两部分：<strong>(function(){})</strong> 和** **<strong>()</strong> 。<br>第 1 个*<em>() *</em>是一个表达式，而这个表达式本身是一个匿名函数，所以在这个表达式后面加 *<em>() \</em>*就表示执行这个匿名函数。<br>因此这段代码执行执行过程可以分解如下：</p><pre class=" language-javascript"><code class="language-javascript">varf <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>document<span class="token punctuation">)</span> <span class="token punctuation">{</span>  varviewport<span class="token punctuation">;</span>  varobj <span class="token operator">=</span> <span class="token punctuation">{</span>    init<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>      viewport <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#"</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    addChild<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>      viewport<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    removeChild<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>      viewport<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  window<span class="token punctuation">.</span>jView <span class="token operator">=</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在这段代码中似乎看到了闭包的影子，但 f 中没有任何返回值，似乎不具备闭包的条件，注意这句代码：</p><pre class=" language-javascript"><code class="language-javascript">window<span class="token punctuation">.</span>jView <span class="token operator">=</span> obj<span class="token punctuation">;</span></code></pre><p>obj 是在函数 f 中定义的一个对象，这个对象中定义了一系列方法， 执行 window.jView = obj 就是在 window 全局对象定义了一个变量 jView，并将这个变量指向 obj 对象，即全局变量 jView 引用了 obj . 而 obj 对象中的函数又引用了函数 f 中的变量 viewport ,因此函数 f 中的 viewport 不会被 GC 回收，viewport  会一直保存到内存中，所以这种写法满足了闭包的条件。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>这是对闭包最简单的理解，当然闭包还有其更深层次的理解，这个就涉及的多了，你需要了解 JS 的执行环境(execution context)、活动对象(activation object)以及作用域(scope)和作用域链(scope chain)的运行机制。</p><hr><h2 id="冒泡事件和捕获事件"><a href="#冒泡事件和捕获事件" class="headerlink" title="冒泡事件和捕获事件"></a>冒泡事件和捕获事件</h2><h3 id="冒泡事件：（由内-gt-外）"><a href="#冒泡事件：（由内-gt-外）" class="headerlink" title="冒泡事件：（由内-&gt;外）"></a>冒泡事件：（由内-&gt;外）</h3><p>微软提出了名为<strong>事件冒泡</strong>(event bubbling)的事件流。事件会从最内层的元素开始发生，一直向上传播，直到 document 对象。<br><strong>p -&gt; div -&gt; body -&gt; html -&gt; document</strong></p><h3 id="事件捕获（由外-gt-内）"><a href="#事件捕获（由外-gt-内）" class="headerlink" title="事件捕获（由外-&gt;内）"></a>事件捕获（由外-&gt;内）</h3><p>网景提出另一种事件流名为<strong>事件捕获</strong>(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到<strong>最具体的元素</strong>。<br><strong>事件冒泡和事件捕获过程图：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1597280637497-1413d9de-e58a-4499-8fd1-c3cf40af2a07.png#align=left&display=inline&height=357&margin=%5Bobject%20Object%5D&name=image.png&originHeight=357&originWidth=394&size=45332&status=done&style=none&width=394" alt="image.png"></p><h2 id="文章引用："><a href="#文章引用：" class="headerlink" title="文章引用："></a>文章引用：</h2><p><a href="https://segmentfault.com/a/1190000015727237" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015727237</a><br><a href="https://juejin.im/post/6844903696111763470#heading-3" target="_blank" rel="noopener">https://juejin.im/post/6844903696111763470</a><br><a href="https://juejin.im/post/6844903767226351623" target="_blank" rel="noopener">https://juejin.im/post/6844903767226351623</a><br><a href="https://www.jianshu.com/p/895422b87c7b" target="_blank" rel="noopener">https://www.jianshu.com/p/895422b87c7b</a><br><a href="https://juejin.im/post/6844903960910757902" target="_blank" rel="noopener">https://juejin.im/post/6844903960910757902</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 解决GitHub速度慢问题</title>
      <link href="/leader755/30871.html"/>
      <url>/leader755/30871.html</url>
      
        <content type="html"><![CDATA[<h2 id="解决方案是修改-hosts，按照以下三步来操作"><a href="#解决方案是修改-hosts，按照以下三步来操作" class="headerlink" title="解决方案是修改 hosts，按照以下三步来操作"></a>解决方案是修改 hosts，按照以下三步来操作</h2><h3 id="1-打开-hosts-文件："><a href="#1-打开-hosts-文件：" class="headerlink" title="1.打开 hosts 文件："></a>1.打开 hosts 文件：</h3><p>终端执行, MacOS 的登录用户不是 root，没有最高权限。修改一些系统保护的资源时，需要临时切换到 root 用户。root 具有最高权限，可以做任何事情。此时需要使用 sudo 命令。</p><pre class=" language-javascript"><code class="language-javascript">sudo vim <span class="token operator">/</span>etc<span class="token operator">/</span>hosts</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1596597386450-28553ab4-298d-455b-bbc7-c1f86aa7a0b8.png#align=left&display=inline&height=362&margin=%5Bobject%20Object%5D&name=image.png&originHeight=724&originWidth=1120&size=236848&status=done&style=none&width=560" alt="image.png"></p><h3 id="2-获取-github-的-ip"><a href="#2-获取-github-的-ip" class="headerlink" title="2.获取 github 的 ip"></a>2.获取 github 的 ip</h3><pre><code> 浏览器访问[https://www.ipaddress.com/](https://www.ipaddress.com/),分别输入以下 ip:(ip 以自己查到为准)</code></pre><blockquote><p>github.com<br>github.global.ssl.fastly.net<br>codeload.github.com</p></blockquote><p>获取到的对应的 ip，将以下追加到 host 文件后面。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">140.82</span><span class="token punctuation">.</span><span class="token number">113.4</span>    github<span class="token punctuation">.</span>com<span class="token number">199.232</span><span class="token punctuation">.</span><span class="token number">69.194</span>  github<span class="token punctuation">.</span>global<span class="token punctuation">.</span>ssl<span class="token punctuation">.</span>fastly<span class="token punctuation">.</span>net<span class="token number">140.82</span><span class="token punctuation">.</span><span class="token number">114.9</span>    codeload<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com</code></pre><blockquote><p>mac 上使用 vim 命令进行修改保存：<br>在输入 sudo vim /etc/hosts，进入页面后，按 o 建，进行输入，修改完成后按 ESC 建，:wq 保存退出。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1596598235246-bf1c3ead-123e-4339-8f4e-7e6bec14c5d7.png#align=left&display=inline&height=360&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=1200&size=246307&status=done&style=none&width=600" alt="image.png"></p><h3 id="3-Mac-系统刷新-DNS-缓存，Windows-系统命令自行查找"><a href="#3-Mac-系统刷新-DNS-缓存，Windows-系统命令自行查找" class="headerlink" title="3.Mac 系统刷新 DNS 缓存，Windows 系统命令自行查找."></a>3.Mac 系统刷新 DNS 缓存，Windows 系统命令自行查找.</h3><pre class=" language-javascript"><code class="language-javascript">sudo killall <span class="token operator">-</span>HUP mDNSResponder</code></pre><h3 id="4-可以试试-github-的访问速度了"><a href="#4-可以试试-github-的访问速度了" class="headerlink" title="4.可以试试 github 的访问速度了"></a>4.可以试试 github 的访问速度了</h3>]]></content>
      
      
      <categories>
          
          <category> 访问速度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试（1）H5+css</title>
      <link href="/leader755/2877.html"/>
      <url>/leader755/2877.html</url>
      
        <content type="html"><![CDATA[<h2 id="HTML-amp-CSS："><a href="#HTML-amp-CSS：" class="headerlink" title="HTML&amp;CSS："></a>HTML&amp;CSS：</h2><ul><li><p>浏览器内核</p></li><li><p>盒模型、flex 布局、两/三栏布局、水平/垂直居中；</p></li><li><p>BFC、清除浮动；</p></li><li><p>css3 的选择器；css 的继承</p></li><li><p>css3 动画、H5 新特性。</p></li></ul><h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><p><strong>主流浏览器有五大款，分别是 IE、Firefox、Google Chrome、Safari、Opera。</strong><br><strong>最常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。</strong></p><ul><li>IE/Eadge 浏览器：Trident 内核</li><li>chrome 浏览器：Webkit/Blink 内核</li><li>FirefoxL 浏览器：Gecko 内核</li><li>Safari 浏览器：Webkit 内核</li><li>Opera 浏览器： Presto 内核</li></ul><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>CSS<strong>盒模型</strong>本质上<strong>是</strong>一个盒子，封装周围的 HTML 元素，它包括：边距，边框，填充，和实际内容，可以简单表述为 盒模型由 content，padding，margin，border 几部分组成。<br>盒模型=标准盒模型+IE 盒模型<br>标准盒模型：<strong>标准盒模型下盒子的大小</strong>  =** width(content)** + <strong>border</strong> + <strong>padding</strong> + <strong>margin;</strong><br><strong>IE 盒模型：  IE 盒模型下盒子的大小=width（content + border + padding） + margin;</strong><br><strong>CSS 如何设置标准模型和 IE 模型:</strong></p><blockquote><p>如果 doctype 协议缺失，会由浏览器自己界定，在 IE 浏览器中 IE9 以下（IE6.IE7.IE8）的版本触发怪异模式，其他浏览器中会默认为 W3c 标准模式。</p></blockquote><p>box-sizing: content-box;  标准盒模型<br>box-sizing: border-box;  IE 盒模型</p><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC:"></a>BFC:</h3><p>块级格式化上下文</p><blockquote><p><strong>BFC 布局规则是？</strong></p><ol><li>内部的 Box 会在垂直方向，一个接一个地放置。</li><li>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li><li>BFC 的区域不会与 float box 重叠。</li><li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算 BFC 的高度时，浮动元素也参与计算</li></ol></blockquote><blockquote></blockquote><h1 id="只要元素满足下面任一条件即可触发-BFC-特性："><a href="#只要元素满足下面任一条件即可触发-BFC-特性：" class="headerlink" title="只要元素满足下面任一条件即可触发 BFC 特性："></a>只要元素满足下面任一条件即可触发 BFC 特性：</h1><blockquote><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul></blockquote><blockquote></blockquote><h1 id="BFC-常见作用"><a href="#BFC-常见作用" class="headerlink" title="BFC 常见作用"></a><strong>BFC 常见作用</strong></h1><blockquote><p><strong>阻止外边距 margin 折叠塌陷</strong></p></blockquote><blockquote><p>1、阻止外边距折叠 margin 塌陷问题：在标准文档流中，块级标签之间竖直方向的 margin 会以大的为准，这就是 margin 的塌陷现象。可以用 overflow：hidden 产生 bfc 来解决。</p></blockquote><h1 id="阻止元素被浮动元素覆盖和高度坍塌"><a href="#阻止元素被浮动元素覆盖和高度坍塌" class="headerlink" title="阻止元素被浮动元素覆盖和高度坍塌"></a>阻止元素被浮动元素覆盖和高度坍塌</h1><blockquote><ol start="2"><li>阻止浮动元素造成的父级元素高度坍塌问题和遮挡其他元素问题 高度塌陷问题，这时就可以用 BFC 来清除浮动了。**</li></ol></blockquote><p>**<br>** <strong>[</strong>点击查看 BFC 块级上下文演示案例**](//code.h5jun.com/bajo/8/embed?html,css)</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>利用 clear:both; 清除浮动</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>  <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>利用伪类：after 清除浮动</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/*万能清除浮动代码*/</span><span class="token selector"><span class="token class">.clearfix</span><span class="token pseudo-element">:after</span> </span><span class="token punctuation">{</span>  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*添加一个看不见的元素*/</span>  <span class="token property">visibility</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>  <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.clearfix</span> </span><span class="token punctuation">{</span>  <span class="token property">zoom</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*兼容 ie*/</span><span class="token punctuation">}</span></code></pre><p>利用 overflow:hidden;</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>**</p><h3 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h3><p>Flexible Box 模型，通常被称为 flexbox，是一种弹性布局。</p><h3 id="css-两栏布局、三栏布局"><a href="#css-两栏布局、三栏布局" class="headerlink" title="css 两栏布局、三栏布局"></a>css 两栏布局、三栏布局</h3><h4 id="两栏布局，已知左侧宽度，右边自适应"><a href="#两栏布局，已知左侧宽度，右边自适应" class="headerlink" title="两栏布局，已知左侧宽度，右边自适应"></a>两栏布局，已知左侧宽度，右边自适应</h4><p>1&gt; 双 inline-block  左右盒子均设置为 display：inline-block; 左盒子设置固定宽高，右盒子使用 calc(100% - width 左);</p><p>2&gt;使用浮动双 float  左盒子浮动，右盒子浮动，右盒子宽度设置用 calc(100% - width 左)可以无缝衔接不会有被覆盖的内容。</p><p>3&gt;使用定位双定位 在左右盒子外侧设置一个大盒子，不必设置大盒子的宽高，直接设置 position:relative;左盒子设置 position:absolute;固定宽高，右盒子设置 position:absolute;left:width 左;width:calc(100% - width 左)可实现无缝衔接。</p><p>4&gt;使用定位单定位   左盒子设置绝对定位，设置右盒子 margin-left:width(左)，右盒子不必设置宽度。</p><p>5&gt;使用 flex 布局   外侧盒子 display:flex;align-items:flex-start/center;左盒子设置宽高即可，右盒子 flex:1 1 auto;右盒子设置为放大缩小均为 1，占据空间是剩下的空间。</p><p>6&gt;.使用 grid 网格   外层盒子设置 display:grid;grid-template-rows:100px;grid-template-columns:100px auto;设置了一行两列的网格，且右边网格的大小自适应。</p><p>7&gt;BFC 外侧盒子设置为 overflow:auto，内部左盒子设置 float:left;对左侧进行浮动，继续设置左侧盒子的大小，右盒子设置 overflow:auto;对左盒子触发 BFC，右盒子触发 BFC，左盒子设置右外边距，右盒子设置左外边距(不设置也可)，右盒子不需要设置 width;</p><h4 id="三栏布局，已知左右侧宽度，中间自适应"><a href="#三栏布局，已知左右侧宽度，中间自适应" class="headerlink" title="三栏布局，已知左右侧宽度，中间自适应"></a>三栏布局，已知左右侧宽度，中间自适应</h4><p>1.<strong>使用定位</strong> 三个盒子外侧设置大盒子，大盒子使用相对定位，下面一层三个盒子均采用绝对定位，左盒子固定宽高，右盒子固定宽高并设置<code>right: 0px;</code>使右盒子靠右，中间盒子设置<code>width: calc(100% - width左-width右相加);</code>即可。</p><p>2.<strong>使用浮动</strong>  左盒子设置左浮动，右盒子设置右浮动，中间盒子设置<code>margin:auto;display: inline-block;width: calc(100% - width左 - width 右);</code>无缝衔接<code>margin:auto;</code>在这里不管左右盒子是否一样大都可。</p><p>3&gt;<strong>使用 grid 网格</strong>  设置外层盒子为<code>display:grid;grid-template-rows:100px;grid-template-columns:100px auto 100px;</code>即可。grid 网格好厉害！！！</p><p>4&gt;<strong>使用 flex</strong>  设置外层盒子为<code>display:flex;align-items:center</code>中间盒子设置<code>flex:1 1 auto</code>左右盒子在盒子内部设置内容有大小即可。</p><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><p>需求：</p><ul><li>1.两边固定，中间自适应；</li><li>2.先加载 middle 内容；</li><li>3.三列等高布局；</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>middle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>middle<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>middle<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>middle<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">  <span class="token selector"><span class="token id">#content</span> </span><span class="token punctuation">{</span>    <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">500</span>px<span class="token punctuation">;</span> //设置总宽度    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">150</span>px <span class="token number">0</span> <span class="token number">100</span>px<span class="token punctuation">;</span> //为左右<span class="token number">2</span>侧留出空间  <span class="token punctuation">}</span>  <span class="token selector"><span class="token id">#left</span>,  <span class="token id">#right</span> </span><span class="token punctuation">{</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token id">#middle</span> </span><span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token id">#middle</span>,  <span class="token id">#left</span>,  <span class="token id">#right</span> </span><span class="token punctuation">{</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>    <span class="token property">padding-bottom</span><span class="token punctuation">:</span> <span class="token number">10000</span>px<span class="token punctuation">;</span>    <span class="token property">margin-bottom</span><span class="token punctuation">:</span> -<span class="token number">10000</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token id">#left</span> </span><span class="token punctuation">{</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 偏移的距离和宽度 */</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token id">#right</span> </span><span class="token punctuation">{</span>    <span class="token property">margin-right</span><span class="token punctuation">:</span> -<span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>    <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">150</span>px<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*偏移的距离和宽度*/</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">150</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><p>还有一件事就是他们在单独部分内容扩充的时候，童鞋们可能发现了 底部会参差不齐。</p><blockquote><p>给 left、middle、right 设置上 padding-bottom: 9999px; margin-bottom: -9999px;</p></blockquote><p><a href="//code.h5jun.com/puja/33/edit?html,css,output" target="_blank" rel="noopener"><strong>点击查看圣杯布局演示案例</strong></a></p><h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>需求：</p><ul><li>1.两边固定，中间自适应；</li><li>2.先加载 middle 内容；</li><li>3.三列等高布局；</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>middle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>middle<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">  <span class="token comment" spellcheck="true">/*float流*/</span>  <span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>    <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">500</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.left</span>,  <span class="token class">.middle</span>,  <span class="token class">.right</span> </span><span class="token punctuation">{</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>    <span class="token property">min-height</span><span class="token punctuation">:</span> <span class="token number">130</span>px<span class="token punctuation">;</span>    <span class="token property">padding-bottom</span><span class="token punctuation">:</span> <span class="token number">9999</span>px<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*解决底部参差不齐的问题**/</span>    <span class="token property">margin-bottom</span><span class="token punctuation">:</span> -<span class="token number">9999</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.middle</span> </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">100%</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*右侧设置宽度和距离*/</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">220</span>px<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*右侧设置宽度和距离*/</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">220</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.inner</span> </span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">220</span>px <span class="token number">0</span> <span class="token number">200</span>px<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*用middle 内部的元素通过 margin 留出空间**/</span>    <span class="token property">min-height</span><span class="token punctuation">:</span> <span class="token number">130</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>  <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    middle  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sub<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>extra<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">  <span class="token comment" spellcheck="true">/*双飞翼 flex布局*/</span>  <span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.sub</span> </span><span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.main</span> </span><span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.extra</span> </span><span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.main</span> </span><span class="token punctuation">{</span>    <span class="token property">flex-grow</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*自动占满剩余空间*/</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.sub</span> </span><span class="token punctuation">{</span>    <span class="token property">flex</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">150</span>px<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*指定宽度，方压缩*/</span>    <span class="token property">order</span><span class="token punctuation">:</span> -<span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*越小越靠前*/</span>  <span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.extra</span> </span><span class="token punctuation">{</span>    <span class="token property">flex</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">200</span>px<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*指定宽度，方压缩*/</span>    <span class="token property">order</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*越大越靠后*/</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/*    flex=>flex-grow:是否占满剩余空间,flex-shrink：是否压缩,flex-basis: 基准宽度    */</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><p><a href="//code.h5jun.com/yenew/edit?html,css,output" target="_blank" rel="noopener"><strong>双飞翼布局 float 流演示案例</strong></a><br><a href="//code.h5jun.com/xogos/edit?html,css,output" target="_blank" rel="noopener"><strong>双飞翼布局 flex 流演示案例</strong></a><br>**</p><blockquote><p>总结：</p><ul><li>相同点：</li></ul><p>圣杯布局和双飞翼布局解决的问题是一样的，就是两边顶宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。<br>圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部 float 浮动，但左右两栏加上负 margin 让其跟中间栏 div 并排，以形成三栏布局。</p></blockquote><blockquote><ul><li>不同点：</li></ul><ol><li>双飞翼布局给主面板添加了一个父标签用来通过 margin 给子面板腾出空间。</li><li>圣杯采用的是 padding，而双飞翼采用的 margin，解决了圣杯布局的问题。</li><li>双飞翼布局不用设置相对布局，以及对应的 left 和 right 值。</li></ol></blockquote><h3 id="水平-垂直居中"><a href="#水平-垂直居中" class="headerlink" title="水平/垂直居中"></a>水平/垂直居中</h3><h4 id="1-绝对定位-margin-auto"><a href="#1-绝对定位-margin-auto" class="headerlink" title="1.绝对定位+margin:auto"></a>1.绝对定位+margin:auto</h4><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">div </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-绝对定位-负-margin"><a href="#2-绝对定位-负-margin" class="headerlink" title="2.绝对定位+负 margin"></a>2.绝对定位+负 margin</h4><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">div </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> -<span class="token number">100</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="3-绝对定位-transform"><a href="#3-绝对定位-transform" class="headerlink" title="3.绝对定位+transform"></a>3.绝对定位+transform</h4><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">div </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 定位父级的50% */</span>  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-<span class="token number">50%</span>, -<span class="token number">50%</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*自己的50% */</span><span class="token punctuation">}</span></code></pre><h4 id="4-flex-布局"><a href="#4-flex-布局" class="headerlink" title="4.flex 布局"></a>4.flex 布局</h4><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">600</span>px<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span> //子元素水平居中  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span> //子元素垂直居中  <span class="token comment" spellcheck="true">/* aa只要三句话就可以实现不定宽高水平垂直居中。 */</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.box</span> > div </span><span class="token punctuation">{</span>  <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>**</p><h4 id="5-table-cell-实现居中"><a href="#5-table-cell-实现居中" class="headerlink" title="5.table-cell 实现居中"></a>5.table-cell 实现居中</h4><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;div  class="outter"  > &lt;div  class="inner"  > &lt;div  class="foo"  > 999  &lt;/div  > &lt;div  > &lt;/div  > <span class="token class">.outter</span> </span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/**定义最外层盒子的 table(非必须)，使用百分比时使用*/</span>  <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.inner</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*控制子元素垂直居中*/</span>  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.foo</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*必须为行内元素*/</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="css-的选择器"><a href="#css-的选择器" class="headerlink" title="css 的选择器"></a>css 的选择器</h3><ul><li><p>标签选择器，类选择器，id 选择器，后代选择器，</p></li><li><p>属性选择器：属性选择器的标志性符号是  []，匹配含义：^：开头 $：结尾 *：包含。E[title=”abc”]选中页面的 E 元素，并且 E 需要带有 title 属性，且属性值完全等于 abc。</p></li><li><p>结构伪类选择器：</p><table><thead><tr><th>选择符号</th><th>含义</th><th>相同点</th></tr></thead><tbody><tr><td>E:first-child</td><td>匹配父元素的第一个子元素 E</td><td>带有 child，以 E 元素的父元素为参考</td></tr><tr><td>E:last-child</td><td>匹配父元素的最后一个子元素 E</td><td></td></tr><tr><td>E:nth-child(n)</td><td>匹配父元素的第 n 个子元素 E</td><td></td></tr><tr><td>E:nth-child(odd)</td><td>匹配奇数</td><td></td></tr><tr><td>E:nth-child(even)</td><td>匹配偶数</td><td></td></tr><tr><td>E:nth-last-child(n)</td><td>匹配父元素的倒数第 n 个子元素 E</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>E:first-of-type</td><td>匹配同类型中的第一个同级兄弟元素 E。</td><td>带有 type，我们可以这样理解：先在同级里找到所有的 E 类型，然后根据 n 进行匹配。</td></tr><tr><td>E:last-of-type</td><td>匹配同类型中的最后一个同级兄弟元素 E。</td><td></td></tr><tr><td>E:nth-of-type(n)</td><td>匹配同类型中的第 n 个同级兄弟元素 E。</td><td></td></tr><tr><td>E:nth-last-of-type(n)</td><td>匹配同类型中的倒数第 n 个同级兄弟元素 E。</td><td></td></tr></tbody></table></li><li><p>伪元素选择器：</p><ul><li><p><code>E::before</code> 设置在 元素 E 前面（依据对象树的逻辑结构）的内容，配合 content 属性一起使用。</p></li><li><p><code>E::after</code> 设置在 元素 E 后面（依据对象树的逻辑结构）的内容，配合 content 属性一起使用。</p></li></ul></li></ul><p>点击查看详细：<a href="https://www.cnblogs.com/qianguyihao/p/8426799.html" target="_blank" rel="noopener">https://www.cnblogs.com/qianguyihao/p/8426799.html</a></p><p>###</p><h3 id="position-的值"><a href="#position-的值" class="headerlink" title="position 的值"></a>position 的值</h3><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">absolute</td><td align="left">生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</td></tr><tr><td align="left">fixed</td><td align="left">生成绝对定位的元素，相对于浏览器窗口进行定位。</td></tr><tr><td align="left">relative</td><td align="left">生成相对定位的元素，相对于其正常位置进行定位。</td></tr><tr><td align="left">sticky</td><td align="left">粘性吸顶布局</td></tr></tbody></table><h3 id="css-的继承性的属性："><a href="#css-的继承性的属性：" class="headerlink" title="css 的继承性的属性："></a>css 的继承性的属性：</h3><table><thead><tr><th>类型</th><th>继承属性</th></tr></thead><tbody><tr><td>字体系列属性</td><td>font：组合字体；</td></tr></tbody></table><p>font-family：字体系列<br>font-family：字体系列<br>font-weight：设置字体的粗细<br>font-size：设置字体的尺寸<br>font-style：定义字体的风格 |<br>| 文本系列属性 | text-indent：文本缩进<br>text-align：文本水平对齐<br>text-shadow：设置文本阴影<br>line-height：行高<br>word-spacing：字间隔<br>letter-spacing：字符间距<br>direction：规定文本的书写方向<br>color：文本颜色 |<br>| 元素可见性 | visibility |<br>| 列表属性 | list-style-type |<br>| 光标属性 | cursor |</p><h3 id="css-动画"><a href="#css-动画" class="headerlink" title="css 动画"></a>css 动画</h3><p>可以参考<a href="https://juejin.im/post/6844903845470945294" target="_blank" rel="noopener">https://juejin.im/post/6844903845470945294</a></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1597274198391-d9f1533b-f045-4a81-a964-52dbb24b0f35.png#align=left&display=inline&height=476&margin=%5Bobject%20Object%5D&name=image.png&originHeight=642&originWidth=482&size=127188&status=done&style=none&width=357" alt="image.png"></p><p>animation: move 2s linear 3 alternate both;</p><table><thead><tr><th align="left"><em>animation-name（</em> keyframe 动画名称<em>）</em></th><th align="left"><em>animation-duration（动画持续时间）</em></th><th><em>animation-timing-function  指定动画计时函数，即动画的速度曲线</em></th><th align="left"><em>animation-delay （运动延迟）单位 s</em></th><th align="left">animation-iteration-count (动画播放的次数,默认 1)</th><th align="left">animation-direction（动画播放的方向。）</th><th align="left">animation-fill-mode 指定动画填充模式。</th><th align="left"><strong>animation-play-state**</strong>（**指定动画播放状态，正在运行或暂停。)</th></tr></thead><tbody><tr><td align="left"></td><td align="left"></td><td>ease（默认值）</td><td align="left">0（默认延迟 0s）</td><td align="left">1（动画播放默认的次数为 1）</td><td align="left">normal  （默认值）</td><td align="left">none（默认值，回到动画没开始时的状态。）</td><td align="left">running 通过 running 将暂停的动画重新播放（默认值）</td></tr><tr><td align="left"></td><td align="left"></td><td>linear 匀速动画</td><td align="left"></td><td align="left">```</td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>number (设置播放的次数）</p><pre><code></code></pre><pre><code> | reverse | forwards：动画完成后，元素状态保持为最后一帧的状态。 | paused 通过paused将正在播放的动画停下了 ||  |  | ease-in |  | `infinite  (无限播放)` | alternate | backwards：表示，有动画延迟时，动画开始前，元素状态保持为第一帧的状态。 |  ||  |  | ease-out |  |  | alternate | both: 表示上述二者效果都有 |  ||  |  | ease-in-out |  |  | alternate-reverse |  |  ||  |  | `cubic-bezier(n,n,n,n)` 的特例。它们被称为贝塞尔曲线  ([https://cubic-bezier.com/](https://cubic-bezier.com/#.17,.67,.83,.67)) |  |  |  |  |  |### css 动画和 js 动画的区别：#### CSS3动画的优点和缺点优点：1. CSS3动画在性能上会稍微好一些，浏览器会对CSS3的动画做一些优化(比如专门新建一个图层用来跑动画)1. 代码相对简单缺点：1. 在动画控制上不够灵活1. 兼容性不好1. 部分动画功能无法实现(如滚动动画，视差滚动等)#### JS动画的优缺点优点：JavaScript动画正好弥补了这两个缺点。1. 控制能力强，可以单帧的控制和变换1. 写的好，写的好的话，完全可以兼容IE6缺点：1.JS运算预渲染性能不如CSS3动画，因为CSS动画的transform矩阵，是C++级的，必然要比JavaScript级的计算要快2. 还有就是对库比较依赖2. 编码较为繁琐#### 综上所述- 对于一些需要复杂控制的动画，使用JavaScript比较靠谱- 如果是一些小的，简单的动画，就使用CSS3动画### H5新特性#### 新特性1.语意特性,添加`&lt;header&gt;&lt;header/&gt;&lt;nav&gt;&lt;nav&gt;`等标签2.多媒体， 用于媒介回放的 video 和 audio 元素3.图像效果，用于绘画的 canvas 元素，svg元素等4.离线 &amp; 存储,对本地离线存储的更好的支持,local Store,Cookies等5.设备兼容特性 ，HTML5提供了前所未有的数据与应用接入开放接口。使外部应用可以直接与浏览器内部的数据直接相连，6.连接特性，更有效的连接工作效率，使得基于页面的实时聊天，更快速的网页游戏体验，更优化的在线交流得到了实现。HTML5拥有更有效的服务器推送技术，Server-Sent Event和WebSockets就是其中的两个特性，这两个特性能够帮助我们实现服务器将数据“推送”到客户端的功能7.性能与集成特性，HTML5会通过XMLHttpRequest2等技术，帮助您的Web应用和网站在多样化的环境中更快速的工作#### 新增标签1.多媒体：`&lt;audio&gt;&lt;/audio&gt;, &lt;video&gt;&lt;video&gt;,&lt;source&gt;&lt;/source&gt;, &lt;embed&gt;&lt;/embed&gt;, &lt;track&gt;&lt;/track&gt;`2.新表单元素：`&lt;datalist&gt; ,&lt;output&gt; , &lt;keygen&gt;`3.新文档节段和纲要:`&lt;header&gt;页面头部、&lt;section&gt;章节、&lt;aside&gt;边栏、&lt;article&gt;文档内容、&lt;footer&gt;页面底部、&lt;section&gt;章节、&lt;aside&gt;边栏、&lt;article&gt;文档内容、&lt;footer&gt;页面底部`等#### Input 有哪些新增类型？- color,选择颜色- date 选择日期- email 用于检测输入的是否为email格式的地址- month 选择月份- number  用于应该包含数值的输入域，可以设定对输入值的限定- range 用于定义一个滑动条，表示范围- search 用于搜索，比如站点搜索或 Google 搜索- tel 输入电话号码-time 选择时间- url 输入网址- week 选择周和年#### 浏览器本地存储中 cookie ，localStorage 有什么区别？#### session(sessionId)，token（令牌），cookie，sessionStorage，localStorage- 共同点：sessionStorage、localStorage和cookie都由浏览器存储在本地的数据，session 存储在服务端。- sessionStorage：页面关闭，缓存消失，最大 5M.- localStorage：除非手动删除，否则永远存在本地，最大 5M.- cookie：存储在客户端，最大4kb。   - **Cookie主要是由服务器生成**，且前端也可以设置，保存在客户端本地的一个文件，通过response响应头的set-Cookie字段进行设置，且Cookie的内容自动在请求的时候被传递给服务器。如下：![image.png](https://cdn.nlark.com/yuque/0/2020/png/241787/1596695630377-bc927c6f-e053-425f-a451-a8176853b439.png#align=left&amp;display=inline&amp;height=259&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=518&amp;originWidth=1474&amp;size=101224&amp;status=done&amp;style=none&amp;width=737)- session:   - session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie   - cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中   - 现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用   - 如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大- token   - token 也称作令牌，由uid+time+sign[+固定参数]   - token 的认证方式类似于**临时的证书签名**, 并且是一种服务端无状态的认证方式, 非常适合于 REST API  的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。   - token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中   - 一般 token 放入header 中#### 分布式情况下的session和tokensession是有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。- 负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。当今的几种[解决session负载均衡](http://blog.51cto.com/zhibeiwang/1965018)的方法。而token是无状态的，token字符串里就保存了所有的用户信息- 客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做[JWT(Json Web Token)](https://huanqiang.wang/2017/12/28/JWT%20%E4%BB%8B%E7%BB%8D/)&gt; 总结：&gt; - session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie&gt; - cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。&gt; - token也类似一个令牌，无状态，用户信息都被加密到token中，一般 token 放到请求头 header 中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。&gt; - jwt只是一个跨域认证的方案### 参考文章：[https://www.jianshu.com/p/c435f52fb95f](https://www.jianshu.com/p/c435f52fb95f)[https://juejin.im/post/6844903817104850952](https://juejin.im/post/6844903817104850952)[https://juejin.im/post/6844904000756809736](https://juejin.im/post/6844904000756809736)[https://www.jianshu.com/p/34044e3c9317](https://www.jianshu.com/p/34044e3c9317)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客的评论功能</title>
      <link href="/leader755/38478.html"/>
      <url>/leader755/38478.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-这里推荐的评论功能插件为valine"><a href="#1-这里推荐的评论功能插件为valine" class="headerlink" title="1.这里推荐的评论功能插件为valine"></a>1.这里推荐的评论功能插件为<a href="https://valine.js.org/" target="_blank" rel="noopener">valine</a></h2><p>官网：<a href="https://valine.js.org/" target="_blank" rel="noopener">https://valine.js.org/</a><br>注册登录网站：<a href="https://leancloud.cn/" target="_blank" rel="noopener">https://leancloud.cn/</a><br>      需要实名注册登记，可以使用支付宝来实名认证，很快的，秒过。</p><h2 id="2-去leancloud注册"><a href="#2-去leancloud注册" class="headerlink" title="2.去leancloud注册"></a>2.去<a href="https://leancloud.cn/" target="_blank" rel="noopener">leancloud</a>注册</h2><p>注册完成后去创建应用，选择开发版就可以了。（需要实名登记才能创建应用）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588779620815-f8a3fc6e-f667-4959-9cb2-53b5777427c7.png#align=left&display=inline&height=445&margin=%5Bobject%20Object%5D&name=image.png&originHeight=890&originWidth=1232&size=83220&status=done&style=none&width=616" alt="image.png"></p><h2 id="3-获取-appkey-和-appid"><a href="#3-获取-appkey-和-appid" class="headerlink" title="3.获取 appkey 和 appid"></a>3.获取 appkey 和 appid</h2><p>创建完成应用后，<strong>进入应用-&gt;设置-&gt;应用 key，找到相应的 appkey 和 appid。</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588779969891-d05a06f8-bcf5-4b7e-84cb-bcedabc8f762.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&name=image.png&originHeight=796&originWidth=2394&size=185376&status=done&style=none&width=746" alt="image.png"></strong></p><h2 id="4-配置主题文件-config-yml"><a href="#4-配置主题文件-config-yml" class="headerlink" title="4.配置主题文件_config.yml"></a>4.配置主题文件_config.yml</h2><p><strong>搜索 valine，一般可看到如下，将 enbled:true, 并填写 appid 和 appkey(从 leancloud 中获取的 appid 和 appkey)。</strong></p><pre class=" language-javascript"><code class="language-javascript"># The configuration <span class="token keyword">of</span> the Valine comment module is not activated by <span class="token keyword">default</span><span class="token punctuation">.</span># To use it<span class="token punctuation">,</span> activate the configuration item and <span class="token keyword">set</span> appId and appKey<span class="token punctuation">.</span># Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey<span class="token punctuation">.</span>valine<span class="token punctuation">:</span>  enable<span class="token punctuation">:</span> <span class="token boolean">true</span>  appId<span class="token punctuation">:</span>  appKey<span class="token punctuation">:</span>  notify<span class="token punctuation">:</span> <span class="token boolean">false</span>  verify<span class="token punctuation">:</span> <span class="token boolean">false</span>  visitor<span class="token punctuation">:</span> <span class="token boolean">true</span>  avatar<span class="token punctuation">:</span> <span class="token string">'mp'</span> # Gravatar style <span class="token punctuation">:</span> mp<span class="token operator">/</span>identicon<span class="token operator">/</span>monsterid<span class="token operator">/</span>wavatar<span class="token operator">/</span>retro<span class="token operator">/</span>hide  pageSize<span class="token punctuation">:</span> <span class="token number">10</span>  placeholder<span class="token punctuation">:</span> <span class="token string">'just go go'</span> # Comment Box placeholder  background<span class="token punctuation">:</span> <span class="token operator">/</span>medias<span class="token operator">/</span>comment_bg<span class="token punctuation">.</span>png</code></pre><h2 id="5-配置域名"><a href="#5-配置域名" class="headerlink" title="5.配置域名"></a>5.配置域名</h2><p>在 Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去.</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588780306061-73286643-1359-4efe-b2a1-5545f880dd4a.png#align=left&display=inline&height=500&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1000&originWidth=1804&size=166396&status=done&style=none&width=902" alt="image.png"></p><h2 id="6-重启你的博客"><a href="#6-重启你的博客" class="headerlink" title="6.重启你的博客"></a>6.重启你的博客</h2><p>大功告成！！</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> valine </tag>
            
            <tag> leancloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>travis-ci + github + hexo 持续集成</title>
      <link href="/leader755/34284.html"/>
      <url>/leader755/34284.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo-博客源代码-GitHub-托管"><a href="#Hexo-博客源代码-GitHub-托管" class="headerlink" title="Hexo 博客源代码 GitHub 托管"></a>Hexo 博客源代码 GitHub 托管</h2><h2 id="1-注册-travis-ci"><a href="#1-注册-travis-ci" class="headerlink" title="1.注册 travis-ci"></a>1.注册 travis-ci</h2><p>Travis CI 的网站有两个，<br><code>travis-ci.org</code>  专门针对开源项目，GitHub 上所有的公开仓库都能够免费使用；<br><code>travis-ci.com</code>  针对私有及商业项目，新用户前 100 次构建是免费的，后面就要收费了。</p><h2 id="2-登录-Travis-CI-网站"><a href="#2-登录-Travis-CI-网站" class="headerlink" title="2.登录 Travis CI 网站"></a>2.登录 Travis CI 网站</h2><ol><li>前往 <a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis-ci.com</a> and Sign up with GitHub.</li><li>接受授权</li><li>选择你想要使用 Travis CI 的仓库 或者 你也可以在 Github-settings-Applications-TravisCI-Configure 中去更新配置；</li><li>在你仓库怎增加 <code>.travis.yml</code> 文件，这个文件定义了构建的步骤，例如<a href="https://docs.travis-ci.com/user/job-lifecycle/#customizing-the-installation-phase" target="_blank" rel="noopener">安装依赖</a>等等。</li><li>将 <code>.travis.yml</code> 文件推送到你的远端仓库，然后就会触发 Travis CI 构建；</li><li>登录 <a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis CI</a>然后选择你的仓库查看构建任务的执行详情；</li></ol><h2 id="3-配置-Travis-CI"><a href="#3-配置-Travis-CI" class="headerlink" title="3.配置 Travis CI"></a>3.配置 Travis CI</h2><h4 id="1-gt-网页端配置"><a href="#1-gt-网页端配置" class="headerlink" title="1&gt;网页端配置"></a>1&gt;网页端配置</h4><p>首先进入 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI 官网</a>，这里我们使用的是免费版的，因为考虑到一般放在 GitHub 上的博客都是公开的，所以不需要付费版本。如果有私有仓库要使用这种方式，可以使用 <a href="https://travis-ci.com/" target="_blank" rel="noopener">付费版的 Travis CI</a>。然后直接通过 GitHub 账户登陆即可，登陆后可以看到我们的共有仓库，找到博客的仓库，我这里是选择 blog-master 源码仓库（博客仓库：leader755.github.io），把旁边的勾勾上，然后点击旁边的 <code>Settings</code> 进入设置页面。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1595728277292-624821ea-7b95-4db8-89fe-22ece79e75db.png#align=left&display=inline&height=457&margin=%5Bobject%20Object%5D&name=image.png&originHeight=914&originWidth=1686&size=85154&status=done&style=none&width=843" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1595728301454-068409c1-f596-4e35-aa3a-d9d2d3c5b39c.png#align=left&display=inline&height=527&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1054&originWidth=1752&size=108378&status=done&style=none&width=876" alt="image.png"></p><p>在设置页面中，General 中只勾选 <code>Build pushed branches</code>，表示当有新的代码 push 到 GitHub 仓库时，自动执行构建任务。其他设置保持默认即可。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1595728534111-16bc9014-0036-44ef-8036-8117eb15dffd.png#align=left&display=inline&height=532&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1064&originWidth=1910&size=135305&status=done&style=none&width=955" alt="image.png"></p><p>接下来为 Travis 添加对 GitHub 仓库的读写权限。进入 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal access tokens</a> 页面，点击 <code>Generate new token</code>，选择 token 权限(这里直选 repo 即可)，设置别名并生成。然后将生成的 token 值复制。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1595728617792-342093c6-0176-4ece-90e0-f1395c93d7cf.png#align=left&display=inline&height=645&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1290&originWidth=2304&size=230289&status=done&style=none&width=1152" alt="image.png"><br>接着在原来 Travis 的设置界面添加 token。如图所示：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1595728826735-1b3d72da-2248-4837-9c46-4b6ce410bfdf.png#align=left&display=inline&height=324&margin=%5Bobject%20Object%5D&name=image.png&originHeight=648&originWidth=2006&size=113373&status=done&style=none&width=1003" alt="image.png"><br>在 Name 中填入 token 的别名，Value 中填入刚刚得到的 token，然后点击 Add 进行添加即可。注意 token 一旦生成，只能在生成时得到其值，后面无法查看。所以如果还有需要，可以记下来或者重新生成新的 token。</p><h4 id="2-gt-Travis-配置文件"><a href="#2-gt-Travis-配置文件" class="headerlink" title="2&gt;Travis 配置文件"></a>2&gt;Travis 配置文件</h4><p>接下来还需要编写 Travis 的配置文件，用于指定构建时使用哪些命令。配置文件名为 <code>.travis.yml</code>，是自动化构建的配置文件。文件内容示例如下：</p><pre class=" language-javascript"><code class="language-javascript"># 指定构建环境是Node<span class="token punctuation">.</span>js，当前版本是稳定版 <span class="token punctuation">(</span>stable<span class="token punctuation">)</span><span class="token punctuation">,</span>版本这里我们选择最新的长期支持版本（ LTS） 应该就够用了anguage<span class="token punctuation">:</span> node_jsnode_js<span class="token punctuation">:</span>  <span class="token operator">-</span> lts<span class="token operator">/</span><span class="token operator">*</span>  # 稳定版 <span class="token punctuation">(</span>stable<span class="token punctuation">)</span> <span class="token punctuation">,</span>最新长期支持版（ <span class="token operator">-</span> lts<span class="token operator">/</span><span class="token operator">*</span> ）# 指定缓存模块，可加快编译速度cache<span class="token punctuation">:</span>  directories<span class="token punctuation">:</span>    <span class="token operator">-</span> node_modules# 在构建之前before_install<span class="token punctuation">:</span>  <span class="token operator">-</span> <span class="token keyword">export</span> TZ<span class="token operator">=</span><span class="token string">'Asia/Shanghai'</span> # 更改时区  <span class="token operator">-</span> npm install <span class="token operator">-</span>g hexo<span class="token operator">-</span>cli # 安装hexo环境#<span class="token function">部署环境的安装</span><span class="token punctuation">(</span>安装一个部署插件<span class="token punctuation">)</span>install<span class="token punctuation">:</span>  <span class="token operator">-</span> npm install  <span class="token operator">-</span> npm install hexo<span class="token operator">-</span>deployer<span class="token operator">-</span>git <span class="token operator">--</span>savebefore_script<span class="token punctuation">:</span> ## 执行清缓存，生成网页操作script<span class="token punctuation">:</span>  <span class="token operator">-</span> hexo clean <span class="token operator">&amp;&amp;</span> hexo gafter_script<span class="token punctuation">:</span>  # 未能成功  <span class="token operator">-</span> git config user<span class="token punctuation">.</span>name <span class="token string">"Leader755"</span>  <span class="token operator">-</span> git config user<span class="token punctuation">.</span>email <span class="token string">"1181012791@qq.com"</span>   # 替换同目录下的_config<span class="token punctuation">.</span>yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！  <span class="token operator">-</span> sed <span class="token operator">-</span>i <span class="token string">"s/gh_token/${GH_TOKEN}/g"</span> <span class="token punctuation">.</span><span class="token operator">/</span>_config<span class="token punctuation">.</span>yml  <span class="token operator">-</span> hexo deploy    # 版本 二（未能成功）  # <span class="token operator">-</span> cd <span class="token punctuation">.</span>deploy_git  # <span class="token operator">-</span> git checkout master  # <span class="token operator">-</span> cd <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>  # <span class="token operator">-</span> sed <span class="token operator">-</span>i<span class="token string">''</span> <span class="token string">"s~${GH_REF}~${GH_TOKEN}:x-oauth-basic@${GH_REF}~"</span> _config<span class="token punctuation">.</span>yml  # <span class="token operator">-</span> hexo d <span class="token operator">></span> log<span class="token punctuation">.</span>txt <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span>  # <span class="token operator">-</span> cat log<span class="token punctuation">.</span>txt <span class="token operator">|</span> sed <span class="token string">"自动构建Travis CI Auto Builder at $(date +'%Y-%m-%d %H:%M:%S')"</span>  # <span class="token operator">-</span> echo <span class="token string">"自动构建Travis CI Auto Builder at $(date +'%Y-%m-%d %H:%M:%S')"</span> # 构建后输出时间标识    # 版本三（能正常构建提交到博客 leader755<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io<span class="token punctuation">,</span>但是并不是使用 hexo d  命令触发的）    # after_script<span class="token punctuation">:</span>  # <span class="token operator">-</span> cd <span class="token punctuation">.</span><span class="token operator">/</span><span class="token keyword">public</span>  # <span class="token operator">-</span> git init  # <span class="token operator">-</span> git config user<span class="token punctuation">.</span>name <span class="token string">"your-git-name"</span>  # <span class="token operator">-</span> git config user<span class="token punctuation">.</span>email <span class="token string">"your-email-address"</span>  # <span class="token operator">-</span> git add <span class="token punctuation">.</span>  # <span class="token operator">-</span> git commit <span class="token operator">-</span>m <span class="token string">"Travis CI Auto Builder at $(date +'%Y-%m-%d %H:%M:%S')"</span>  # <span class="token operator">-</span> git push <span class="token operator">--</span>force <span class="token operator">--</span>quiet <span class="token string">"https://${GH_TOKEN}@${GH_REF}"</span> master<span class="token punctuation">:</span>master# 指定博客源码分支，Travis CI 监控哪一个分支的变动，这里是 master 分支（若博客备份文件和 GitHub Pages 共用一个仓库的话需设置为博客备份文件所在分支）。branches<span class="token punctuation">:</span>  only<span class="token punctuation">:</span>    <span class="token operator">-</span> master# End<span class="token punctuation">:</span> Build LifeCycle# configure notifications <span class="token punctuation">(</span>email<span class="token punctuation">,</span> IRC<span class="token punctuation">,</span> campfire etc<span class="token punctuation">)</span># please update <span class="token keyword">this</span> section to your needs<span class="token operator">!</span># https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>docs<span class="token punctuation">.</span>travis<span class="token operator">-</span>ci<span class="token punctuation">.</span>com<span class="token operator">/</span>user<span class="token regex">/notifications/</span>notifications<span class="token punctuation">:</span>  email<span class="token punctuation">:</span>    <span class="token operator">-</span> <span class="token number">1181012791</span>@qq<span class="token punctuation">.</span>com  on_success<span class="token punctuation">:</span> change  on_failure<span class="token punctuation">:</span> always</code></pre><p>到这里我就出问题了，虽然能成功触发构建，但是并不能使用 hexo d 发布到 leader755.github.io 这个博客仓库。目前还没找出问题在哪里，出现问题地方应该在生命周期 after_script: ,如果有知道还请留言回复，感激不尽。虽然没有成功使用吧。但是也算对 travis-ci 有初步的认识吧。继续折腾吧。</p><h2 id="4-认识-Job-Lifecycle–Job-的生命周期"><a href="#4-认识-Job-Lifecycle–Job-的生命周期" class="headerlink" title="4.认识 Job Lifecycle–Job 的生命周期"></a>4.认识 Job Lifecycle–Job 的生命周期</h2><p>Travis CI 为每种编程语言提供默认构建环境和默认的阶段集。 创建虚拟机为你的 Job 提供构建环境，将存储库克隆到其中，安装可选的插件，然后运行构建阶段。<br>job 的声明周期，主要包含两大部分：<br>install：安装依赖，官网有专门讲解的 <a href="https://docs.travis-ci.com/user/installing-dependencies/" target="_blank" rel="noopener">Installing Dependencies</a><br>script：运行构建脚本；<br>在 installation 阶段之前（beofore_install）、在 script phase 之前（before_script）或之后（after_script），你可以运行自定义命令；<br>当构建成功或失败置换后，可以使用 after_success（例如构建文档）或 after_failure（例如上载日志文件）阶段执行其他操作（actions）。 在 after_failure 和 after_success 中，您可以使用$TRAVIS_TEST_RESULT 环境变量获取构建结果。</p><p>完整的 job 生命周期(包括三个可选的部署阶段，以及在检出 git 存储库 和更改到存储库目录) 如下：</p><ul><li><a href="https://docs.travis-ci.com/user/installing-dependencies/#installing-packages-with-the-apt-addon" target="_blank" rel="noopener"><strong>apt addons</strong></a>** 可选安装**</li><li><a href="https://docs.travis-ci.com/user/caching" target="_blank" rel="noopener"><strong>cache components</strong></a>** 可选安装**</li><li><strong>before_install</strong></li><li><strong>install</strong></li><li><strong>before_script</strong></li><li><strong>script</strong></li><li><strong>before_cache (for cleaning up cache) 可选</strong></li><li><strong>after_success or after_failure</strong></li><li><strong>before_deploy 可选</strong></li><li><strong>deploy 可选</strong></li><li><strong>after_deploy 可选</strong></li><li><strong>after_script</strong></li></ul><p>一次构建任务可有许多 job 组成。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> travis-ci </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.语雀文档同步到 hexo</title>
      <link href="/leader755/7381.html"/>
      <url>/leader755/7381.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-去官网注册账号"><a href="#1-去官网注册账号" class="headerlink" title="1.去官网注册账号"></a><a href="https://www.yuque.com/login?platform=wechat&inviteToken=d250cce7a9bfb322880f20b1d1c4cdc4e59fa5e9f65dd25b1c2d2e774a076c56" target="_blank" rel="noopener">1</a>.去官网注册账号</h2><p><a href="https://www.yuque.com/login?platform=wechat&inviteToken=d250cce7a9bfb322880f20b1d1c4cdc4e59fa5e9f65dd25b1c2d2e774a076c56" target="_blank" rel="noopener">点我去官网</a></p><h2 id="2-创建知识库"><a href="#2-创建知识库" class="headerlink" title="2.创建知识库"></a>2.创建知识库</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588478034103-86a7c5cc-71cb-4fd5-ba96-5eee9a2e8a2f.png#align=left&display=inline&height=321&margin=%5Bobject%20Object%5D&name=image.png&originHeight=642&originWidth=726&size=55017&status=done&style=none&width=363" alt="image.png"></p><h2 id="3-点击当前知识库的设置"><a href="#3-点击当前知识库的设置" class="headerlink" title="3.点击当前知识库的设置"></a>3.点击当前知识库的设置</h2><p>获取当前知识库的登录名和路径<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588477857012-0a0094c3-e542-429d-bb28-20cd6d29c941.png#align=left&display=inline&height=531&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1062&originWidth=1828&size=124676&status=done&style=none&width=914" alt="image.png"></p><h2 id="4-在将语雀文档同步到-hexo"><a href="#4-在将语雀文档同步到-hexo" class="headerlink" title="4.在将语雀文档同步到 hexo"></a>4.在将语雀文档同步到 hexo</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//先安装 yuque-hexo</span>npm install yuque<span class="token operator">-</span>hexo <span class="token operator">--</span>save</code></pre><h3 id="1-修改-package-json，增加配置"><a href="#1-修改-package-json，增加配置" class="headerlink" title="1) 修改 package.json，增加配置:"></a>1) 修改 package.json，增加配置:</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"yuqueConfig"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"postPath"</span><span class="token punctuation">:</span> <span class="token string">"source/_posts/yuque"</span><span class="token punctuation">,</span>    <span class="token string">"cachePath"</span><span class="token punctuation">:</span> <span class="token string">"yuque.json"</span><span class="token punctuation">,</span>    <span class="token string">"mdNameFormat"</span><span class="token punctuation">:</span> <span class="token string">"title"</span><span class="token punctuation">,</span>    <span class="token string">"adapter"</span><span class="token punctuation">:</span> <span class="token string">"hexo"</span><span class="token punctuation">,</span>    <span class="token string">"concurrency"</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span>    <span class="token string">"baseUrl"</span><span class="token punctuation">:</span> <span class="token string">"https://www.yuque.com/api/v2"</span><span class="token punctuation">,</span>    <span class="token string">"login"</span><span class="token punctuation">:</span> <span class="token string">"leader755"</span><span class="token punctuation">,</span>    <span class="token string">"repo"</span><span class="token punctuation">:</span> <span class="token string">"blog"</span><span class="token punctuation">,</span>    <span class="token string">"token"</span><span class="token punctuation">:</span> <span class="token string">"在语雀上申请的 token"</span><span class="token punctuation">,</span>    <span class="token string">"onlyPublished"</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token string">"onlyPublic"</span><span class="token punctuation">:</span> <span class="token boolean">false</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><table><thead><tr><th>参数名</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>postPath</td><td>文档同步后生成的路径</td><td>source/_posts/yuque</td></tr><tr><td>cachePath</td><td>文档下载缓存文件</td><td>yuque.json</td></tr><tr><td>mdNameFormat</td><td>文件名命名方式 (title / slug)</td><td>title</td></tr><tr><td>adapter</td><td>文档生成格式 (hexo/markdown)</td><td>hexo</td></tr><tr><td>concurrency</td><td>下载文章并发数</td><td>5</td></tr><tr><td>baseUrl</td><td>语雀 API 地址</td><td>-</td></tr><tr><td>login</td><td>语雀 login (group), 也称为个人路径</td><td>-</td></tr><tr><td>repo</td><td>语雀仓库短名称，也称为语雀知识库路径</td><td>-</td></tr><tr><td>onlyPublished</td><td>只展示已经发布的文章</td><td>false</td></tr><tr><td>onlyPublic</td><td>只展示公开文章</td><td>false</td></tr></tbody></table><blockquote><p>slug 是语雀的永久链接名，一般是几个随机字母。</p></blockquote><h3 id="2-在-package-json-添加-scripts"><a href="#2-在-package-json-添加-scripts" class="headerlink" title="2)在 package.json 添加 scripts"></a>2)在 package.json 添加 scripts</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//添加以下命令行</span><span class="token punctuation">{</span>  <span class="token string">"sync"</span><span class="token punctuation">:</span> <span class="token string">"yuque-hexo sync"</span><span class="token punctuation">,</span>  <span class="token string">"clean:yuque"</span><span class="token punctuation">:</span> <span class="token string">"yuque-hexo clean"</span><span class="token punctuation">}</span></code></pre><p>目前为止 scripts 命令行为</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"build"</span><span class="token punctuation">:</span> <span class="token string">"hexo generate"</span><span class="token punctuation">,</span>    <span class="token string">"clean"</span><span class="token punctuation">:</span> <span class="token string">"hexo clean"</span><span class="token punctuation">,</span>    <span class="token string">"deploy"</span><span class="token punctuation">:</span> <span class="token string">"hexo deploy"</span><span class="token punctuation">,</span>    <span class="token string">"server"</span><span class="token punctuation">:</span> <span class="token string">"hexo server"</span><span class="token punctuation">,</span>    <span class="token string">"sync"</span><span class="token punctuation">:</span> <span class="token string">"yuque-hexo sync"</span><span class="token punctuation">,</span>    <span class="token string">"clean:yuque"</span><span class="token punctuation">:</span> <span class="token string">"yuque-hexo clean"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><h3 id="3）关于在语雀上申请-token"><a href="#3）关于在语雀上申请-token" class="headerlink" title="3）关于在语雀上申请 token"></a>3）关于在语雀上申请 token</h3><p>点击账户个人–&gt;设置 –&gt;Token–&gt;新建 token</p><h2 id="5-同步语雀文档到本地-hexo"><a href="#5-同步语雀文档到本地-hexo" class="headerlink" title="5.同步语雀文档到本地 hexo"></a>5.同步语雀文档到本地 hexo</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//同步文档</span>yuque<span class="token operator">-</span>hexo sync<span class="token comment" spellcheck="true">//清除本地缓存</span>yuque<span class="token operator">-</span>hexo clean</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yuque </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客站内搜索功能</title>
      <link href="/leader755/31782.html"/>
      <url>/leader755/31782.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-根目录安装插件-hexo-generator-searchdb"><a href="#1-根目录安装插件-hexo-generator-searchdb" class="headerlink" title="1.根目录安装插件 hexo-generator-searchdb"></a>1.根目录安装插件 hexo-generator-searchdb</h2><pre class=" language-javascript"><code class="language-javascript">npm install hexo<span class="token operator">-</span>generator<span class="token operator">-</span>searchdb <span class="token operator">--</span>save</code></pre><h2 id="2-配置根目录文件-config-yml"><a href="#2-配置根目录文件-config-yml" class="headerlink" title="2.配置根目录文件_config.yml"></a>2.配置根目录文件_config.yml</h2><pre class=" language-javascript"><code class="language-javascript">search<span class="token punctuation">:</span> path<span class="token punctuation">:</span> search<span class="token punctuation">.</span>xml<span class="token punctuation">;</span>field<span class="token punctuation">:</span> post<span class="token punctuation">;</span>format<span class="token punctuation">:</span> html<span class="token punctuation">;</span>limit<span class="token punctuation">:</span> <span class="token number">10000</span><span class="token punctuation">;</span></code></pre><p>##</p><h2 id="3-配置主题文件-config-yml"><a href="#3-配置主题文件-config-yml" class="headerlink" title="3.配置主题文件_config.yml"></a>3.配置主题文件_config.yml</h2><pre class=" language-javascript"><code class="language-javascript">local_search<span class="token punctuation">:</span> enable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><h2 id="4-完成效果图示"><a href="#4-完成效果图示" class="headerlink" title="4.完成效果图示"></a>4.完成效果图示</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588695774509-2476d128-a52b-4d6b-8e64-7269b5c7389b.png#align=left&display=inline&height=568&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1136&originWidth=2180&size=310201&status=done&style=none&width=1090" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客提交百度和Google收录</title>
      <link href="/leader755/13299.html"/>
      <url>/leader755/13299.html</url>
      
        <content type="html"><![CDATA[<p>一个网站的 SEO 对一个网站非常重要，<a href="https://link.jianshu.com/?t=https://baike.baidu.com/item/SEO/102990?fr=aladdin" target="_blank" rel="noopener">SEO</a>指的是搜索引擎优化。通过搜索引擎优化，可以提高网站的网站关键词排名以及博客文章的曝光度。一般来说，我们针对百度和 Google 这两个搜索引擎进行优化，提高对网站资源的索引量，使我们的文章更容易被发现。虽然我的博客的主要读者是我自己，但也不妨碍我做些优化，对吧！接下来向大家展示如何使博客被百度和 Google 收录。</p><h3 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h3><p>站点地图即<a href="https://link.jianshu.com/?t=https://baike.baidu.com/item/sitemap/6241567?fr=aladdin" target="_blank" rel="noopener">sitemap</a>， 是一个页面，上面放置了网站上需要搜索引擎抓取的所有页面的链接。站点地图可以告诉搜索引擎网站上有哪些可供抓取的网页，以便搜索引擎可以更加智能地抓取网站。</p><h4 id="生成站点地图"><a href="#生成站点地图" class="headerlink" title="生成站点地图"></a>生成站点地图</h4><p>安装百度和 Google 的站点地图生成插件：</p><pre><code>npm install hexo-generator-baidu-sitemap --savenpm install hexo-generator-sitemap --save</code></pre><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>修改站点配置文件<code>_config.yml</code>，添加以下内容：</p><pre><code># 自动生成sitemapsitemap:  path: sitemap.xmlbaidusitemap:  path: baidusitemap.xml</code></pre><h4 id="生成和部署"><a href="#生成和部署" class="headerlink" title="生成和部署"></a>生成和部署</h4><p>执行生成和部署命令：</p><p>此时，进入<code>public</code>目录，你会发现里面有<code>sitemap.xml</code>和<code>baidusitemap.xml</code>两个文件，这就是生成的站点地图。里面包含了网站上所有页面的链接，搜索引擎通过这两个文件来抓取网站页面。</p><blockquote><ul><li>sitemap.xml 用来提交给 Google</li><li>baidusitemap.xml 用来提交给百度</li></ul></blockquote><h3 id="百度站长平台"><a href="#百度站长平台" class="headerlink" title="百度站长平台"></a>百度站长平台</h3><p>通过百度站长平台进行链接提交，增加网站的索引量。我的这篇文章：<a href="https://link.jianshu.com/?t=http://fengdi.org/2017/08/07/Hexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">Hexo 博客之速度优化</a> 已经提到过 Github 对百度爬虫进行了屏蔽，因此百度爬取不到 Github 上的页面，如果你按照这篇文章同时部署到 Coding 上，那百度就可以抓取到，因为此时百度抓取的是位于 Coding 上的博客网页。</p><p>注册并登录百度站长平台：<a href="https://link.jianshu.com/?t=http://zhanzhang.baidu.com/" target="_blank" rel="noopener">百度站长平台</a></p><h4 id="添加站点"><a href="#添加站点" class="headerlink" title="添加站点"></a>添加站点</h4><p>选择添加站点：</p><p><img src="https://upload-images.jianshu.io/upload_images/5635196-9bca3b38a6c1685d.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&originHeight=331&originWidth=982&status=done&style=none&width=982" alt=""></p><h4 id="验证站点"><a href="#验证站点" class="headerlink" title="验证站点"></a>验证站点</h4><p>进行站点验证：</p><p><img src="https://upload-images.jianshu.io/upload_images/5635196-51233e024040d8d7.png#align=left&display=inline&height=533&margin=%5Bobject%20Object%5D&originHeight=533&originWidth=982&status=done&style=none&width=982" alt=""></p><p>这里我们选择<code>文件验证</code>，下载验证文件到本地，放置在<code>themes/next/source</code>目录下。执行生成和部署命令：</p><p>点击完成验证即可。</p><h4 id="链接提交"><a href="#链接提交" class="headerlink" title="链接提交"></a>链接提交</h4><p>百度站长平台的链接提交方式分为自动提交和手动提交两种，此处只讲自动提交，手动提交按照要求操作即可。</p><h5 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h5><p>主动推送最为快速的提交方式，是被百度收录最快的推送方式。主动推送可以通过安装插件实现：</p><pre><code>npm install hexo-baidu-url-submit --save</code></pre><p>修改站点配置文件<code>_config.yml</code>，添加以下内容：</p><pre><code>baidu_url_submit:  count: 5 ## 提交最新的五个链接  host: www.hui-wang.info ## 百度站长平台中注册的域名  token: your_token ## 准入秘钥  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</code></pre><p>其次，记得查看<code>_config.yml</code>文件中 url 的值， 必须包含是百度站长平台注册的域名， 比如:</p><pre><code># URLurl: http://fengdi.orgroot: /permalink: :year/:month/:day/:title.xml</code></pre><p>最后，加入新的 deployer:</p><pre><code>deploy:- type: git ## 这是我原来的deployer  repo:  branch:- type: baidu_url_submitter ## 添加这里内容即可</code></pre><p>其主动推送的实现原理如下：</p><ul><li>新链接的产生， <code>hexo generate</code> 会产生一个文本文件，里面包含最新的链接</li><li>新链接的提交， <code>hexo deploy</code> 会从上述文件中读取链接，提交至百度搜索引擎</li></ul><h5 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h5><p>安装自动推送 JS 代码的网页，在页面被访问时，页面 URL 将立即被推送给百度。</p><p>修改主题目录下的<code>layout/post.swig</code>文件，末尾添加自动推送代码，代码如下：</p><pre><code>&lt;script&gt;(function(){    var bp = document.createElement(&#39;script&#39;);    var curProtocol = window.location.protocol.split(&#39;:&#39;)[0];    if (curProtocol === &#39;https&#39;) {        bp.src = &#39;https://zz.bdstatic.com/linksubmit/push.js&#39;;    }    else {        bp.src = &#39;http://push.zhanzhang.baidu.com/push.js&#39;;    }    var s = document.getElementsByTagName(&quot;script&quot;)[0];    s.parentNode.insertBefore(bp, s);})();&lt;/script&gt;</code></pre><h5 id="sitemap-提交"><a href="#sitemap-提交" class="headerlink" title="sitemap 提交"></a>sitemap 提交</h5><p>我们之前已经说过如何生成 sitemap 文件，这时就需要我们生成的 sitemap 文件了。</p><p><img src="https://upload-images.jianshu.io/upload_images/5635196-cfb7e4bd12e2deb8.png#align=left&display=inline&height=443&margin=%5Bobject%20Object%5D&originHeight=443&originWidth=981&status=done&style=none&width=981" alt=""></p><p>输入以下内容到输入框里：</p><pre><code>http://fengdi.org/baidusitemap.xml</code></pre><p>输入验证码后，提交即可。一般情况下，百度会在一个小时内处理该文件，并提取其中的 url。</p><h3 id="Google-网站站长"><a href="#Google-网站站长" class="headerlink" title="Google 网站站长"></a>Google 网站站长</h3><p>在提交 Google 之前，要解决一个大家都知道的问题，关于如何登录 Google。这里就不再说了，相信你们有办法。</p><h4 id="添加站点-1"><a href="#添加站点-1" class="headerlink" title="添加站点"></a>添加站点</h4><p>登录<a href="https://link.jianshu.com/?t=https://www.google.com/webmasters/#?modal_active=none" target="_blank" rel="noopener">Google 网站站长</a>，进入<code>Search Console</code>，点击<code>添加属性</code>进行站点添加：</p><p><img src="https://upload-images.jianshu.io/upload_images/5635196-9a7ce99e3aaaf1a9.png#align=left&display=inline&height=477&margin=%5Bobject%20Object%5D&originHeight=477&originWidth=1364&status=done&style=none&width=1364" alt=""></p><h4 id="验证站点-1"><a href="#验证站点-1" class="headerlink" title="验证站点"></a>验证站点</h4><p>同百度平台一样，下载 Google 验证文件，放到 source 下<code>themes/next/source</code>目录中：</p><p><img src="https://upload-images.jianshu.io/upload_images/5635196-2a7e8f527d0b1b42.png#align=left&display=inline&height=618&margin=%5Bobject%20Object%5D&originHeight=618&originWidth=1210&status=done&style=none&width=1210" alt=""></p><p>重新生成和部署：</p><p>部署完成之后，进行验证即可。</p><h4 id="添加站点地图"><a href="#添加站点地图" class="headerlink" title="添加站点地图"></a>添加站点地图</h4><p>在<code>抓取</code>里面，点击<code>站点地图</code>，进行添加：</p><p><img src="https://upload-images.jianshu.io/upload_images/5635196-7071aa22f10e2c28.png#align=left&display=inline&height=507&margin=%5Bobject%20Object%5D&originHeight=507&originWidth=1353&status=done&style=none&width=1353" alt=""></p><p>好了，到这里文章就结束了。如果你之前没有把网站部署到 Coding 上，你的网站百度是爬取不到的，关于如何部署请参阅：<a href="https://link.jianshu.com/?t=http://fengdi.org/2017/08/07/Hexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">Hexo 博客之速度优化</a></p><p><a href="https://link.jianshu.com/?t=http://svend.cc/posts/22980/" target="_blank" rel="noopener">Hexo 系列：（四）Hexo 博客提交百度和 Google 收录</a></p><p>文文章转载自：<a href="https://www.jianshu.com/p/f8ec422ebd52" target="_blank" rel="noopener">https://www.jianshu.com/p/f8ec422ebd52</a></p><p>**</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 百度收录 </tag>
            
            <tag> 谷歌收录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客的生成永久标题链接</title>
      <link href="/leader755/9481.html"/>
      <url>/leader755/9481.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-hexo-博客默认链接规则："><a href="#1-hexo-博客默认链接规则：" class="headerlink" title="1.hexo 博客默认链接规则："></a>1.hexo 博客默认链接规则：</h2><p><strong>hexo 生成的标题默认规则（年、月、日、标题）：:year/:month/:day/:title。复制后的链接是一长串，非常不利于阅读，也不简洁。</strong></p><h2 id="2-解决方案："><a href="#2-解决方案：" class="headerlink" title="2.解决方案："></a>2.解决方案：</h2><h3 id="1-使用hexo-permalink-pinyin"><a href="#1-使用hexo-permalink-pinyin" class="headerlink" title="1.使用hexo-permalink-pinyin"></a>1.使用<a href="">hexo-permalink-pinyin</a></h3><p>将中文转英文，这样方案也存在一定的缺陷，比如修改了文章标题，重新 hexo 三连后，URL 就变了，以前的文章地址变成了 404。而且这样生成的 URL 层级也很深，不利于 SEO。</p><h4 id="1-gt-安装-hexo-permalink-pinyin"><a href="#1-gt-安装-hexo-permalink-pinyin" class="headerlink" title="1&gt;安装 hexo-permalink-pinyin"></a>1&gt;安装 hexo-permalink-pinyin</h4><pre class=" language-javascript"><code class="language-javascript">npm i hexo<span class="token operator">-</span>permalink<span class="token operator">-</span>pinyin <span class="token operator">--</span>save</code></pre><h4 id="2-gt-修改根目录下的-config-yml-文件，找到-permalink。"><a href="#2-gt-修改根目录下的-config-yml-文件，找到-permalink。" class="headerlink" title="2&gt;修改根目录下的_config.yml 文件，找到 permalink。"></a>2&gt;修改根目录下的_config.yml 文件，找到 permalink。</h4><pre class=" language-javascript"><code class="language-javascript">permalink_pinyin<span class="token punctuation">:</span>  enable<span class="token punctuation">:</span> <span class="token boolean">true</span>  separator<span class="token punctuation">:</span> <span class="token string">'-'</span> # <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token string">'-'</span>permalink_pinyin<span class="token punctuation">:</span>  enable<span class="token punctuation">:</span> <span class="token boolean">true</span>             # Enable <span class="token keyword">this</span> plugin  separator<span class="token punctuation">:</span> <span class="token string">'-'</span>           # Separator <span class="token keyword">of</span> the slug<span class="token punctuation">,</span> <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token string">'-'</span>  exclude<span class="token punctuation">:</span> <span class="token operator">/</span>ignore_post<span class="token operator">/</span>   # Regex <span class="token keyword">for</span> which post should skip</code></pre><p>###</p><h3 id="2-使用hexo-abbrlink"><a href="#2-使用hexo-abbrlink" class="headerlink" title="2.使用hexo-abbrlink"></a>2.使用<a href="https://github.com/Rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a></h3><p>生成唯一不变的 URl 链接，链接可以调整自己想要的。弊端</p><h4 id="1-gt-安装-hexo-abbrlink"><a href="#1-gt-安装-hexo-abbrlink" class="headerlink" title="1&gt;安装 hexo-abbrlink"></a>1&gt;安装 hexo-abbrlink</h4><pre class=" language-javascript"><code class="language-javascript">npm i hexo<span class="token operator">-</span>permalink<span class="token operator">-</span>pinyin <span class="token operator">--</span>save</code></pre><p>####</p><h4 id="2-gt-修改根目录下的-config-yml-文件，找到-permalink。-1"><a href="#2-gt-修改根目录下的-config-yml-文件，找到-permalink。-1" class="headerlink" title="2&gt;修改根目录下的_config.yml 文件，找到 permalink。"></a>2&gt;修改根目录下的_config.yml 文件，找到 permalink。</h4><pre class=" language-javascript"><code class="language-javascript">permalink<span class="token punctuation">:</span> post<span class="token operator">/</span><span class="token punctuation">:</span>abbrlink<span class="token punctuation">.</span>html  # 文章的永久链接格式<span class="token punctuation">,</span>post可以自定义abbrlink<span class="token punctuation">:</span>  alg<span class="token punctuation">:</span> crc32  # 算法： <span class="token function">crc16</span><span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">)</span> and crc32  rep<span class="token punctuation">:</span> hex    # 进制： <span class="token function">dec</span><span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">)</span> and hex</code></pre><p>生成后的博客链接如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588694804547-5dbe637d-46af-4bfc-9b3d-4d5228b573a6.png#align=left&display=inline&height=37&margin=%5Bobject%20Object%5D&name=image.png&originHeight=74&originWidth=908&size=11417&status=done&style=none&width=454" alt="image.png"></p><p>如果觉得对你有帮助，点个赞呗。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 永久标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.hexo主题配置</title>
      <link href="/leader755/52316.html"/>
      <url>/leader755/52316.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-hexo-主题官网"><a href="#1-hexo-主题官网" class="headerlink" title="1.hexo 主题官网"></a>1.hexo 主题官网</h2><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a></p><h2 id="2-应用以及下载主题"><a href="#2-应用以及下载主题" class="headerlink" title="2.应用以及下载主题"></a>2.应用以及下载主题</h2><p>说明：在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。（必看）</p><h3 id="1-安装主题"><a href="#1-安装主题" class="headerlink" title="1.安装主题"></a>1.安装主题</h3><p>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至<strong>站点目录(**</strong>即根目录下的文件_config.yml 文件*<strong>*)</strong>的  <code>themes</code>  目录下， 然后修改下配置文件即可。next 为主题名</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码：</span>$ cd your<span class="token operator">-</span>hexo<span class="token operator">-</span>site$ git clone https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>iissnan<span class="token operator">/</span>hexo<span class="token operator">-</span>theme<span class="token operator">-</span>next themes<span class="token operator">/</span>next</code></pre><p>###</p><h3 id="2-启用主题"><a href="#2-启用主题" class="headerlink" title="2.启用主题"></a>2.启用主题</h3><p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 <strong>站点配置文件</strong>， 找到 <code>theme</code> 字段，并将其值更改为 <code>next(主题名)</code>。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588326982972-1828234c-3a21-48e1-ac1e-5b57480ac6f0.png#align=left&display=inline&height=111&margin=%5Bobject%20Object%5D&name=image.png&originHeight=222&originWidth=1012&size=24250&status=done&style=none&width=506" alt="image.png"></p><pre class=" language-javascript"><code class="language-javascript">theme<span class="token punctuation">:</span> next<span class="token punctuation">;</span></code></pre><h4 id="2-1-本文使用的是（hexo-theme-halo）主题"><a href="#2-1-本文使用的是（hexo-theme-halo）主题" class="headerlink" title="2.1 本文使用的是（hexo-theme-halo）主题"></a>2.1 本文使用的是（hexo-theme-halo）主题</h4><p>1&gt;直接下载 git  clone</p><pre class=" language-javascript"><code class="language-javascript">git clone https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>hongweifuture<span class="token operator">/</span>hexo<span class="token operator">-</span>theme<span class="token operator">-</span>halo<span class="token punctuation">.</span>git themes<span class="token operator">/</span>halo</code></pre><p>2&gt;直接将<code>themes/halo/config/source</code>内所有内容拷贝到<code>Hexo</code>根目录下的<code>source</code>文件夹内替换</p><h4 id="2-2-配置切换主题"><a href="#2-2-配置切换主题" class="headerlink" title="2.2 配置切换主题"></a>2.2 配置切换主题</h4><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 <code>theme</code> 的值：<code>theme: halo</code><br><code>根目录_config.yml</code> 文件的其它修改建议:</p><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>[http://xxx.github.io](http://xxx.github.io)</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="3-验证主题"><a href="#3-验证主题" class="headerlink" title="3.验证主题"></a>3.验证主题</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//最好先清除缓存</span>hexo clean<span class="token comment" spellcheck="true">//打包</span>hexo g<span class="token comment" spellcheck="true">//启动</span>hexo s<span class="token comment" spellcheck="true">//发布到 github</span>hexo s <span class="token operator">-</span>d</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.hexo插件篇（必看）</title>
      <link href="/leader755/40372.html"/>
      <url>/leader755/40372.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-gt-安装插件说明"><a href="#1-gt-安装插件说明" class="headerlink" title="1&gt;安装插件说明"></a>1&gt;安装插件说明</h2><p>如果应用官网的主题你会发现，有可能出现打不开的情况，这是由于有些主题使用的插件，本地并没有安装导致的报错。所以本篇文章为补充说明篇。（无问题的可以跳过）</p><h2 id="2-gt-常用的插件"><a href="#2-gt-常用的插件" class="headerlink" title="2&gt;常用的插件"></a>2&gt;常用的插件</h2><h3 id="代码高亮（建议安装）"><a href="#代码高亮（建议安装）" class="headerlink" title="代码高亮（建议安装）"></a>代码高亮（建议安装）</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class=" language-javascript"><code class="language-javascript">npm i <span class="token operator">-</span>S hexo<span class="token operator">-</span>prism<span class="token operator">-</span>plugin</code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class=" language-javascript"><code class="language-javascript">highlight<span class="token punctuation">:</span>  enable<span class="token punctuation">:</span> <span class="token boolean">false</span>  line_number<span class="token punctuation">:</span> <span class="token boolean">true</span>  auto_detect<span class="token punctuation">:</span> <span class="token boolean">false</span>  tab_replace<span class="token punctuation">:</span> <span class="token boolean">false</span>  wrap<span class="token punctuation">:</span> <span class="token boolean">true</span>  hljs<span class="token punctuation">:</span> <span class="token boolean">false</span>prism_plugin<span class="token punctuation">:</span>  mode<span class="token punctuation">:</span> <span class="token string">'preprocess'</span>    # realtime<span class="token operator">/</span>preprocess  theme<span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  line_number<span class="token punctuation">:</span> <span class="token boolean">false</span>    # <span class="token keyword">default</span> <span class="token boolean">false</span>  custom_css<span class="token punctuation">:</span></code></pre><h3 id="搜索（建议安装）"><a href="#搜索（建议安装）" class="headerlink" title="搜索（建议安装）"></a>搜索（建议安装）</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class=" language-javascript"><code class="language-javascript">npm install hexo<span class="token operator">-</span>generator<span class="token operator">-</span>search <span class="token operator">--</span>save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-javascript"><code class="language-javascript">search<span class="token punctuation">:</span> path<span class="token punctuation">:</span> search<span class="token punctuation">.</span>xml<span class="token punctuation">;</span>field<span class="token punctuation">:</span> post<span class="token punctuation">;</span></code></pre><p>###</p><h3 id="文章字数统计插件（建议安装）（使用了-halo-主题则必须安装）"><a href="#文章字数统计插件（建议安装）（使用了-halo-主题则必须安装）" class="headerlink" title="文章字数统计插件（建议安装）（使用了 halo 主题则必须安装）"></a>文章字数统计插件（建议安装）（使用了 halo 主题则必须安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>插件。安装命令如下：</p><pre class=" language-javascript"><code class="language-javascript">npm i <span class="token operator">--</span>save hexo<span class="token operator">-</span>wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：<br>(此处注意源文档的 postInfo 是错的，应该为 post_wordcount)</p><pre class=" language-javascript"><code class="language-javascript">post_wordcount<span class="token punctuation">:</span>  date<span class="token punctuation">:</span> <span class="token boolean">true</span> # 发布日期  update<span class="token punctuation">:</span> <span class="token boolean">true</span> # 更新日期  wordCount<span class="token punctuation">:</span> <span class="token boolean">true</span> # 文章字数统计  totalCount<span class="token punctuation">:</span> <span class="token boolean">true</span> # 站点总文章字数  min2read<span class="token punctuation">:</span> <span class="token boolean">true</span> # 文章阅读时长  readCount<span class="token punctuation">:</span> <span class="token boolean">true</span> # 文章阅读次数</code></pre><h3 id="添加代码压缩（建议安装）"><a href="#添加代码压缩（建议安装）" class="headerlink" title="添加代码压缩（建议安装）"></a>添加代码压缩（建议安装）</h3><p><a href="https://github.com/rozbo/hexo-neat" target="_blank" rel="noopener">hexo-neat</a>插件实现压缩代码，底层是通过 gulp 来实现的。但是这个插件是有 Bug 的：</p><ul><li>压缩 md 文件会使 markdown 语法的代码块消失</li><li>会删除全角空格</li></ul><p>在博客站点根目录执行安装代码：</p><pre><code>npm install hexo-neat --save</code></pre><p>紧接着在站点根目录下的配置文件添加如下代码：</p><pre><code>neat_enable: trueneat_html:  enable: true  exclude:neat_css:  enable: true  exclude:    - &#39;*.min.css&#39;neat_js:  enable: true  mangle: true  output:  compress:  exclude:    - &#39;*.min.js&#39;</code></pre><p>然后直接 hexo cl&amp;&amp;hexo g 就可以了，会自动压缩文件 。<br>补充：为了解决以上 Bug，对于<code>halo</code>主题（其他主题自行解决）需要将以上默认配置修改为：</p><pre><code>#hexo-neat 优化提速插件（去掉HTML、css、js的blank字符）neat_enable: trueneat_html:  enable: true  exclude:    - &#39;**/*.md&#39;neat_css:  enable: true  exclude:    - &#39;**/*.min.css&#39;neat_js:  enable: true  mangle: true  output:  compress:  exclude:    - &#39;**/*.min.js&#39;    - &#39;**/**/instantpage.js&#39;    - &#39;**/matery.js&#39;</code></pre><p>###</p><h3 id="外链跳转插件-hexo-external-link（可选安装）（使用了-halo-主题则必须安装）"><a href="#外链跳转插件-hexo-external-link（可选安装）（使用了-halo-主题则必须安装）" class="headerlink" title="外链跳转插件 hexo-external-link（可选安装）（使用了 halo 主题则必须安装）"></a>外链跳转插件 hexo-external-link（可选安装）（使用了 halo 主题则必须安装）</h3><blockquote><p><a href="https://github.com/hvnobug/hexo-external-link" target="_blank" rel="noopener">hexo-external-link</a>是一个跳转外链相关插件。自动为所有 html 文件中外链的 a 标签生成对应的属性。 比如 设置<code>target=’_blank’</code>, <code>rel=’external nofollow noopener noreferrer’</code>告诉搜索引擎这是外部链接,不要将该链接计入权重。 同时自动生成外链跳转页面,默认在根目录下 go.html;</p></blockquote><p>安装:</p><pre class=" language-javascript"><code class="language-javascript">npm install hexo<span class="token operator">-</span>external<span class="token operator">-</span>link <span class="token operator">--</span>save</code></pre><p>配置插件 在 Hexo 根目录的_config.yml 文件中添加如下配置。</p><pre class=" language-javascript"><code class="language-javascript">hexo_external_link<span class="token punctuation">:</span>  enable<span class="token punctuation">:</span> <span class="token boolean">true</span>  enable_base64_encode<span class="token punctuation">:</span> <span class="token boolean">true</span>  url_param_name<span class="token punctuation">:</span> <span class="token string">'u'</span>  html_file_name<span class="token punctuation">:</span> <span class="token string">'go.html'</span>  target_blank<span class="token punctuation">:</span> <span class="token boolean">true</span>  link_rel<span class="token punctuation">:</span> <span class="token string">'external nofollow noopener noreferrer'</span>  domain<span class="token punctuation">:</span> <span class="token string">'your_domain'</span> # 如果开启了防盗链  safety_chain<span class="token punctuation">:</span> <span class="token boolean">true</span></code></pre><ul><li>enable：是否开启 hexo_external_link 插件 - 默认 false</li><li>enable_base64_encode：是否对跳转 url 使用 base64 编码 - 默认 fasle</li><li>url_param_name：url 参数名,在跳转到外链传递给 html_file_name 的参数名 - 默认 ‘u’</li><li>html_file_name：跳转到外链的页面文件路径 - 默认 ‘go.html’</li><li>target_blank：是否为外链的 a 标签添加 target=’_blank’ - 默认 true</li><li>link_rel：设置外链的 a 标签的 rel 属性 - 默认 ‘external nofollow noopener noreferrer’</li><li>domain：如果开启了防盗链,除了 localhost 和 domain 之外调用会跳到主页,同时也是判断链接是否为外链的依据 - 默认 window.location.host</li><li>safety_chain：go.html 为了防止外链盗用 对域名进行的判断 - 默认 false 即关闭防盗链</li></ul><p>###</p><h3 id="添加-RSS-订阅支持（可选安装）（使用了-halo-主题则必须安装）"><a href="#添加-RSS-订阅支持（可选安装）（使用了-halo-主题则必须安装）" class="headerlink" title="添加 RSS 订阅支持（可选安装）（使用了 halo 主题则必须安装）"></a>添加 RSS 订阅支持（可选安装）（使用了 halo 主题则必须安装）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class=" language-javascript"><code class="language-javascript">npm install hexo<span class="token operator">-</span>generator<span class="token operator">-</span>feed <span class="token operator">--</span>save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-javascript"><code class="language-javascript">feed<span class="token punctuation">:</span> type<span class="token punctuation">:</span> atom<span class="token punctuation">;</span>path<span class="token punctuation">:</span> atom<span class="token punctuation">.</span>xml<span class="token punctuation">;</span>limit<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">;</span>hub<span class="token punctuation">:</span> content<span class="token punctuation">:</span> content_limit<span class="token punctuation">:</span> <span class="token number">140</span><span class="token punctuation">;</span>content_limit_delim<span class="token punctuation">:</span> <span class="token string">" "</span><span class="token punctuation">;</span>order_by<span class="token punctuation">:</span> <span class="token operator">-</span>date<span class="token punctuation">;</span></code></pre><h3 id="添加-sitemap-站点地图（可选安装）（使用了-halo-主题则必须安装）"><a href="#添加-sitemap-站点地图（可选安装）（使用了-halo-主题则必须安装）" class="headerlink" title="添加 sitemap 站点地图（可选安装）（使用了 halo 主题则必须安装）"></a>添加 sitemap 站点地图（可选安装）（使用了 halo 主题则必须安装）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="noopener">hexo-generator-sitemap</a> 的 Hexo 插件来做 <code>Sitemap</code>，安装命令如下：</p><pre class=" language-javascript"><code class="language-javascript">npm install hexo<span class="token operator">-</span>generator<span class="token operator">-</span>sitemap <span class="token operator">--</span>save</code></pre><p>访问地址：/sitemap.xml</p><h3 id="中文链接转拼音（可选安装）"><a href="#中文链接转拼音（可选安装）" class="headerlink" title="中文链接转拼音（可选安装）"></a>中文链接转拼音（可选安装）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。<br>这里为可选安装，因为我希望使用<code>urlname</code>进行连接访问，中文链接转拼音由一个缺点就是当文章名字过长会显示十分臃肿。<code>urlname</code>的方式见下文。<br>安装命令如下：</p><pre class=" language-javascript"><code class="language-javascript">npm i hexo<span class="token operator">-</span>permalink<span class="token operator">-</span>pinyin <span class="token operator">--</span>save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-javascript"><code class="language-javascript">permalink_pinyin<span class="token punctuation">:</span>  enable<span class="token punctuation">:</span> <span class="token boolean">true</span>  separator<span class="token punctuation">:</span> <span class="token string">'-'</span> # <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token string">'-'</span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><p>###</p><p>###</p><h3 id="添加-emoji-表情支持（可选安装）"><a href="#添加-emoji-表情支持（可选安装）" class="headerlink" title="添加 emoji 表情支持（可选安装）"></a>添加 emoji 表情支持（可选安装）</h3><p>本主题新增了对<code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis" target="_blank" rel="noopener">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p><pre class=" language-javascript"><code class="language-javascript">npm install hexo<span class="token operator">-</span>filter<span class="token operator">-</span>github<span class="token operator">-</span>emojis <span class="token operator">--</span>save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-javascript"><code class="language-javascript">githubEmojis<span class="token punctuation">:</span>  enable<span class="token punctuation">:</span> <span class="token boolean">true</span>  className<span class="token punctuation">:</span> github<span class="token operator">-</span>emoji  inject<span class="token punctuation">:</span> <span class="token boolean">true</span>  styles<span class="token punctuation">:</span>  customEmojis<span class="token punctuation">:</span></code></pre><h3 id="deploy-发布插件（可选安装）（部署到-github-需要安装）"><a href="#deploy-发布插件（可选安装）（部署到-github-需要安装）" class="headerlink" title="deploy 发布插件（可选安装）（部署到 github 需要安装）"></a>deploy 发布插件（可选安装）（部署到 github 需要安装）</h3><p>如果你想通过<code>deploy</code>的方式进行推送<code>public文件夹</code>到托管网站，你需要安装</p><pre class=" language-javascript"><code class="language-javascript">npm install hexo<span class="token operator">-</span>deployer<span class="token operator">-</span>git <span class="token operator">--</span>save</code></pre><p>当然你也可以选择不装，使用 Github Actions、docker 等方式<br>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="添加-DaoVoice-在线聊天功能（可选的）"><a href="#添加-DaoVoice-在线聊天功能（可选的）" class="headerlink" title="添加 DaoVoice 在线聊天功能（可选的）"></a>添加 <a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a> 在线聊天功能（可选的）</h3><p>前往 <a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="添加-Tidio-在线聊天功能（可选的）"><a href="#添加-Tidio-在线聊天功能（可选的）" class="headerlink" title="添加 Tidio 在线聊天功能（可选的）"></a>添加 <a href="https://www.tidio.com/" target="_blank" rel="noopener">Tidio</a> 在线聊天功能（可选的）</h3><p>前往 <a href="https://www.tidio.com/" target="_blank" rel="noopener">Tidio</a> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ej``s</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>socialLink<span class="token punctuation">.</span>github<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%= theme.socialLink.github %>"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"tooltipped"</span> target<span class="token operator">=</span><span class="token string">"_blank"</span> data<span class="token operator">-</span>tooltip<span class="token operator">=</span><span class="token string">"访问我的GitHub"</span> data<span class="token operator">-</span>position<span class="token operator">=</span><span class="token string">"top"</span> data<span class="token operator">-</span>delay<span class="token operator">=</span><span class="token string">"50"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>i <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"fab fa-github"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fab fa-facebook</code></li><li>Twitter: <code>fab fa-twitter</code></li><li>Google-plus: <code>fab fa-google-plus</code></li><li>Linkedin: <code>fab fa-linkedin</code></li><li>Tumblr: <code>fab fa-tumblr</code></li><li>Medium: <code>fab fa-medium</code></li><li>Slack: <code>fab fa-slack</code></li><li>Sina Weibo: <code>fab fa-weibo</code></li><li>Wechat: <code>fab fa-weixin</code></li><li>QQ: <code>fab fa-qq</code></li><li>Zhihu: <code>fab fa-zhihu</code><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>5.11.0</code>。</p></blockquote></li></ul><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。<br>首先，在你的博客 <code>source</code> 目录下的 <code>_data</code> 目录（没有的话就新建一个）中新建 <code>musics.json</code> 文件，文件内容如下所示：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span>  <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">"五月雨变奏电音"</span><span class="token punctuation">,</span>    artist<span class="token punctuation">:</span> <span class="token string">"AnimeVibe"</span><span class="token punctuation">,</span>    url<span class="token punctuation">:</span> <span class="token string">"http://xxx.com/music1.mp3"</span><span class="token punctuation">,</span>    cover<span class="token punctuation">:</span> <span class="token string">"http://xxx.com/music-cover1.png"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">"Take me hand"</span><span class="token punctuation">,</span>    artist<span class="token punctuation">:</span> <span class="token string">"DAISHI DANCE,Cecile Corbel"</span><span class="token punctuation">,</span>    url<span class="token punctuation">:</span> <span class="token string">"/medias/music/music2.mp3"</span><span class="token punctuation">,</span>    cover<span class="token punctuation">:</span> <span class="token string">"/medias/music/cover2.png"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">"Shape of You"</span><span class="token punctuation">,</span>    artist<span class="token punctuation">:</span> <span class="token string">"J.Fla"</span><span class="token punctuation">,</span>    url<span class="token punctuation">:</span> <span class="token string">"http://xxx.com/music3.mp3"</span><span class="token punctuation">,</span>    cover<span class="token punctuation">:</span> <span class="token string">"http://xxx.com/music-cover3.png"</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>注</strong>：以上 JSON 中的属性：<code>name</code>、<code>artist</code>、<code>url</code>、<code>cover</code> 分别表示音乐的名称、作者、音乐文件地址、音乐封面。</p></blockquote><p>然后，在主题的 <code>_config.yml</code> 配置文件中激活配置即可：</p><h1 id="是否在首页显示音乐"><a href="#是否在首页显示音乐" class="headerlink" title="是否在首页显示音乐."></a>是否在首页显示音乐.</h1><pre class=" language-javascript"><code class="language-javascript"># 是否在首页显示音乐<span class="token punctuation">.</span>music<span class="token punctuation">:</span>  enable<span class="token punctuation">:</span> <span class="token boolean">true</span>  showTitle<span class="token punctuation">:</span> <span class="token boolean">false</span>  title<span class="token punctuation">:</span> 听听音乐  fixed<span class="token punctuation">:</span> <span class="token boolean">false</span> # 是否开启吸底模式  autoplay<span class="token punctuation">:</span> <span class="token boolean">false</span> # 是否自动播放  theme<span class="token punctuation">:</span> <span class="token string">'#42b983'</span>  loop<span class="token punctuation">:</span> <span class="token string">'all'</span> # 音频循环播放<span class="token punctuation">,</span> 可选值<span class="token punctuation">:</span> <span class="token string">'all'</span><span class="token punctuation">,</span> <span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token string">'none'</span>  order<span class="token punctuation">:</span> <span class="token string">'list'</span> # 音频循环顺序<span class="token punctuation">,</span> 可选值<span class="token punctuation">:</span> <span class="token string">'list'</span><span class="token punctuation">,</span> <span class="token string">'random'</span>  preload<span class="token punctuation">:</span> <span class="token string">'auto'</span> # 预加载，可选值<span class="token punctuation">:</span> <span class="token string">'none'</span><span class="token punctuation">,</span> <span class="token string">'metadata'</span><span class="token punctuation">,</span> <span class="token string">'auto'</span>  volume<span class="token punctuation">:</span> <span class="token number">0.7</span> # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded<span class="token punctuation">:</span> <span class="token boolean">false</span> # 列表默认折叠  listMaxHeight<span class="token punctuation">:</span> # 列表最大高度</code></pre><h3 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h3><ol><li><strong>直接将<code>themes/halo/config/scaffolds</code>内所有内容拷贝到**</strong><code>Hexo</code>根目录下*<strong>*的<code>scaffolds</code>文件夹内替换</strong></li><li>或者自己重新修改，修改请参考下面</li></ol><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 、<code>urlname</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>[http://xxx.com/xxx.jpg](http://xxx.com/xxx.jpg)</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>urlname</td><td>index</td><td>文章访问路径，需要在<code>Hexo</code>根目录下<code>_config.yml</code>文件中使用<code>permalink: :urlname/</code>和<code>permalink_defaults:</code></td></tr><tr><td><code>urlname: index</code></td><td></td><td></td></tr><tr><td>toc</td><td><code>true</code></td><td>permalink_defaults:是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>urlname: index 是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li><li>您可以在文章 md 文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h3><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token punctuation">.</span>bg<span class="token operator">-</span>color <span class="token punctuation">{</span>    background<span class="token operator">-</span>image<span class="token punctuation">:</span> linear<span class="token operator">-</span><span class="token function">gradient</span><span class="token punctuation">(</span>to right<span class="token punctuation">,</span> #4cbf30 <span class="token number">0</span><span class="token operator">%</span><span class="token punctuation">,</span> #0f9d58 <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>@<span class="token operator">-</span>webkit<span class="token operator">-</span>keyframes rainbow <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span>@keyframes rainbow <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span></code></pre><p>/</p><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".bg-cover"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span>  <span class="token string">"background-image"</span><span class="token punctuation">,</span>  <span class="token string">"url(/medias/banner/"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".jpg)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h3 id="修改文章访问路径-urlname"><a href="#修改文章访问路径-urlname" class="headerlink" title="修改文章访问路径 urlname"></a>修改文章访问路径 urlname</h3><p>在<code>Hexo</code>根目录<code>_config.yaml</code>中添加以下配置</p><pre><code># permalink: :year/:month/:day/:title/permalink: :urlname/permalink_defaults:  urlname: index</code></pre><p>##</p><h3 id="全站-CDN"><a href="#全站-CDN" class="headerlink" title="全站 CDN"></a>全站 CDN</h3><blockquote><p>CDN 的全称是<code>Content Delivery Network</code>，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。——百度百科</p></blockquote><p>放在 Github 的资源在国内加载速度比较慢，因此需要使用 CDN 加速来优化网站打开速度，jsDelivr + Github 便是免费且好用的 CDN，非常适合博客网站使用。</p><p>用法：<br><a href="https://cdn.jsdelivr.net/gh/" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/</a>你的用户名/你的仓库名@发布的版本号/文件路径</p><p>如：<br><a href="http://cdn.jsdelivr.net/gh/hongweifuture/hongweifuture.github.io/medias/featureimages/" target="_blank" rel="noopener">http://cdn.jsdelivr.net/gh/hongweifuture/hongweifuture.github.io/medias/featureimages/</a>12.jpg<br>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，如果需要版本，请创建<code>releases</code>然后按照格式添加<br>当然最直接的办法就是使用 <code>username/username.github.io/</code></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.hexo文档部署到 Github和 coding</title>
      <link href="/leader755/58848.html"/>
      <url>/leader755/58848.html</url>
      
        <content type="html"><![CDATA[<h2 id="1：打开项目根目录下的-config-yml-配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）："><a href="#1：打开项目根目录下的-config-yml-配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）：" class="headerlink" title="1：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）："></a>1：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）：</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588313278812-df6c1515-c7b2-4988-ab07-98655129341a.png#align=left&display=inline&height=144&margin=%5Bobject%20Object%5D&name=image.png&originHeight=288&originWidth=1052&size=44477&status=done&style=none&width=526" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588333533439-ce902a29-c0fc-49e0-90a7-90e71ce9c3aa.png#align=left&display=inline&height=120&margin=%5Bobject%20Object%5D&name=image.png&originHeight=240&originWidth=972&size=33032&status=done&style=none&width=486" alt="image.png"><br>如果不部署到 coding，就只写 github 就行。</p><pre class=" language-javascript"><code class="language-javascript">deploy<span class="token punctuation">:</span> type<span class="token punctuation">:</span> git<span class="token punctuation">;</span>repo<span class="token punctuation">:</span> github<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">//github.com/Leader755/leader755.github.io.git</span>https<span class="token punctuation">:</span> coding<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">//e.coding.net/Leader755/leader755.coding.git</span>https<span class="token punctuation">:</span> branch<span class="token punctuation">:</span> master<span class="token punctuation">;</span></code></pre><h2 id="2：要安装一个部署插件-hexo-deployer-git。"><a href="#2：要安装一个部署插件-hexo-deployer-git。" class="headerlink" title="2：要安装一个部署插件 hexo-deployer-git。"></a>2：要安装一个部署插件 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>。</h2><pre class=" language-javascript"><code class="language-javascript">npm install hexo<span class="token operator">-</span>deployer<span class="token operator">-</span>git <span class="token operator">--</span>save</code></pre><h2 id="3：发布到-github"><a href="#3：发布到-github" class="headerlink" title="3：发布到 github"></a>3：发布到 github</h2><p>最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p><pre class=" language-javascript"><code class="language-javascript">hexo g <span class="token operator">-</span>d</code></pre><p>稍等一会，在浏览器访问网址： <a href="https://xn--6qqv7i14ofosyrb.github.io/" target="_blank" rel="noopener">https://你的用户名.github.io</a> 就会看到你的博客啦！！</p><h2 id="4-写作并发布"><a href="#4-写作并发布" class="headerlink" title="4.写作并发布"></a>4.写作并发布</h2><h3 id="1-直接写作（情况）"><a href="#1-直接写作（情况）" class="headerlink" title="1.直接写作（情况）"></a>1.直接写作（情况）</h3><p>博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a> 官网。<br>新建文章，输入以下命令即可</p><pre class=" language-javascript"><code class="language-javascript">hexo <span class="token keyword">new</span> <span class="token string">'文章标题'</span></code></pre><p>执行完成后可以在 /source/_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。<br>在 Markdown 文章里面输入你的文章内容</p><h3 id="2-存查稿-情况"><a href="#2-存查稿-情况" class="headerlink" title="2.存查稿(情况)"></a>2.存查稿(情况)</h3><h4 id="1-首先查看-sources-文件下是否有-drafts-文件夹"><a href="#1-首先查看-sources-文件下是否有-drafts-文件夹" class="headerlink" title="1.首先查看 sources 文件下是否有_drafts 文件夹"></a>1.首先查看 sources 文件下是否有_drafts 文件夹</h4><p>**  _drafts(草稿文章缓存区)，_posts(正式文章缓存区)**<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588313764893-f9511ad0-1933-4c23-becd-bc162c0e8f3e.png#align=left&display=inline&height=149&margin=%5Bobject%20Object%5D&name=image.png&originHeight=298&originWidth=782&size=24987&status=done&style=none&width=391" alt="image.png"></p><p>如果没有该文件夹或者报错，则运行：</p><pre class=" language-javascript"><code class="language-javascript">hexo <span class="token keyword">new</span> <span class="token class-name">draft</span> <span class="token string">"My First Blog Post"</span></code></pre><h4 id="2-将草稿文章推送到正式区"><a href="#2-将草稿文章推送到正式区" class="headerlink" title="2.将草稿文章推送到正式区"></a>2.将草稿文章推送到正式区</h4><pre class=" language-javascript"><code class="language-javascript">hexo publish <span class="token string">"My First Blog Post"</span></code></pre><h3 id="2-打包"><a href="#2-打包" class="headerlink" title="2.打包"></a>2.打包</h3><pre class=" language-javascript"><code class="language-javascript">hexo g</code></pre><h3 id="3-运行本地-hexo"><a href="#3-运行本地-hexo" class="headerlink" title="3.运行本地 hexo"></a>3.运行本地 hexo</h3><pre class=" language-javascript"><code class="language-javascript">hexo s</code></pre><h3 id="4-部署到-github-和-coding"><a href="#4-部署到-github-和-coding" class="headerlink" title="4.部署到 github 和 coding"></a>4.部署到 github 和 coding</h3><p>因为 github 和 coding 使用了同一个公钥，所以推送时会触发多个仓库。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//部署前先清理一下缓存命令</span>hexo clean<span class="token comment" spellcheck="true">//部署</span>hexo g <span class="token operator">-</span>d</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>serverless 和 hexo快速搭建静态博客</title>
      <link href="/leader755/2093.html"/>
      <url>/leader755/2093.html</url>
      
        <content type="html"><![CDATA[<p>##</p><h2 id="1-首先搭建一个用-hexo-快速搭建一个博客"><a href="#1-首先搭建一个用-hexo-快速搭建一个博客" class="headerlink" title="1.首先搭建一个用 hexo 快速搭建一个博客"></a>1.首先搭建一个用 hexo 快速搭建一个博客</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//全局安装脚手架 hexo-cli</span>npm install hexo<span class="token operator">-</span>cli <span class="token operator">-</span>g<span class="token comment" spellcheck="true">//初始化一个 blog</span>hexo init blog<span class="token comment" spellcheck="true">//访问本地博客(默认地址为：localhost:4000)</span>cd bloghexo s</code></pre><h2 id="2-serverless-文档（推荐）"><a href="#2-serverless-文档（推荐）" class="headerlink" title="2.serverless 文档（推荐）"></a>2.serverless 文档（推荐）</h2><p>github 官方中文文档：<a href="https://github.com/serverless/serverless/blob/master/README_CN.md" target="_blank" rel="noopener">https://github.com/serverless/serverless/blob/master/README_CN.md</a><br>serverless 中文博客： <a href="https://serverlesscloud.cn/" target="_blank" rel="noopener">https://serverlesscloud.cn/</a></p><h2 id="3-使用-npm-安装"><a href="#3-使用-npm-安装" class="headerlink" title="3.使用 npm 安装"></a>3.使用 npm 安装</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//全局安装 serverless</span>npm install <span class="token operator">-</span>g serverless</code></pre><h2 id="4-在-blog-的根目录创建一个-serverless-yml-文件"><a href="#4-在-blog-的根目录创建一个-serverless-yml-文件" class="headerlink" title="4.在 blog 的根目录创建一个 serverless.yml 文件"></a>4.在 blog 的根目录创建一个 serverless.yml 文件</h2><p>复制以下文件内容：唯一注意的地方就是 src 的路径：根据实际更改（即为博客的 index.html 网页）</p><pre class=" language-javascript"><code class="language-javascript">myWebsite<span class="token punctuation">:</span>  component<span class="token punctuation">:</span> <span class="token string">'@serverless/tencent-website'</span>  inputs<span class="token punctuation">:</span>    code<span class="token punctuation">:</span>      src<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token operator">/</span><span class="token keyword">public</span>      index<span class="token punctuation">:</span> index<span class="token punctuation">.</span>html      error<span class="token punctuation">:</span> index<span class="token punctuation">.</span>html    region<span class="token punctuation">:</span> ap<span class="token operator">-</span>guangzhou    bucketName<span class="token punctuation">:</span> my<span class="token operator">-</span>bucket</code></pre><h2 id="5-将静态博客发布到-tencent-serverless"><a href="#5-将静态博客发布到-tencent-serverless" class="headerlink" title="5.将静态博客发布到 tencent-serverless"></a>5.将静态博客发布到 tencent-serverless</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//首先将 hexo 中博客打包</span>heox g<span class="token comment" spellcheck="true">//将本地的博客部署到 serverless</span>serverless<span class="token operator">/</span>sls <span class="token operator">--</span>debug</code></pre><h2 id="6-稍等片刻可以在-命令行工具看到以下"><a href="#6-稍等片刻可以在-命令行工具看到以下" class="headerlink" title="6.稍等片刻可以在 命令行工具看到以下"></a>6.稍等片刻可以在 命令行工具看到以下</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588607113775-6a30d4dc-3c70-4506-9f5b-7af5a07b4e05.png#align=left&display=inline&height=567&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1134&originWidth=1298&size=453581&status=done&style=none&width=649" alt="image.png"><br>此时需要的操作就是用手机微信去扫描（此处会检测是否有腾讯云账号，没有会提示注册，有会直接成功）并返回以下内容：此处就是部署成功，并返回地址，可以直接访问。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588607252405-a0fad8a2-f2d5-49ef-8101-09a10eec3916.png#align=left&display=inline&height=264&margin=%5Bobject%20Object%5D&name=image.png&originHeight=528&originWidth=1274&size=364624&status=done&style=none&width=637" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> serverless </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用的问题指南</title>
      <link href="/leader755/52181.html"/>
      <url>/leader755/52181.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-hexo-g-d-会报错"><a href="#1-hexo-g-d-会报错" class="headerlink" title="1.hexo g -d 会报错"></a>1.hexo g -d 会报错</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588475689582-0959dce9-cdf9-4e4f-937b-175fcab6f7ce.png#align=left&display=inline&height=127&margin=%5Bobject%20Object%5D&name=image.png&originHeight=254&originWidth=1160&size=179534&status=done&style=none&width=580" alt="image.png"><br>win 本地仓库：将 https 改为 ssh</p><pre class=" language-javascript"><code class="language-javascript">deploy：   type：git   repo：git@github<span class="token punctuation">.</span>com<span class="token punctuation">:</span>Leader755<span class="token operator">/</span>leader755<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io<span class="token punctuation">.</span>git   branch：master</code></pre><p>mac:</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎使用 MWeb</title>
      <link href="/leader755/18674.html"/>
      <url>/leader755/18674.html</url>
      
        <content type="html"><![CDATA[<p>MWeb 是专业的 Markdown 写作、记笔记、静态博客生成软件，目前已支持 Mac，iPad 和 iPhone。MWeb 有以下特色：</p><h2 id="软件本身："><a href="#软件本身：" class="headerlink" title="软件本身："></a>软件本身：</h2><ul><li>使用原生的 macOS 技术打造，追求与系统的完美结合。</li><li>原则上，首先是追求界面简洁和高性能，然后才是强大易用，功能全面。</li></ul><h2 id="Markdown-语法："><a href="#Markdown-语法：" class="headerlink" title="Markdown 语法："></a>Markdown 语法：</h2><ul><li>使用 GitHub Flavored Markdown 语法，简称 GFM 语法。</li><li>支持表格、TOC、LaTeX、代码块、任务列表、脚注等。</li><li>画图库支持 mermaid, viz, ECharts, PlantUML, Sequence, Flow。</li></ul><h2 id="Markdown-辅助："><a href="#Markdown-辅助：" class="headerlink" title="Markdown 辅助："></a>Markdown 辅助：</h2><ul><li>支持截图并粘贴、复制并粘贴、拖拽等方式插入图片并直接显示在编辑器内。</li><li>在兼容 Markdown 语法的情况下支持设置图片宽度。</li><li>好用的表格插入和 LaTeX 书写辅助。</li></ul><h2 id="Markdown-输出："><a href="#Markdown-输出：" class="headerlink" title="Markdown 输出："></a>Markdown 输出：</h2><ul><li>支持导出为图片、HTML、Epub、PDF、RTF、Docx。</li><li>支持发布到 WordPress、支持 Metaweblog API 协议的服务、Wordpress.com、印象笔记（Evernote）、Blogger、Medium、Tumblr、语雀、Ghost、少数派 Matrix。</li><li>图片上传服务（图床）支持 Imgur、七牛云、又拍云、腾讯云 COS、阿里云 OSS、SM.MS 和自定义的图床服务。</li></ul><h2 id="Markdown-笔记："><a href="#Markdown-笔记：" class="headerlink" title="Markdown 笔记："></a>Markdown 笔记：</h2><ul><li>强大的文档库支持分类树和标签管理文档，文档可归类于多个分类，可以把分类整个导出为 Epub、PDF 和生成静态网站。非常合适用于笔记、个人知识收集、管理和输出。</li><li>快速笔记：随意增加笔记及图片等素材，支持以天为单位把增加的素材组合在一个文档内，方便整理及记录历史收集情况。</li><li>快速搜索：目前已支持全局快捷键调出搜索。</li></ul><h2 id="外部-Markdown-文档："><a href="#外部-Markdown-文档：" class="headerlink" title="外部 Markdown 文档："></a>外部 Markdown 文档：</h2><ul><li>外部 Markdown 文档使用外部模式管理。外部模式使用目录树的方式编辑和管理你的 Markdown 文档，还能很好的支持 GitBook、Jekyll、Hexo 等等编辑和图片插入。</li></ul><h2 id="MWeb-文档："><a href="#MWeb-文档：" class="headerlink" title="MWeb 文档："></a>MWeb 文档：</h2><p>如果要更详细了解 MWeb，建议你一定要去看一下官网的帮助文档，网址为：<a href="https://zh.mweb.im/help.html" target="_blank" rel="noopener">https://zh.mweb.im/help.html</a>。我们建议在使用文档库之前，一定要阅读一下 <a href="https://zh.mweb.im/mweb-library.html" target="_blank" rel="noopener">MWeb 文档库详细介绍</a> 这篇文章，以便更好的使用文档库。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何绕开referrer防盗链</title>
      <link href="/leader755/49766.html"/>
      <url>/leader755/49766.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-referrer"><a href="#什么是-referrer" class="headerlink" title="什么是 referrer"></a>什么是 referrer</h2><p>当一用户点击当前页面中的一个链接，然后跳转到目标页面时，目标页面会收到一个信息，即用户是从哪个源链接跳转过来的。如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1595703140078-870fec1d-0742-4dea-828a-1f32819af187.png#align=left&display=inline&height=543&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1086&originWidth=1184&size=153142&status=done&style=none&width=592" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/webp/241787/1595702418075-1743cd6e-ed7c-4b5b-9f96-7f89fff17373.webp#align=left&display=inline&height=543&margin=%5Bobject%20Object%5D&originHeight=543&originWidth=896&size=0&status=done&style=none&width=896" alt=""><br>也就是说，当你发起一个 http 请求，请求头中的<code>referrer</code>字段就说明了你是从哪个页面发起该请求的。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>有时候我们需要控制这个<code>referrer</code>字段的值，即是否让其显示在请求头中，或者是否显示完整路径等。尤其是在以下两个使用场景：</p><h3 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h3><p>在社交网站的个人中心页面，也许会存在一些外链，这时候社交网站肯定不希望用户在点击这些链接跳转到其他第三方网站时会将自己个人中心的 URL 信息显示在<code>referrer</code>字段中传过去，尤其是个人中心页面的 URL 往往会带着用户数据和一些敏感信息。这时候可以选择不显示来源页面 URL 信息或者只显示一个网站根地址 hostname。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>有些使用了 https 的网站，可能在 URL 中使用一个参数（sid）来作为用户身份凭证，而又需要引入其他 https 网站的资源，这种情况，网站肯定不希望泄露用户的身份凭证信息。当 https 网站需要引入不安全的 http 网站的资源或者有链接要跳转到 http 网站时，这时候将 https 源网站的 URL 信息传过去也是不太安全的。<br>当然还有其他情况下需要<code>referrer</code>的值，比如最近公司所做的项目中，有一个请求由于请求头过大导致响应是 400，我们的<code>Referrer Policy</code>是默认的情况，显示的<code>referrer</code>是完整的 URL 信息，该 URL 带了很多敏感数据比如加密后的 token，sessionID 等，长度特别长，请求头中的 cookie 和请求的 URL 也带着很大块的信息，最终我们决定让<code>referrer</code>只携带网站根地址的信息而不是其完整路径，由此减小了 header 的大小。</p><h2 id="Referrer-Policy"><a href="#Referrer-Policy" class="headerlink" title="Referrer-Policy"></a>Referrer-Policy</h2><p><code>Referrer-Policy</code>的作用就是为了控制请求头中<code>referrer</code>的内容，目前<code>Referrer-Policy</code>只包含以下几种值：</p><table><thead><tr><th align="left">策略名称</th><th align="left">属性值（新）</th><th align="left">属性值（旧）</th></tr></thead><tbody><tr><td align="left">No Referrer</td><td align="left">no-referrer</td><td align="left">never</td></tr><tr><td align="left">No Referrer When Downgrade</td><td align="left">no-referrer-when-downgrade</td><td align="left">default</td></tr><tr><td align="left">Origin Only</td><td align="left">origin</td><td align="left">-</td></tr><tr><td align="left">Origin When Cross-origin</td><td align="left">origin-when-crossorigin</td><td align="left">-</td></tr><tr><td align="left">Unsafe URL</td><td align="left">unsafe-url</td><td align="left">always</td></tr></tbody></table><p>简单介绍下这五种类型的具体含义：</p><ul><li><strong>No Referrer</strong>：任何情况下都不发送 Referrer 信息；</li><li><strong>No Referrer When Downgrade</strong>：仅当发生协议降级（如 HTTPS 页面引入 HTTP 资源，从 HTTPS 页面跳到 HTTP 等）时不发送 Referrer 信息。这个规则是现在大部分浏览器默认所采用的；</li><li><strong>Origin Only</strong>：发送只包含 host 部分的 Referrer。启用这个规则，无论是否发生协议降级，无论是本站链接还是站外链接，都会发送 Referrer 信息，但是只包含协议 + host 部分（不包含具体的路径及参数等信息）；</li><li><strong>Origin When Cross-origin</strong>：仅在发生跨域访问时发送只包含 host 的 Referrer，同域下还是完整的。它与 <code>Origin Only</code> 的区别是多判断了是否 <code>Cross-origin</code>。需要注意的是协议、域名和端口都一致，才会被浏览器认为是同域；</li><li><strong>Unsafe URL</strong>：无论是否发生协议降级，无论是本站链接还是站外链接，统统都发送 Referrer 信息。正如其名，这是最宽松而最不安全的策略；</li></ul><h2 id="Referrer-Policy-更改方法"><a href="#Referrer-Policy-更改方法" class="headerlink" title="Referrer-Policy 更改方法"></a>Referrer-Policy 更改方法</h2><p>可以有以下 4 种方法：</p><p><strong>1.</strong> <code>Referrer-Policy</code> HTTP <code>header</code>设置：</p><pre class=" language-javascript"><code class="language-javascript">Referrer<span class="token operator">-</span>Policy<span class="token punctuation">:</span> origin</code></pre><p><strong>2.</strong> 通过<code>&lt;meta&gt;</code>元素改变<code>Referrer Policy</code>，直接修改名为<code>referrer</code>的内容</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"referrer"</span> content<span class="token operator">=</span><span class="token string">"origin"</span><span class="token operator">></span>复制代码</code></pre><p><strong>3.</strong> 给 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a" target="_blank" rel="noopener"><code>&lt;a&gt;</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area" target="_blank" rel="noopener"><code>&lt;area&gt;</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img" target="_blank" rel="noopener"><code>&lt;img&gt;</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe" target="_blank" rel="noopener"><code>&lt;iframe&gt;</code></a>, 或者<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link" target="_blank" rel="noopener"><code>&lt;link&gt;</code></a>元素设置<code>referrerpolicy</code>属性</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://example.com"</span> referrerpolicy<span class="token operator">=</span><span class="token string">"origin"</span><span class="token operator">></span>复制代码</code></pre><p><strong>4.</strong> 如需设置不显示<code>referrer</code>信息时，也可以给 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a" target="_blank" rel="noopener"><code>&lt;a&gt;</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area" target="_blank" rel="noopener"><code>&lt;area&gt;</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link" target="_blank" rel="noopener"><code>&lt;link&gt;</code></a>元素设置<code>rel</code>的链接关系。</p><pre><code>&lt;a href=&quot;http://example.com&quot; rel=&quot;noreferrer&quot;&gt;复制代码</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用何种<code>Referrer Policy</code>取决于网站的需求，但是一般来说，<code>unsafe-url</code>是不太建议用的，同样，如果是只想显示网站的根地址，那么建议用<code>strict-origin</code>和 s<code>trict-origin-when-cross-origin</code>。如果 URL 中没有什么敏感信息，那就默认使用<code>no-referrer-when-downgrade</code>。</p><p>特别声明，文章转载自：<a href="https://juejin.im/post/5cd81b59518825686a06fd05" target="_blank" rel="noopener">https://juejin.im/post/5cd81b59518825686a06fd05</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> referrer </tag>
            
            <tag> 防盗链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo+ 又拍云创建个人图床工具</title>
      <link href="/leader755/50207.html"/>
      <url>/leader755/50207.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-首先注册又拍云账号"><a href="#1-首先注册又拍云账号" class="headerlink" title="1.首先注册又拍云账号"></a>1.首先注册又拍云账号</h2><p>点击云存储，创建新的云存储服务<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599998647052-f7345059-98b6-42c3-9301-7d90e86b1d70.png#align=left&display=inline&height=498&margin=%5Bobject%20Object%5D&name=image.png&originHeight=996&originWidth=2544&size=148631&status=done&style=none&width=1272" alt="image.png"></p><h2 id="2-创建服务"><a href="#2-创建服务" class="headerlink" title="2.创建服务"></a>2.创建服务</h2><p>设置服务名称（唯一的性），加速区域 看自己需求决定。选择暂不授权。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599998887443-d2990b95-c77b-4547-8ac7-e214f4dc4023.png#align=left&display=inline&height=942&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1884&originWidth=2472&size=266401&status=done&style=none&width=1236" alt="image.png"><br>点击创建，创建成功过后会弹出成功框。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599998936673-060b3409-6d08-4985-8174-a9d9b9213291.png#align=left&display=inline&height=661&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1322&originWidth=2232&size=229931&status=done&style=none&width=1116" alt="image.png"></p><h2 id="3-进入配置，点击进行绑定自己的域名"><a href="#3-进入配置，点击进行绑定自己的域名" class="headerlink" title="3.进入配置，点击进行绑定自己的域名"></a>3.进入配置，点击进行绑定自己的域名</h2><blockquote><p>划重点，敲黑板（估计很多同学会搞不清楚，测试域名，博客域名，博客图片域名，有什么关系）<br>这里详细介绍下 ：<br>又拍云测试域名（leader755-upyun.b0.aicdn.com,博客域名(leader755.com),图片的域名（img.leader755.com）<br>说到这里，可能有同学要问，为什么要搞出一个图片域名，直接用博客域名不就行了。博客域名肯定需要作为 A 级域名进行解析，绑定到 ip。所以使用了 图片域名进行解析。</p></blockquote><h3 id="1-gt-绑定域名（域名需要备案，10-分钟以内审核完毕）"><a href="#1-gt-绑定域名（域名需要备案，10-分钟以内审核完毕）" class="headerlink" title="1&gt;绑定域名（域名需要备案，10 分钟以内审核完毕）"></a>1&gt;绑定域名（域名需要备案，10 分钟以内审核完毕）</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1599999259811-6205b1a2-f624-40e6-bd65-9dad75eeb9b6.png#align=left&display=inline&height=666&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1332&originWidth=2298&size=201493&status=done&style=none&width=1149" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1600002000265-b2543dc8-3d7a-41ce-aaf3-717a9fadafe8.png#align=left&display=inline&height=690&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1380&originWidth=2552&size=236696&status=done&style=none&width=1276" alt="image.png"></p><h3 id="2-gt-去阿里云的域名中解析域名"><a href="#2-gt-去阿里云的域名中解析域名" class="headerlink" title="2&gt;去阿里云的域名中解析域名"></a>2&gt;去阿里云的域名中解析域名</h3><blockquote><p><strong>记住必须选择 CNAME，这就是为啥不用直接用博客的域名绑定而用图片域名，博客的域名一般为 A 。</strong> &gt; <strong>到这一步，又拍云的域名绑定子自定义域名，自定义域名解析到又拍云测试域名上。已经完成了域名的绑定了。</strong></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1600002447390-09cd0067-3fc8-4d68-8903-d7d42641359b.png#align=left&display=inline&height=620&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1240&originWidth=1554&size=111447&status=done&style=none&width=777" alt="image.png"></p><h2 id="4-点击账户管理，添加操作员"><a href="#4-点击账户管理，添加操作员" class="headerlink" title="4.点击账户管理，添加操作员"></a>4.点击账户管理，添加操作员</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1595048861058-8644fd49-a611-4466-8248-61fb8a8dc573.png#align=left&display=inline&height=681&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1362&originWidth=2558&size=215488&status=done&style=none&width=1279" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1600003497722-aac2e4da-1222-4682-84f4-17b12bcf15b0.png#align=left&display=inline&height=559&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1118&originWidth=1182&size=125643&status=done&style=none&width=591" alt="image.png"></p><h2 id="5-PicGo-的设置"><a href="#5-PicGo-的设置" class="headerlink" title="5.PicGo 的设置"></a>5.PicGo 的设置</h2><ul><li><strong>存储空间和存储员都是自己配置好的，操作密码也是复制好的。</strong></li><li><strong>注意的是加速域名最好加上<code>http/https</code>，不然会无法在 PicGo 预览</strong></li><li><strong>指定存储路径可填可不填</strong></li><li><strong>设置网址后缀 可不填（可用来加密）</strong><blockquote><p><strong>这里说下我自己的对图片的后缀处理：</strong> &gt; <strong>“**</strong>?*<strong>*(此处必须使用问好，不然识别有问题)”+”**</strong>@*<strong>*“+”**</strong>自定义字母*<strong>*“+”**</strong>@*<strong>*“+ “**</strong>文件秘钥*<strong>*“ *<em>=》 *</em>?@自定义字母@文件秘钥</strong></p></blockquote></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1600003658469-54190b09-bd3a-4fee-97c1-6611535cb1bd.png#align=left&display=inline&height=446&margin=%5Bobject%20Object%5D&name=image.png&originHeight=892&originWidth=1584&size=931034&status=done&style=none&width=792" alt="image.png"></p><h2 id="6-又拍云的图片加密防盗"><a href="#6-又拍云的图片加密防盗" class="headerlink" title="6.又拍云的图片加密防盗"></a>6.又拍云的图片加密防盗</h2><h3 id="1-gt-开启文件加密"><a href="#1-gt-开启文件加密" class="headerlink" title="1&gt;开启文件加密"></a>1&gt;开启文件加密</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1600003879520-54ecd63a-ad4d-4f11-96fb-306875cf7e18.png#align=left&display=inline&height=648&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1296&originWidth=2430&size=255465&status=done&style=none&width=1215" alt="image.png"></p><h3 id="2-gt-Referer-防盗链"><a href="#2-gt-Referer-防盗链" class="headerlink" title="2&gt;Referer 防盗链"></a>2&gt;Referer 防盗链</h3><p>访问控制–&gt; Referer 防盗链<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1600004636572-e809f82e-050d-4eda-a793-b9887d929924.png#align=left&display=inline&height=249&margin=%5Bobject%20Object%5D&name=image.png&originHeight=498&originWidth=2222&size=65656&status=done&style=none&width=1111" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1600004658635-2217485e-64da-4e93-a0b7-f1aff36ee852.png#align=left&display=inline&height=504&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1008&originWidth=2558&size=130351&status=done&style=none&width=1279" alt="image.png"></p><h3 id="3-gt-其他处理看个人需求"><a href="#3-gt-其他处理看个人需求" class="headerlink" title="3&gt;其他处理看个人需求"></a>3&gt;其他处理看个人需求</h3>]]></content>
      
      
      <categories>
          
          <category> 图床 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PicGo </tag>
            
            <tag> 又拍云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 hexo 博客的图片链接失效问题</title>
      <link href="/leader755/3275.html"/>
      <url>/leader755/3275.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-首先找到-hexo-博客的主题文件夹目录"><a href="#1-首先找到-hexo-博客的主题文件夹目录" class="headerlink" title="1.首先找到 hexo 博客的主题文件夹目录"></a>1.首先找到 hexo 博客的主题文件夹目录</h2><pre class=" language-javascript"><code class="language-javascript">D<span class="token punctuation">:</span> \Blog_leader755\Blog_leader755\themes\Blog_leader755\themes\halo\Blog_leader755\themes\halo\layout\Blog_leader755\themes\halo\layout\_partial\Blog_leader755\themes\halo\layout\_partial\head<span class="token punctuation">.</span>ejs<span class="token punctuation">;</span></code></pre><p>修改上述路径的文件 head.ejs ，因为每个页面都会包含 head 这个文件，在里面加上一行代码就能解决。</p><h2 id="2-加入此行代码到页面"><a href="#2-加入此行代码到页面" class="headerlink" title="2.加入此行代码到页面"></a>2.加入此行代码到页面<head><link rel=manifest href=/manifest.json><meta name="generator" content="Hexo 4.1.1"><link rel="alternate" href="/atom.xml" title="leader755 Blogs" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head></h2><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"referrer"</span> content<span class="token operator">=</span><span class="token string">"no-referrer"</span> <span class="token operator">/</span><span class="token operator">></span></code></pre><h2 id="3-暂时解决载了外链限制的问题"><a href="#3-暂时解决载了外链限制的问题" class="headerlink" title="3.暂时解决载了外链限制的问题"></a>3.暂时解决载了外链限制的问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1595671131433-aced588a-b41e-406a-acf6-6133df722701.png#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&name=image.png&originHeight=390&originWidth=1288&size=105257&status=done&style=none&width=644" alt="image.png"></p><h2 id="4-随之而来的问题出现了"><a href="#4-随之而来的问题出现了" class="headerlink" title="4.随之而来的问题出现了"></a>4.随之而来的问题出现了</h2><p>如果你同时使用了 <a href="https://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子 (https://busuanzi.ibruce.info/)</a>统计，你会发现问题，查看控制台会出现不蒜子出现跨域的请求。这是为什么呢。由于使用了 no-referrer。</p><p>关于 no-refferrer 的相关问题可以自行搜索，在这里就不一一解释，直接给出解决方案。</p><h2 id="5-目前的解决方案"><a href="#5-目前的解决方案" class="headerlink" title="5.目前的解决方案"></a>5.目前的解决方案</h2><h3 id="1-gt-方案-："><a href="#1-gt-方案-：" class="headerlink" title="1&gt;方案-："></a>1&gt;方案-：</h3><p>按照网友的说法是，meta 是可以放在 <code>&lt;body&gt;</code> 里的吧。<br>所以把 <code>&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;</code> 放到 <strong>archive-book.ejs</strong> 的最前面。<br>然后在网页结构里就会是这个样子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">...</span><span class="token operator">...</span><span class="token operator">&lt;</span>head<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"main-center no-sidebar okayNav-loaded"</span> <span class="token operator">...</span><span class="token operator">></span>  <span class="token operator">&lt;</span>header <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"header"</span> <span class="token operator">...</span><span class="token operator">></span>  <span class="token operator">&lt;</span>aside <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sidebar"</span> <span class="token operator">...</span><span class="token operator">></span>  <span class="token operator">&lt;</span>main <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"main"</span> role<span class="token operator">=</span><span class="token string">"main"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"referrer"</span> content<span class="token operator">=</span><span class="token string">"never"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>article <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"article article-links article-type-list"</span> <span class="token operator">...</span><span class="token operator">></span><span class="token operator">...</span><span class="token operator">...</span></code></pre><p>在它之上的所有链接都会带来源信息，之后的就是 no-referrer 了。所以理论上也就规避了图片的防盗链了。<br>划重点，但是并没有如愿解决不蒜子的跨域问题。</p><h3 id="2-gt-方案二：终极解决方案"><a href="#2-gt-方案二：终极解决方案" class="headerlink" title="2&gt;方案二：终极解决方案"></a>2&gt;方案二：终极解决方案</h3><p>由于可以给  <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a" target="_blank" rel="noopener"><code>&lt;a&gt;</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area" target="_blank" rel="noopener"><code>&lt;area&gt;</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img" target="_blank" rel="noopener"><code>&lt;img&gt;</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe" target="_blank" rel="noopener"><code>&lt;iframe&gt;</code></a>, 或者<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link" target="_blank" rel="noopener"><code>&lt;link&gt;</code></a>元素设置<code>referrerpolicy</code>属性。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://example.com"</span> referrerpolicy<span class="token operator">=</span><span class="token string">"no-referrer"</span><span class="token operator">></span></code></pre><p>所以，可以为所有文章内的图片动态添加 referrerpolicy 属性，通过查看控制台找到图片 img 的类名<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1595702030353-1e6505c0-c918-4e4a-864b-12077c39bc66.png#align=left&display=inline&height=275&margin=%5Bobject%20Object%5D&name=image.png&originHeight=550&originWidth=2056&size=252165&status=done&style=none&width=1028" alt="image.png"></p><p>在文件夹中全局搜索类名，找到如下代码：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1595702163492-a013ed03-25f0-4474-a3d1-39aa2753081c.png#align=left&display=inline&height=387&margin=%5Bobject%20Object%5D&name=image.png&originHeight=774&originWidth=1204&size=160420&status=done&style=none&width=602" alt="image.png"></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//为文章内的图片添加no-referrer来隐藏referer（解决第三方图片外链不显示问题）</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"referrerPolicy"</span><span class="token punctuation">,</span> <span class="token string">"no-referrer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>注意每个主题中的文章下的图片类名应该都不一致，所以类名需要根据实际情况，在控制台中查找文章中的图片类名，再去找相应的代码，为其动态添加 referrerPolicy 属性。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片链接失效 </tag>
            
            <tag> 第三方链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.mac 上使用 vi</title>
      <link href="/leader755/38612.html"/>
      <url>/leader755/38612.html</url>
      
        <content type="html"><![CDATA[<p>上一篇博客提到 mac 进入 vi 编辑界面，复制 ssh key。这篇就是介绍如何保存退出 vi。</p><p>如果是 vi，则：<br><strong>Esc</strong> 退出编辑模式，输入以下命令：<br><strong>:wq</strong> 保存后退出 vi，若为 :wq! 则为强制储存后退出（常用）<br><strong>:w</strong> 保存但不退出（常用）<br><strong>:w!</strong> 若文件属性为『只读』时，强制写入该档案<br><strong>:q</strong> 离开 vi （常用）<br><strong>:q!</strong> 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。<br><strong>:e!</strong> 将档案还原到最原始的状态！</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> vi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.mac上生成SSH key与GitHub通信</title>
      <link href="/leader755/10760.html"/>
      <url>/leader755/10760.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-检查-SSH-key-是否存在"><a href="#1-检查-SSH-key-是否存在" class="headerlink" title="1.检查 SSH key 是否存在"></a>1.检查 SSH key 是否存在</h2><p>在终端输入：</p><pre class=" language-javascript"><code class="language-javascript">ls <span class="token operator">-</span>a <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>ssh</code></pre><p>如果没有，终端显示如下：</p><blockquote><p>No such file or directory</p></blockquote><p>如果已经存在，则会显示 id_rsa 和 id_rsa.pub</p><ul><li>查看 .ssh</li></ul><pre class=" language-javascript"><code class="language-javascript">ls <span class="token operator">-</span>a <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>sshcd <span class="token punctuation">.</span>sshcat id_rsa<span class="token punctuation">.</span>pub <span class="token comment" spellcheck="true">//查看公钥</span>cat id_rsa     <span class="token comment" spellcheck="true">//查看私钥</span></code></pre><h2 id="2-生成新的-SSH-key"><a href="#2-生成新的-SSH-key" class="headerlink" title="2.生成新的 SSH key"></a>2.生成新的 SSH key</h2><h4 id="1-设置-username-和-email（github-每次-commit-都会记录他们）"><a href="#1-设置-username-和-email（github-每次-commit-都会记录他们）" class="headerlink" title="1.设置 username 和 email（github 每次 commit 都会记录他们）"></a>1.设置 username 和 email（github 每次 commit 都会记录他们）</h4><pre class=" language-javascript"><code class="language-javascript">git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"Leader755"</span>git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"1181012791@qq.com"</span></code></pre><h4 id="2-通过终端命令创建-ssh-key"><a href="#2-通过终端命令创建-ssh-key" class="headerlink" title="2.通过终端命令创建 ssh key"></a>2.通过终端命令创建 ssh key</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//其中 your_email@example.com 为你在 GitHub 注册时的邮箱</span>'ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa <span class="token operator">-</span>C <span class="token string">"1181012791@qq.com"</span></code></pre><p><a href="https://www.cnblogs.com/jarod99/p/7251361.html" target="_blank" rel="noopener">Bad escape character ‘ygen’ 错误原因!</a></p><blockquote><p>ssh-keygen -t rsa -C “邮箱”<br>ssh-keygen 命令中间没有空格，如果在 ssh 后面加上空格，会得到 Bad escape character ‘ygen’.的错误。</p></blockquote><p>成功后终端显示如下：</p><blockquote><p>Generating public/private rsa key pair.<br>Enter file in which to save the key (/Users/xxx/.ssh/id_rsa):</p></blockquote><p>提示你保存 .ssh/id_rsa 的路径，这里直接 enter</p><blockquote><p>Created directory ‘/Users/xxx/.ssh’.<br>Enter passphrase (empty for no passphrase):</p></blockquote><p>提示输入 passphrase，每次与 GitHub 通信都会要求输入 passphrase，以避免某些「失误」，建议输入<br><strong>这里有个问题需要注意，那就是当你在这里输入密码，以后在连接 gitHub 去 push 代码的时候都需要输入密码，非常蛋疼，所以在这里最好直接回车过即可，不用输入密码。**</strong>()**</p><h4 id="3-即连续-enter-3-次，就会生成-key。"><a href="#3-即连续-enter-3-次，就会生成-key。" class="headerlink" title="3.即连续 enter 3 次，就会生成 key。"></a>3.即连续 enter 3 次，就会生成 key。</h4><p>成功后终端显示：</p><blockquote><p>Your identification has been saved in /Users/xxx/.ssh/id_rsa.<br>Your public key has been saved in /Users/xxx/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48 <a href="mailto:your_email@example.com">your_email@example.com</a><br>The key’s randomart image is:（后面图形省略）</p></blockquote><h2 id="3-添加-key-到-SSH"><a href="#3-添加-key-到-SSH" class="headerlink" title="3.添加 key 到 SSH"></a>3.添加 key 到 SSH</h2><p>输入命令：</p><pre class=" language-javascript"><code class="language-javascript">ssh<span class="token operator">-</span>add <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>ssh<span class="token operator">/</span>id_rsa</code></pre><p>此时会要求输入 passphrase，输入步骤二中填的 passphrase<br>成功后，终端显示：</p><blockquote><p>Identity added: /Users/xxx/.ssh/id_rsa (/Users/xxx/.ssh/id_rsa)</p></blockquote><p>最后，在 /Users/xxx/.ssh/ 生成两个文件，id_rsa 和 id_rsa.pub<br>此时，SSH key 已经生成成功</p><h2 id="4-添加-SSH-key-到-GitHub-和-coding"><a href="#4-添加-SSH-key-到-GitHub-和-coding" class="headerlink" title="4.添加 SSH key 到 GitHub 和 coding"></a>4.添加 SSH key 到 GitHub 和 coding</h2><h4 id="1-复制-id-rsa-pub-中的所有内容"><a href="#1-复制-id-rsa-pub-中的所有内容" class="headerlink" title="1.复制 id_rsa.pub 中的所有内容,"></a>1.复制 id_rsa.pub 中的所有内容,</h4><p>打开 id_rsa.pub，终端命令：</p><pre class=" language-javascript"><code class="language-javascript">vim<span class="token regex">/cat   ~/</span><span class="token punctuation">.</span>ssh<span class="token operator">/</span>id_rsa<span class="token punctuation">.</span>pub</code></pre><p>手动复制以 ssh-rsa 到以 <a href="mailto:your_email@example.com">your_email@example.com</a> 结尾的所有内容</p><p>或者直接输入命令复制 id_rsa.pub 中的所有内容，终端命令：</p><pre class=" language-javascript"><code class="language-javascript">pbcopy <span class="token operator">&lt;</span> <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>ssh<span class="token operator">/</span>_adirs<span class="token punctuation">.</span>pub<span class="token punctuation">;</span></code></pre><h2 id="5-登录-GitHub-和-coding"><a href="#5-登录-GitHub-和-coding" class="headerlink" title="5.登录 GitHub 和 coding"></a>5.登录 GitHub 和 coding</h2><h4 id="github：打开个人-Settings–-gt-SSH-keys–-gt-Add-SSH-key"><a href="#github：打开个人-Settings–-gt-SSH-keys–-gt-Add-SSH-key" class="headerlink" title="github：打开个人 Settings–&gt;SSH keys–&gt;Add SSH key"></a>github：打开个人 Settings–&gt;SSH keys–&gt;Add SSH key</h4><h4 id="coding：打开个人设置–-gt-SSH-公钥-–-gt-新增公钥"><a href="#coding：打开个人设置–-gt-SSH-公钥-–-gt-新增公钥" class="headerlink" title="coding：打开个人设置–&gt;SSH 公钥 –&gt;新增公钥"></a>coding：打开个人设置–&gt;SSH 公钥 –&gt;新增公钥</h4><p>Title 随便写<br>Key 粘贴之前复制的内容<br>这样 SSH key 就添加的 GitHub 或者 coding.<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588333300890-a4b759da-4e1d-4837-8cc3-c2c3b1fa1f01.png#align=left&display=inline&height=565&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1130&originWidth=1902&size=254444&status=done&style=none&width=951" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1588333326072-e78c1bf9-ed79-4811-bbc9-a203e423b57a.png#align=left&display=inline&height=560&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1120&originWidth=1946&size=357795&status=done&style=none&width=973" alt="image.png"></p><h2 id="6-检测-SSH-key"><a href="#6-检测-SSH-key" class="headerlink" title="6.检测 SSH key"></a>6.检测 SSH key</h2><p>输入命令：</p><pre class=" language-javascript"><code class="language-javascript">ssh git@github<span class="token punctuation">.</span>com</code></pre><p>此时会验证 SSH key 是否可以访问 GitHub<br>成功显示如下：</p><blockquote><p>Hi your_name! You’ve successfully authenticated, but GitHub does not provide shell access.<br>Connection to github.com closed.</p></blockquote><blockquote><p>以上为提示内容，不过这里还是有一个需要注意的地方，如果没有上面的成功提示输出的话也不要害怕，我们可以先自己在本地建立一个 gitHub 仓库，然后进行 push 操作，如果 push 成功那么设置是成功的，如果 push 不上去的话再去检查。</p></blockquote><h2 id="7-使用-git-去创建一个-ssh-key-就完成了"><a href="#7-使用-git-去创建一个-ssh-key-就完成了" class="headerlink" title="7.使用 git 去创建一个 ssh key 就完成了"></a>7.使用 git 去创建一个 ssh key 就完成了</h2><h2 id="8-已经存在-ssh，创建新密钥"><a href="#8-已经存在-ssh，创建新密钥" class="headerlink" title="8.已经存在 ssh，创建新密钥"></a>8.已经存在 ssh，创建新密钥</h2><h3 id="1-gt-进入-ssh-目录"><a href="#1-gt-进入-ssh-目录" class="headerlink" title="1&gt;进入 ssh 目录"></a>1&gt;进入 ssh 目录</h3><pre class=" language-javascript"><code class="language-javascript">cd <span class="token operator">~</span><span class="token regex">/.ssh/</span></code></pre><h3 id="2-gt-用-ssh-keygen-命令生成一组新的-id-rsa-new-和-id-rsa-new-pub"><a href="#2-gt-用-ssh-keygen-命令生成一组新的-id-rsa-new-和-id-rsa-new-pub" class="headerlink" title="2&gt;用 ssh-keygen 命令生成一组新的 id_rsa_new 和 id_rsa_new.pub"></a>2&gt;用 ssh-keygen 命令生成一组新的 id_rsa_new 和 id_rsa_new.pub</h3><pre class=" language-javascript"><code class="language-javascript">ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa <span class="token operator">-</span>C <span class="token string">"new email"</span></code></pre><blockquote><p>需要注意，出现提示输入文件名的时候要输入与默认配置不一样的文件名，比如： id_rsa_new</p></blockquote><h3 id="3-gt-执行-ssh-agent-让-ssh-识别新的私钥"><a href="#3-gt-执行-ssh-agent-让-ssh-识别新的私钥" class="headerlink" title="3&gt;执行 ssh-agent 让 ssh 识别新的私钥"></a>3&gt;执行 ssh-agent 让 ssh 识别新的私钥</h3><pre class=" language-javascript"><code class="language-javascript">ssh<span class="token operator">-</span>add <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>ssh<span class="token operator">/</span>id_rsa_new</code></pre><h3 id="4-gt-添加-SSH-到钥匙串"><a href="#4-gt-添加-SSH-到钥匙串" class="headerlink" title="4&gt;添加 SSH 到钥匙串"></a>4&gt;添加 SSH 到钥匙串</h3><pre class=" language-javascript"><code class="language-javascript">ssh<span class="token operator">-</span>add <span class="token operator">-</span>K KeyPathOrKeyName</code></pre>]]></content>
      
      
      <categories>
          
          <category> ssh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac 使用 homebrew</title>
      <link href="/leader755/65348.html"/>
      <url>/leader755/65348.html</url>
      
        <content type="html"><![CDATA[<p>使用 brew update 指令</p><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><p>Error: The following directories are not writable by your user:<br>/usr/local/sbin<br>/usr/local/share/man/man5<br>/usr/local/share/man/man7</p><p>解决办法：</p><pre class=" language-javascript"><code class="language-javascript">sudo chown <span class="token operator">-</span>R <span class="token function">$</span><span class="token punctuation">(</span>whoami<span class="token punctuation">)</span> <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token operator">*</span></code></pre><p>重新调用即可：</p><pre><code>brew update</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> homebrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat下部署vue项目[history模式]</title>
      <link href="/leader755/14064.html"/>
      <url>/leader755/14064.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-项目发布后通常有两种访问方式，"><a href="#1-项目发布后通常有两种访问方式，" class="headerlink" title="1.项目发布后通常有两种访问方式，"></a>1.项目发布后通常有两种访问方式，</h2><p>第一种： IP+端口直接访问的方式，如 <a href="http://192.168.4.160:6090/" target="_blank" rel="noopener">http://192.168.1.107:8080/</a><br>第二种：IP+端口+项目名，如 <a href="https://links.jianshu.com/go?to=http%3A%2F%2F192.168.4.160%3A6090%2Fhuangshi%2F" target="_blank" rel="noopener">http://192.168.1.107:8080/saas/</a></p><h2 id="2-第一种方式：ip-端口（前端后端修改）"><a href="#2-第一种方式：ip-端口（前端后端修改）" class="headerlink" title="2.第一种方式：ip+端口（前端后端修改）"></a>2.第一种方式：ip+端口（前端后端修改）</h2><p>范例：vue-cli 项目使用路由，tomcat 作为服务器，项目文件夹名 saas</p><p>步骤：</p><h3 id="1-修改配置文件-router-js"><a href="#1-修改配置文件-router-js" class="headerlink" title="1.修改配置文件 router.js"></a>1.修改配置文件 router.js</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  mode<span class="token punctuation">:</span> <span class="token string">"history"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 将mode值改为history</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">"HelloWorld"</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> HelloWorld<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-1-将-tomcat-下的-ROOT-文件中的内容替换-选择其一"><a href="#2-1-将-tomcat-下的-ROOT-文件中的内容替换-选择其一" class="headerlink" title="2.1 将 tomcat 下的 ROOT 文件中的内容替换(选择其一)"></a>2.1 将 tomcat 下的 ROOT 文件中的内容替换(选择其一)</h3><p>（此种方式需要删除 ROOT 文件夹下的全部内容，将打包的文件放进去，无需修改配置文件）<br><strong>找到 tomcat 目录，将 tomcat-&gt;ROOT 文件夹中文件全部删除，将打包好的 dist 文件夹中的文件全部放到 ROOT 文件夹中。</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1579239963286-48f67f71-308e-49dc-9953-8cc2cc1be528.png#align=left&display=inline&height=166&margin=%5Bobject%20Object%5D&name=image.png&originHeight=331&originWidth=1486&size=32467&status=done&style=none&width=743" alt="image.png"></p><h3 id="2-2-修改-tomcat-gt-conf-server-xml-配置-选择其一"><a href="#2-2-修改-tomcat-gt-conf-server-xml-配置-选择其一" class="headerlink" title="2.2 修改 tomcat-&gt;conf/server.xml 配置(选择其一)"></a>2.2 修改 tomcat-&gt;conf/server.xml 配置(选择其一)</h3><p>(此种方式无需删除 ROOT 文件夹中的内容，只需修改 serve.xml 中的配置)<br><strong>找到 tomcat 目录，修改 tomcat-&gt;conf/server.xml，增加 Context 节点。设置 docBase=”/saas” 。其中的 saas 就是 webapps 目录下的项目名称（文件夹名）</strong><br>**<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1579153518666-35db848d-44c8-411f-a40d-02dc81ae9ae8.png#align=left&display=inline&height=696&margin=%5Bobject%20Object%5D&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200116134505.png&originHeight=696&originWidth=1277&size=80321&status=done&style=none&width=1277" alt="微信图片_20200116134505.png"></p><h2 id="3-第二种方式：ip-端口-项目名（前端修改）"><a href="#3-第二种方式：ip-端口-项目名（前端修改）" class="headerlink" title="3.第二种方式：ip+端口+项目名（前端修改）"></a>3.第二种方式：ip+端口+项目名（前端修改）</h2><p>范例：vue-cli 项目使用路由，tomcat 作为服务器，项目文件夹名 saas</p><p>步骤：</p><h3 id="1-首先创建-WEB-INF-文件，文件夹中创建-web-xml-文件："><a href="#1-首先创建-WEB-INF-文件，文件夹中创建-web-xml-文件：" class="headerlink" title="1.首先创建 WEB-INF 文件，文件夹中创建 web.xml 文件："></a>1.首先创建 WEB-INF 文件，文件夹中创建 web.xml 文件：</h3><p>因为是 history 模式, 要防止在路由下刷新变成 404 错误，这需要让 tomcat 都定位到首页，也就是 index.html 页，以往我们使用 Java 写 web 项目部署在 tomcat 时，通常都会有一个 WEB-INF 文件夹，并包含一个 web.xml 文件，而 vue 项目 build 之后只是纯静态资源项目，所以我们需要在 build 之后的 dist 文件夹里新增一个 WEB-INF 文件夹，并新建 web.xml 文件。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1579014872343-c8253ec9-d3d5-4b53-bda6-3983472244ae.png#align=left&display=inline&height=421&margin=%5Bobject%20Object%5D&name=image.png&originHeight=842&originWidth=482&size=57023&status=done&style=none&width=241" alt="image.png"></p><p><strong>在项目目录下新建**</strong><code>WEB-INF</code>*<strong>*文件夹， 接着在**</strong><code>WEB-INF</code>*<strong>*文件夹下新建 **</strong><code>web.xml</code>*<strong>*文件，内容如下：</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version='1.0' encoding='UTF-8'?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee/web-app_2_5.xsd<span class="token punctuation">"</span></span>         <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>scplatform<span class="token punctuation">"</span></span> <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2.5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-page</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-code</span><span class="token punctuation">></span></span>404<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-code</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">></span></span>/index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-page</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">></span></span></code></pre><h3 id="2-修改配置文件-router-js"><a href="#2-修改配置文件-router-js" class="headerlink" title="2.修改配置文件 router.js"></a>2.修改配置文件 router.js</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  mode<span class="token punctuation">:</span> <span class="token string">"history"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 开启history模式需要后端配置404时返回/index.html</span>  base<span class="token punctuation">:</span> <span class="token string">"/saas/"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//当项目不在根目录时，必须添加子目录路径，否则空白页面</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">"/home"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// '/saas/home'</span>      name<span class="token punctuation">:</span> <span class="token string">"home"</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> home<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="3-修改-config-文件夹下的-index-js-中配置"><a href="#3-修改-config-文件夹下的-index-js-中配置" class="headerlink" title="3.修改 config 文件夹下的 index.js 中配置"></a>3.修改 config 文件夹下的 index.js 中配置</h3><pre class=" language-javascript"><code class="language-javascript">build<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Template for index.html</span>    index<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"../dist/index.html"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// Paths</span>    assetsRoot<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"../dist"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//构建输出目录,也就是构建后的东西都扔这里</span>    assetsSubDirectory<span class="token punctuation">:</span> <span class="token string">"static"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//源子目录 除了index.html，其余的js img css都分在这里</span>    <span class="token comment" spellcheck="true">/**添加开始**/</span>    <span class="token comment" spellcheck="true">//tomcat webapps/sass/</span>    assetsPublicPath<span class="token punctuation">:</span> <span class="token string">"/saas/"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//需要加上这一行项目目录,一个 / 表示根目录</span>        <span class="token comment" spellcheck="true">/**添加结束**/</span>  <span class="token punctuation">}</span></code></pre><h3 id="4-webpack-设置不打包文件WEB-INF"><a href="#4-webpack-设置不打包文件WEB-INF" class="headerlink" title="4.webpack 设置不打包文件WEB-INF"></a>4.webpack 设置不打包文件<code>WEB-INF</code></h3><p>到此处已经可以成功配置一个 tomcat 服务下的 vue 的 history 模式的项目，但是不能每次打包去手动<strong>添加和更改新建<code>WEB-INF</code>文件夹</strong>吧，遇到过设置不打包文件 WEB-INF 文件时的配置未生效，导致 WEB-INF 下的 web.xml 文件被打包成 js 文件，导致当前路由刷新报 404 错误。<br>(这个错误找了 好久，以为配置好了，就 Ok 了，由于代码同步问题，没注意可能就发生问题，所以上传服务器前一定要记得检查下<strong><code>WEB-INF</code>文件夹是否存在 web.xml 文件</strong>)</p><p><strong>修改 webpack.prod.conf.js 配置</strong></p><pre class=" language-javascript"><code class="language-javascript">plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>  <span class="token comment" spellcheck="true">// copy custom static assets</span>  <span class="token keyword">new</span> <span class="token class-name">CopyWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token keyword">from</span><span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"../static"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      to<span class="token punctuation">:</span> config<span class="token punctuation">.</span>build<span class="token punctuation">.</span>assetsSubDirectory<span class="token punctuation">,</span>      ignore<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">".*"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/**添加开始**/</span>    <span class="token punctuation">{</span>      <span class="token keyword">from</span><span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">"../WEB-INF"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 不打包直接输出的文件</span>      to<span class="token punctuation">:</span> <span class="token string">"dist"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 打包后静态文件放置位置</span>      ignore<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">".*"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 忽略规则。（这种写法表示将该文件夹下的所有文件都复制）</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">/**添加结束**/</span>  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>关于此处的的设置不打包问题可以自行搜索，关键词：<strong>webpack 设置不打包文件</strong><br>**<br>**</p><h3 id="5-到此处前端已经成功配置了-tomcat-下-vue-的-history-模式"><a href="#5-到此处前端已经成功配置了-tomcat-下-vue-的-history-模式" class="headerlink" title="5.到此处前端已经成功配置了 tomcat 下 vue 的 history 模式"></a>5.到此处前端已经成功配置了 tomcat 下 vue 的 history 模式</h3><p>项目最终目录如下图<br><img src="https://cdn.nlark.com/yuque/0/2020/png/241787/1579015282523-603258d7-6c26-49bd-8f0c-cb6453d65a11.png#align=left&display=inline&height=464&margin=%5Bobject%20Object%5D&name=image.png&originHeight=928&originWidth=504&size=64927&status=done&style=none&width=252" alt="image.png"></p><h3 id="6-注意-vue-cli-3-x-vue-cli-打包配置还需要设置以下内容："><a href="#6-注意-vue-cli-3-x-vue-cli-打包配置还需要设置以下内容：" class="headerlink" title="6.注意 vue-cli 3.x vue-cli 打包配置还需要设置以下内容："></a>6.注意 vue-cli 3.x vue-cli 打包配置还需要设置以下内容：</h3><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  publicPath<span class="token punctuation">:</span> <span class="token string">"/saas"</span><span class="token punctuation">,</span>  configureWebpack<span class="token punctuation">:</span> <span class="token punctuation">{</span>    performance<span class="token punctuation">:</span> <span class="token punctuation">{</span>      hints<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4.结语"></a>4.结语</h2><p>终于完成了，也是踩了不少坑和加上一些搜索，感觉目前给的文档都不太详细，所以自己写了一篇关于 tomcat 下的 vue 的 history 模式，希望能帮到大家，欢迎大家一起交流。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> history </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给文件添加一个.gitignore</title>
      <link href="/leader755/54468.html"/>
      <url>/leader755/54468.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-WHY"><a href="#1-WHY" class="headerlink" title="1.WHY?"></a>1.WHY?</h2><p>.gitignore 文件只要在这个文件中申明那些文件你不希望添加到 git 中去，这样当你使用<code>git add .</code>这些文件就会被自动忽略掉</p><h2 id="2-忽略文件的原则"><a href="#2-忽略文件的原则" class="headerlink" title="2.忽略文件的原则"></a>2.忽略文件的原则</h2><ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的.class 文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ul><h2 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3.使用方法"></a>3.使用方法</h2><p>首先，在你的工作区新建一个名称为<code>.gitignore</code>的文件。<br>然后，把要忽略的文件名填进去，Git 就会自动忽略这些文件。<br>不需要从头写.gitignore 文件，GitHub 已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://link.jianshu.com?t=https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p><h2 id="4-例子"><a href="#4-例子" class="headerlink" title="4.例子"></a>4.例子</h2><p>比如你的项目是 java 项目，<code>.java</code>文件编译后会生成<code>.class</code>文件，这些文件多数情况下是不想被传到仓库中的文件。这时候你可以直接适用 github 的.gitignore 文件模板。<a href="https://link.jianshu.com?t=https://github.com/github/gitignore/blob/master/Java.gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore/blob/master/Java.gitignore</a> 将这些忽略文件信息复制到你的.gitignore 文件中去：</p><pre><code>*.class# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.ear# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*</code></pre><p>可以看到 github 为我们提供了最流行的.gitignore 文件配置。<br>保存.ignore 文件后我们查看下 git status，检查下是否还有我们不需要的文件会被添加到 git 中去：</p><pre><code>$ git statusOn branch masterInitial commitChanges to be committed:  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)        new file:   .gitignore        new file:   HelloWorld.javaUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        Config.ini</code></pre><p>比如我的项目目录下有一个 Config.ini 文件，这个是个本地配置文件我不希望上传到 git 中去，我们可以在 gitignore 文件中添加这样的配置：</p><pre class=" language-javascript"><code class="language-javascript">Config<span class="token punctuation">.</span>ini<span class="token punctuation">;</span></code></pre><p>或者你想忽略所有的.ini 文件你可以这样写：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">*</span><span class="token punctuation">.</span>ini</code></pre><p>如果有些文件已经被你忽略了，当你使用<code>git add</code>时是无法添加的，比如我忽略了<code>*.class</code>，现在我想把<code>HelloWorld.class</code>添加到 git 中去：</p><pre class=" language-javascript"><code class="language-javascript">$ git add HelloWorld<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token class-name">The</span> following paths are ignored by one <span class="token keyword">of</span> your <span class="token punctuation">.</span>gitignore files<span class="token punctuation">:</span>HelloWorld<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token class-name">Use</span> <span class="token operator">-</span>f <span class="token keyword">if</span> you really want to add them<span class="token punctuation">.</span></code></pre><p>git 会提示我们这个文件已经被我们忽略了，需要加上<code>-f</code>参数才能强制添加到 git 中去：</p><pre class=" language-javascript"><code class="language-javascript">$ git statusOn branch masterInitial commitChanges to be committed<span class="token punctuation">:</span>  <span class="token punctuation">(</span>use <span class="token string">"git rm --cached &lt;file>..."</span> to unstage<span class="token punctuation">)</span>        <span class="token keyword">new</span> <span class="token class-name">file</span><span class="token punctuation">:</span>   <span class="token punctuation">.</span>gitignore        <span class="token keyword">new</span> <span class="token class-name">file</span><span class="token punctuation">:</span>   HelloWorld<span class="token punctuation">.</span><span class="token keyword">class</span>        <span class="token class-name">new</span> file<span class="token punctuation">:</span>   HelloWorld<span class="token punctuation">.</span>java</code></pre><p>这样就能强制添加到缓存中去了。<br>如果我们意外的将想要忽略的文件添加到缓存中去了，我们可以使用<code>rm</code>命令将其从中移除：</p><pre class=" language-javascript"><code class="language-javascript">$ git rm HelloWorld<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">--</span>cachedrm <span class="token string">'HelloWorld.class'</span></code></pre><p>如果你已经把不想上传的文件上传到了 git 仓库，那么你必须先从远程仓库删了它，我们可以从远程仓库直接删除然后 pull 代码到本地仓库这些文件就会本删除，或者从本地删除这些文件并且在.gitignore 文件中添加这些你想忽略的文件，然后再 push 到远程仓库。</p><h2 id="5-查看-gitignore-规则"><a href="#5-查看-gitignore-规则" class="headerlink" title="5.查看 gitignore 规则"></a>5.查看 gitignore 规则</h2><p>如果你发下<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p><pre class=" language-javascript"><code class="language-javascript">$ git check<span class="token operator">-</span>ignore <span class="token operator">-</span>v HelloWorld<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token class-name"><span class="token punctuation">.</span>gitignore</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token keyword">class</span>    <span class="token class-name">HelloWorld<span class="token punctuation">.</span>class</span></code></pre><p>可以看到<code>HelloWorld.class</code>匹配到了我们的第一条<code>*.class</code>的忽略规则所以文件被忽略了。</p><h2 id="6-忽略规则文件语法"><a href="#6-忽略规则文件语法" class="headerlink" title="6.忽略规则文件语法"></a>6.忽略规则文件语法</h2><h3 id="a-忽略指定文件-目录"><a href="#a-忽略指定文件-目录" class="headerlink" title="a.忽略指定文件/目录"></a>a.忽略指定文件/目录</h3><pre class=" language-javascript"><code class="language-javascript"># 忽略指定文件HelloWrold<span class="token punctuation">.</span><span class="token keyword">class</span># 忽略指定文件夹bin<span class="token operator">/</span>bin<span class="token regex">/gen/</span></code></pre><h3 id="b-通配符忽略规则"><a href="#b-通配符忽略规则" class="headerlink" title="b.通配符忽略规则"></a>b.通配符忽略规则</h3><p>通配符规则如下：</p><pre class=" language-javascript"><code class="language-javascript"># 忽略<span class="token punctuation">.</span><span class="token keyword">class</span>的所有文件<span class="token operator">*</span><span class="token punctuation">.</span><span class="token keyword">class</span># 忽略名称中末尾为ignore的文件夹<span class="token operator">*</span>ignore<span class="token operator">/</span># 忽略名称中间包含ignore的文件夹<span class="token operator">*</span>ignore<span class="token operator">*</span><span class="token operator">/</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitignore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序中setData修改属性值</title>
      <link href="/leader755/16589.html"/>
      <url>/leader755/16589.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-修改对象属性"><a href="#1-修改对象属性" class="headerlink" title="1.修改对象属性"></a>1.修改对象属性</h2><p>##</p><h3 id="1-gt-第一种"><a href="#1-gt-第一种" class="headerlink" title="1&gt;第一种"></a>1&gt;第一种</h3><pre class=" language-javascript"><code class="language-javascript"> changePerson<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'person.name'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      <span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'fxjzzyo'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>###</p><h3 id="2-gt-第二种"><a href="#2-gt-第二种" class="headerlink" title="2&gt;第二种"></a>2&gt;第二种</h3><pre class=" language-javascript"><code class="language-javascript">changePerson<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      <span class="token string">'person.name'</span><span class="token punctuation">:</span> <span class="token string">'fxjzzyo'</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>#</p><h2 id="2-修改数组属性"><a href="#2-修改数组属性" class="headerlink" title="2.修改数组属性"></a>2.修改数组属性</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token punctuation">[</span><span class="token string">"array["</span> <span class="token operator">+</span> index <span class="token operator">+</span> <span class="token string">"].amount"</span><span class="token punctuation">]</span><span class="token punctuation">:</span> amount<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> setData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.搭建本地的 hexo 的博客</title>
      <link href="/leader755/7894.html"/>
      <url>/leader755/7894.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-gt-官方文档-https-github-com-hexojs-hexo"><a href="#1-gt-官方文档-https-github-com-hexojs-hexo" class="headerlink" title="1&gt;官方文档   https://github.com/hexojs/hexo"></a>1&gt;官方文档   <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a></h2><h2 id="2-gt-搭建博客"><a href="#2-gt-搭建博客" class="headerlink" title="2&gt;搭建博客"></a>2&gt;搭建博客</h2><h3 id="1-全局安装-hexo，创建博客"><a href="#1-全局安装-hexo，创建博客" class="headerlink" title="1.全局安装 hexo，创建博客"></a>1.全局安装 hexo，创建博客</h3><pre class=" language-javascript"><code class="language-javascript">npm install hexo<span class="token operator">-</span>cli <span class="token operator">-</span>g</code></pre><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h3><pre class=" language-javascript"><code class="language-javascript">hexo init blog</code></pre><h3 id="3-启动本地-hexo-server"><a href="#3-启动本地-hexo-server" class="headerlink" title="3.启动本地 hexo-server"></a>3.启动本地 hexo-server</h3><pre class=" language-javascript"><code class="language-javascript">hexo server</code></pre><h2 id="4-新建一个-hexo-博客，富文本-makedown-文档"><a href="#4-新建一个-hexo-博客，富文本-makedown-文档" class="headerlink" title="4.新建一个 hexo 博客，富文本 makedown 文档"></a>4.新建一个 hexo 博客，富文本 makedown 文档</h2><pre class=" language-javascript"><code class="language-javascript">$ hexo <span class="token keyword">new</span> <span class="token string">"Hello Hexo"</span></code></pre><h2 id="5-打包发布到-hexo"><a href="#5-打包发布到-hexo" class="headerlink" title="5.打包发布到 hexo"></a>5.打包发布到 hexo</h2><pre><code>//打包发布 hexohexo generate//重启服务(可以看到新增的文档)hexo server</code></pre><h2 id="6-packge-json-的命令行（备份文件）"><a href="#6-packge-json-的命令行（备份文件）" class="headerlink" title="6.packge.json 的命令行（备份文件）"></a>6.packge.json 的命令行（备份文件）</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"build"</span><span class="token punctuation">:</span> <span class="token string">"hexo generate"</span><span class="token punctuation">,</span>    <span class="token string">"clean"</span><span class="token punctuation">:</span> <span class="token string">"hexo clean"</span><span class="token punctuation">,</span>    <span class="token string">"deploy"</span><span class="token punctuation">:</span> <span class="token string">"hexo deploy"</span><span class="token punctuation">,</span>    <span class="token string">"server"</span><span class="token punctuation">:</span> <span class="token string">"hexo server"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
